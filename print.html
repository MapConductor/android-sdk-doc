<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>MapConductor Android SDK Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">MapConductor Android SDK Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="mapconductor-android-sdk-documentation"><a class="header" href="#mapconductor-android-sdk-documentation">MapConductor Android SDK Documentation</a></h1>
<p>MapConductor is a unified mapping library that provides a common API for multiple map providers including Google Maps, Mapbox, HERE, and ArcGIS. This documentation covers the public API components available through Maven distribution.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>The MapConductor SDK allows you to use a single API to work with different map providers. The SDK automatically handles provider-specific implementations while providing a consistent interface for your application.</p>
<h3 id="supported-map-providers"><a class="header" href="#supported-map-providers">Supported Map Providers</a></h3>
<ul>
<li><strong>Google Maps</strong>: <code>GoogleMapViewStateImpl</code></li>
<li><strong>Mapbox</strong>: <code>MapboxViewStateImpl</code></li>
<li><strong>HERE Maps</strong>: <code>HereViewStateImpl</code></li>
<li><strong>ArcGIS</strong>: <code>ArcGISMapViewStateImpl</code></li>
</ul>
<h3 id="core-classes"><a class="header" href="#core-classes">Core Classes</a></h3>
<p>The SDK provides fundamental geographic classes:</p>
<ul>
<li><strong>GeoPoint</strong>: Represents geographic coordinates (latitude, longitude, altitude)</li>
<li><strong>GeoRectBounds</strong>: Defines rectangular geographic areas with southwest/northeast corners</li>
</ul>
<h3 id="key-components"><a class="header" href="#key-components">Key Components</a></h3>
<p>The SDK provides the following core components:</p>
<ol>
<li><strong>MapViewComponent</strong>: Provider-specific map view components (GoogleMapsView, MapboxMapView, etc.)</li>
<li><strong>Marker</strong>: Point markers with customizable icons and interactions</li>
<li><strong>Circle</strong>: Circular overlays with styling options</li>
<li><strong>Polyline</strong>: Line segments connecting multiple points</li>
<li><strong>Polygon</strong>: Filled shapes with stroke and fill styling</li>
<li><strong>GroundImage</strong>: Image overlays positioned geographically</li>
</ol>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>To use MapConductor in your project:</p>
<h3 id="1-installation"><a class="header" href="#1-installation">1. Installation</a></h3>
<p>See the <a href="./installation.html">Installation and Versions</a> page for complete dependency information and version details.</p>
<h3 id="2-sdk-specific-setup"><a class="header" href="#2-sdk-specific-setup">2. SDK-Specific Setup</a></h3>
<blockquote>
<p><strong>Important</strong>: MapConductor provides a unified API layer on top of existing map SDKs. You must set up each map SDK independently before using MapConductor’s integration.</p>
</blockquote>
<p>Each map provider requires its own SDK setup with API keys, permissions, and configuration:</p>
<ul>
<li><strong><a href="./setup/google-maps.html">Google Maps Setup</a></strong> - Configure Google Maps SDK with API keys and permissions</li>
<li><strong><a href="./setup/mapbox.html">Mapbox Setup</a></strong> - Set up Mapbox access tokens and style configuration</li>
<li><strong><a href="./setup/here-maps.html">HERE Maps Setup</a></strong> - Configure HERE SDK with API keys and licensing</li>
<li><strong><a href="./setup/arcgis.html">ArcGIS Maps Setup</a></strong> - Set up ArcGIS SDK with API keys and licensing</li>
</ul>
<p><strong>Choose the setup guide(s) for your target map provider(s).</strong> You only need to configure the SDKs you plan to use in your application.</p>
<h3 id="3-basic-usage"><a class="header" href="#3-basic-usage">3. Basic Usage</a></h3>
<p>Create a map view with markers:</p>
<pre><code class="language-kotlin">@Composable
fun BasicMapExample() {
    // Choose your map provider
    val mapViewState = rememberGoogleMapViewState()

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(
        state = mapViewState,
        onMapClick = { geoPoint -&gt;
            println("Map clicked at: ${geoPoint.latitude}, ${geoPoint.longitude}")
        },
        onMarkerClick = { markerState -&gt;
            println("Marker clicked: ${markerState.extra}")
        }
    ) {
        // Add a marker
        Marker(
            position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
            icon = DefaultIcon(label = "SF"),
            extra = "San Francisco marker"
        )

        // Add a circle
        Circle(
            center = GeoPointImpl.fromLatLong(37.7749, -122.4194),
            radius = 1000.0,
            strokeColor = Color.Blue,
            fillColor = Color.Blue.copy(alpha = 0.3f)
        )
    }
}
</code></pre>
<h3 id="4-switching-map-providers"><a class="header" href="#4-switching-map-providers">4. Switching Map Providers</a></h3>
<p>To switch between map providers, simply change the <code>MapViewState</code> implementation:</p>
<pre><code class="language-kotlin">// Google Maps
val googleMapState = GoogleMapViewStateImpl()

// Mapbox
val mapboxState = MapboxViewStateImpl()

// HERE Maps
val hereState = HereViewStateImpl()

// ArcGIS
val arcgisState = ArcGISMapViewStateImpl()
</code></pre>
<p>The rest of your code remains the same - all components work consistently across providers.</p>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<h3 id="compose-integration"><a class="header" href="#compose-integration">Compose Integration</a></h3>
<p>All components are built for Jetpack Compose with:</p>
<ul>
<li>Reactive state updates</li>
<li>Automatic lifecycle management</li>
<li>Declarative UI patterns</li>
</ul>
<h3 id="event-handling"><a class="header" href="#event-handling">Event Handling</a></h3>
<p>Rich event system supporting:</p>
<ul>
<li>Map clicks and long presses</li>
<li>Marker interactions (click, drag)</li>
<li>Overlay interactions</li>
<li>Animation events</li>
</ul>
<h3 id="customization"><a class="header" href="#customization">Customization</a></h3>
<p>Extensive customization options:</p>
<ul>
<li>Custom marker icons and styling</li>
<li>Overlay appearance and behavior</li>
<li>Animation and interaction settings</li>
<li>Provider-specific optimizations</li>
</ul>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Explore the detailed documentation for each component to learn about their properties, methods, and usage patterns.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation-and-versions"><a class="header" href="#installation-and-versions">Installation and Versions</a></h1>
<p>This page provides complete installation instructions and version information for all MapConductor Android SDK modules.</p>
<h2 id="current-version"><a class="header" href="#current-version">Current Version</a></h2>
<p><strong>Latest Release</strong>: <code>1.0.0</code></p>
<h2 id="versioning-strategy"><a class="header" href="#versioning-strategy">Versioning Strategy</a></h2>
<p>MapConductor follows a unified versioning approach across all modules:</p>
<h3 id="major-version-alignment"><a class="header" href="#major-version-alignment">Major Version Alignment</a></h3>
<ul>
<li>All modules share the same <strong>major version</strong> to ensure compatibility</li>
<li>When any core module requires breaking changes, all modules increment their major version together</li>
</ul>
<h3 id="core-module-versioning"><a class="header" href="#core-module-versioning">Core Module Versioning</a></h3>
<ul>
<li><strong>Minor version</strong> increments when:
<ul>
<li>Map provider SDKs receive major updates requiring significant API changes</li>
<li>New core components are added due to expanded map provider capabilities</li>
<li>Significant new features are introduced to the unified API</li>
</ul>
</li>
<li><strong>Patch version</strong> increments for:
<ul>
<li>Bug fixes and stability improvements</li>
<li>Performance optimizations</li>
<li>Documentation updates</li>
</ul>
</li>
</ul>
<h3 id="experimental-module-versioning"><a class="header" href="#experimental-module-versioning">Experimental Module Versioning</a></h3>
<ul>
<li><strong>Major version</strong> increments when:
<ul>
<li>New significant features or icon types are added</li>
<li>Breaking API changes are introduced</li>
<li>Module graduates from experimental to stable</li>
</ul>
</li>
<li><strong>Patch version</strong> increments for:
<ul>
<li>Minor bug fixes and improvements</li>
<li>Small additions that don’t break existing APIs</li>
</ul>
</li>
</ul>
<h2 id="core-modules"><a class="header" href="#core-modules">Core Modules</a></h2>
<h3 id="required-modules"><a class="header" href="#required-modules">Required Modules</a></h3>
<h4 id="mapconductor-bom"><a class="header" href="#mapconductor-bom">mapconductor-bom</a></h4>
<p>The bom module containing version information.</p>
<pre><code class="language-kotlin">implementation "com.mapconductor:mapconductor-bom:1.0.0"
</code></pre>
<p><strong>Required for</strong>: All MapConductor usage
<strong>Size</strong>: ~XXX KB</p>
<h4 id="core"><a class="header" href="#core">core</a></h4>
<p>The core module containing shared functionality and base classes.</p>
<pre><code class="language-kotlin">implementation "com.mapconductor:core"
</code></pre>
<p><strong>Required for</strong>: All MapConductor usage
<strong>Dependencies</strong>: Jetpack Compose, Kotlin Coroutines
<strong>Size</strong>: ~XXX KB</p>
<h3 id="map-provider-modules"><a class="header" href="#map-provider-modules">Map Provider Modules</a></h3>
<p>Choose one or more map provider modules based on your needs:</p>
<h4 id="for-googlemaps"><a class="header" href="#for-googlemaps">for-googlemaps</a></h4>
<p>Google Maps integration module.</p>
<pre><code class="language-kotlin">implementation "com.mapconductor:for-googlemaps"
</code></pre>
<p><strong>Provides</strong>: GoogleMapsView, GoogleMapViewStateImpl
<strong>Requires</strong>: Google Maps SDK setup
<strong>Size</strong>: ~XXX KB</p>
<h4 id="for-mapbox"><a class="header" href="#for-mapbox">for-mapbox</a></h4>
<p>Mapbox integration module.</p>
<pre><code class="language-kotlin">implementation "com.mapconductor:for-mapbox"
</code></pre>
<p><strong>Provides</strong>: MapboxMapView, MapboxViewStateImpl
<strong>Requires</strong>: Mapbox SDK setup
<strong>Size</strong>: ~XXX KB</p>
<h4 id="for-here"><a class="header" href="#for-here">for-here</a></h4>
<p>HERE Maps integration module.</p>
<pre><code class="language-kotlin">implementation "com.mapconductor:for-here"
</code></pre>
<p><strong>Provides</strong>: HereMapView, HereViewStateImpl
<strong>Requires</strong>: HERE SDK setup
<strong>Size</strong>: ~XXX KB</p>
<h4 id="for-arcgis"><a class="header" href="#for-arcgis">for-arcgis</a></h4>
<p>ArcGIS integration module.</p>
<pre><code class="language-kotlin">implementation "com.mapconductor:for-arcgis"
</code></pre>
<p><strong>Provides</strong>: ArcGISMapView, ArcGISMapViewStateImpl
<strong>Requires</strong>: ArcGIS SDK setup
<strong>Size</strong>: ~XXX KB</p>
<h2 id="experimental-modules"><a class="header" href="#experimental-modules">Experimental Modules</a></h2>
<blockquote>
<p><strong>⚠️ Experimental</strong>: These modules are experimental and may change significantly in future versions.</p>
</blockquote>
<h3 id="icons"><a class="header" href="#icons">icons</a></h3>
<p>Custom marker icons with programmatic styling.</p>
<pre><code class="language-kotlin">implementation "com.mapconductor:icons"
</code></pre>
<p><strong>Provides</strong>: CircleIcon, FlagIcon
<strong>Stability</strong>: Experimental
<strong>Size</strong>: ~XXX KB</p>
<h3 id="marker-strategy"><a class="header" href="#marker-strategy">marker-strategy</a></h3>
<p>Advanced marker rendering strategies for performance optimization.</p>
<pre><code class="language-kotlin">implementation "com.mapconductor:marker-strategy"
</code></pre>
<p><strong>Provides</strong>: DefaultMarkerRenderingStrategy, SpatialMarkerRenderingStrategy
<strong>Stability</strong>: Experimental
<strong>Size</strong>: ~XXX KB</p>
<h3 id="marker-native-strategy"><a class="header" href="#marker-native-strategy">marker-native-strategy</a></h3>
<p>High-performance native C++ marker management.</p>
<pre><code class="language-kotlin">implementation "com.mapconductor:marker-native-strategy"
</code></pre>
<p><strong>Provides</strong>: NativeMarkerManager, SimpleNativeParallelStrategy
<strong>Requires</strong>: Native library support (arm64-v8a, armeabi-v7a, x86, x86_64)
<strong>Stability</strong>: Highly Experimental
<strong>Size</strong>: ~XXX KB + native libraries</p>
<h2 id="complete-installation-examples"><a class="header" href="#complete-installation-examples">Complete Installation Examples</a></h2>
<h3 id="basic-installation-single-provider"><a class="header" href="#basic-installation-single-provider">Basic Installation (Single Provider)</a></h3>
<pre><code class="language-kotlin">dependencies {
    // Bom module (required)
    implementation "com.mapconductor:mapconductor-bom:1.0.0"
    // Core module (required)
    implementation "com.mapconductor:core"

    // Choose one map provider
    implementation "com.mapconductor:for-googlemaps"
}
</code></pre>
<h3 id="multi-provider-installation"><a class="header" href="#multi-provider-installation">Multi-Provider Installation</a></h3>
<pre><code class="language-kotlin">dependencies {
    // Bom module (required)
    implementation "com.mapconductor:mapconductor-bom:1.0.0"
    // Core module (required)
    implementation "com.mapconductor:core"

    // Multiple map providers
    implementation "com.mapconductor:for-googlemaps"
    implementation "com.mapconductor:for-mapbox"
    implementation "com.mapconductor:for-here"
    implementation "com.mapconductor:for-arcgis"
}
</code></pre>
<h3 id="full-installation-all-modules"><a class="header" href="#full-installation-all-modules">Full Installation (All Modules)</a></h3>
<pre><code class="language-kotlin">dependencies {
    // Bom module (required)
    implementation "com.mapconductor:mapconductor-bom:1.0.0"
    // Core module (required)
    implementation "com.mapconductor:core"

    // All map providers
    implementation "com.mapconductor:for-googlemaps"
    implementation "com.mapconductor:for-mapbox"
    implementation "com.mapconductor:for-here"
    implementation "com.mapconductor:for-arcgis"

    // Experimental modules (optional)
    implementation "com.mapconductor:icons"
    implementation "com.mapconductor:marker-strategy"
    implementation "com.mapconductor:marker-native-strategy"
}
</code></pre>
<h2 id="module-dependencies"><a class="header" href="#module-dependencies">Module Dependencies</a></h2>
<h3 id="dependency-graph"><a class="header" href="#dependency-graph">Dependency Graph</a></h3>
<pre><code>mapconductor-bom (base)
core (base)
├── googlemaps
├── for-mapbox
├── for-here
├── for-arcgis
├── icons
├── marker-strategy
└── marker-native-strategy
</code></pre>
<h3 id="external-dependencies"><a class="header" href="#external-dependencies">External Dependencies</a></h3>
<p>Each module requires different external dependencies:</p>
<h4 id="core-module-dependencies"><a class="header" href="#core-module-dependencies">Core Module Dependencies</a></h4>
<ul>
<li><code>androidx.compose.ui:ui</code></li>
<li><code>androidx.compose.runtime:runtime</code></li>
<li><code>org.jetbrains.kotlinx:kotlinx-coroutines-android</code></li>
</ul>
<h4 id="google-maps-module"><a class="header" href="#google-maps-module">Google Maps Module</a></h4>
<ul>
<li><code>com.google.android.gms:play-services-maps</code></li>
<li><code>com.google.maps.android:maps-compose</code></li>
</ul>
<h4 id="mapbox-module"><a class="header" href="#mapbox-module">Mapbox Module</a></h4>
<ul>
<li><code>com.mapbox.maps:android</code></li>
<li><code>com.mapbox.extension:maps-compose</code></li>
</ul>
<h4 id="here-maps-module"><a class="header" href="#here-maps-module">HERE Maps Module</a></h4>
<ul>
<li><code>com.here.sdk:sdk-core</code></li>
<li><code>com.here.sdk:sdk-search</code></li>
</ul>
<h4 id="arcgis-module"><a class="header" href="#arcgis-module">ArcGIS Module</a></h4>
<ul>
<li><code>com.esri.arcgisruntime:arcgis-android</code></li>
</ul>
<h2 id="version-compatibility"><a class="header" href="#version-compatibility">Version Compatibility</a></h2>
<h3 id="mapconductor-version-matrix"><a class="header" href="#mapconductor-version-matrix">MapConductor Version Matrix</a></h3>
<div class="table-wrapper"><table><thead><tr><th>MapConductor</th><th>Min Android</th><th>Target Android</th><th>Kotlin</th><th>Compose</th></tr></thead><tbody>
<tr><td>1.0.0</td><td>API 26 (8.0)</td><td>API 35 (15)</td><td>1.9.x</td><td>1.7.x</td></tr>
</tbody></table>
</div>
<h3 id="map-provider-sdk-compatibility"><a class="header" href="#map-provider-sdk-compatibility">Map Provider SDK Compatibility</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Provider</th><th>SDK Version</th><th>MapConductor 1.0.0</th></tr></thead><tbody>
<tr><td>Google Maps</td><td>18.2.x+</td><td>✅ Compatible</td></tr>
<tr><td>Mapbox</td><td>11.x+</td><td>✅ Compatible</td></tr>
<tr><td>HERE</td><td>4.23.x+</td><td>✅ Compatible</td></tr>
<tr><td>ArcGIS</td><td>200.x+</td><td>✅ Compatible</td></tr>
</tbody></table>
</div>
<h2 id="gradle-configuration"><a class="header" href="#gradle-configuration">Gradle Configuration</a></h2>
<h3 id="project-level-buildgradle"><a class="header" href="#project-level-buildgradle">Project-level build.gradle</a></h3>
<pre><code class="language-kotlin">buildscript {
    ext {
        compose_version = '1.7.1'
        kotlin_version = '1.9.25'
    }
}
</code></pre>
<h3 id="module-level-buildgradle"><a class="header" href="#module-level-buildgradle">Module-level build.gradle</a></h3>
<pre><code class="language-kotlin">android {
    compileSdk 35

    defaultConfig {
        minSdk 26
        targetSdk 35
    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_17
        targetCompatibility JavaVersion.VERSION_17
    }

    kotlinOptions {
        jvmTarget = '17'
    }

    buildFeatures {
        compose true
    }

    composeOptions {
        kotlinCompilerExtensionVersion compose_version
    }
}
</code></pre>
<h3 id="proguard-configuration"><a class="header" href="#proguard-configuration">ProGuard Configuration</a></h3>
<p>For release builds, add these ProGuard rules:</p>
<pre><code class="language-proguard"># MapConductor Core
-keep class com.mapconductor.core.** { *; }

# Map Provider Specific
-keep class com.mapconductor.googlemaps.** { *; }
-keep class com.mapconductor.mapbox.** { *; }
-keep class com.mapconductor.here.** { *; }
-keep class com.mapconductor.arcgis.** { *; }

# Native Strategy (if using)
-keep class com.mapconductor.marker.nativestrategy.** { *; }
</code></pre>
<h2 id="version-updates"><a class="header" href="#version-updates">Version Updates</a></h2>
<h3 id="checking-for-updates"><a class="header" href="#checking-for-updates">Checking for Updates</a></h3>
<p>To check for the latest MapConductor version:</p>
<ol>
<li><strong>GitHub Releases</strong>: Check the <a href="https://github.com/mapconductor/android-sdk/releases">releases page</a></li>
<li><strong>Maven Central</strong>: Search for <code>com.mapconductor</code> on <a href="https://central.sonatype.com/">Maven Central</a></li>
<li><strong>Gradle Version Catalog</strong>: Use dependency version checking tools</li>
</ol>
<h3 id="updating-versions"><a class="header" href="#updating-versions">Updating Versions</a></h3>
<p>To update to a new MapConductor version:</p>
<pre><code class="language-kotlin">// Update all modules to the same version
def mapconductor_version = "1.1.0"  // New version

dependencies {
    implementation "com.mapconductor:mapconductor-bom:$mapconductor_version"
    implementation "com.mapconductor:core"
    implementation "com.mapconductor:for-googlemaps"
    // ... other modules
}
</code></pre>
<h2 id="release-notes"><a class="header" href="#release-notes">Release Notes</a></h2>
<h3 id="version-100-current"><a class="header" href="#version-100-current">Version 1.0.0 (Current)</a></h3>
<ul>
<li>Initial stable release</li>
<li>Support for Google Maps, Mapbox, HERE, and ArcGIS</li>
<li>Core components: Marker, Circle, Polyline, Polygon, GroundImage</li>
<li>Experimental modules: Icons, Marker Strategy, Native Strategy</li>
<li>Jetpack Compose integration</li>
<li>Android 8.0+ support</li>
</ul>
<h3 id="upcoming-releases"><a class="header" href="#upcoming-releases">Upcoming Releases</a></h3>
<p>Future versions will include:</p>
<ul>
<li>Additional map providers</li>
<li>Enhanced clustering algorithms</li>
<li>Offline map support</li>
<li>Performance improvements</li>
<li>New experimental features</li>
</ul>
<h2 id="support-and-compatibility"><a class="header" href="#support-and-compatibility">Support and Compatibility</a></h2>
<h3 id="minimum-requirements"><a class="header" href="#minimum-requirements">Minimum Requirements</a></h3>
<ul>
<li><strong>Android</strong>: API 26 (Android 8.0) or higher</li>
<li><strong>Kotlin</strong>: 1.9.0 or higher</li>
<li><strong>Jetpack Compose</strong>: 1.7.0 or higher</li>
<li><strong>Java</strong>: JDK 17 or higher</li>
</ul>
<h3 id="device-support"><a class="header" href="#device-support">Device Support</a></h3>
<ul>
<li><strong>ARM</strong>: arm64-v8a, armeabi-v7a (native strategy only)</li>
<li><strong>x86</strong>: x86, x86_64 (emulator support for native strategy)</li>
<li><strong>Memory</strong>: Minimum 2GB RAM recommended for large datasets</li>
</ul>
<p>For questions about versions or compatibility, please check the <a href="https://docs.mapconductor.com">documentation</a> or file an issue on <a href="https://github.com/mapconductor/android-sdk/issues">GitHub</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sdk-version-compatibility"><a class="header" href="#sdk-version-compatibility">SDK Version Compatibility</a></h1>
<p>This page shows the relationship between MapConductor versions and the underlying map SDK versions that each MapConductor module depends on.</p>
<h2 id="version-matrix"><a class="header" href="#version-matrix">Version Matrix</a></h2>
<h3 id="mapconductor-100"><a class="header" href="#mapconductor-100">MapConductor 1.0.0</a></h3>
<div class="table-wrapper"><table><thead><tr><th>MapConductor Module</th><th>Version</th><th>Underlying SDK</th><th>SDK Version</th><th>Notes</th></tr></thead><tbody>
<tr><td>mapconductor-core</td><td>1.0.0</td><td>-</td><td>-</td><td>Versioning dependency modules</td></tr>
<tr><td>core</td><td>1.0.0</td><td>-</td><td>-</td><td>Core abstractions and utilities</td></tr>
<tr><td>for-googlemaps</td><td>1.0.0</td><td>Google Play Services Maps</td><td>19.2.0</td><td>Stable, widely supported</td></tr>
<tr><td>for-mapbox</td><td>1.0.0</td><td>Mapbox Maps Android SDK</td><td>11.14.3</td><td>Uses NDK27 variant</td></tr>
<tr><td>for-here</td><td>1.0.0</td><td>HERE SDK Explore</td><td>4.23.2.0.210004</td><td>Local AAR dependency</td></tr>
<tr><td>for-arcgis</td><td>1.0.0</td><td>ArcGIS Maps SDK for Kotlin</td><td>200.7.0</td><td>Includes Compose toolkit</td></tr>
<tr><td>icons</td><td>1.0.0</td><td>-</td><td>-</td><td>Icon components</td></tr>
<tr><td>marker-strategy</td><td>1.0.0</td><td>-</td><td>-</td><td>Marker rendering strategies</td></tr>
<tr><td>marker-native-strategy</td><td>1.0.0</td><td>-</td><td>-</td><td>Native performance optimization</td></tr>
</tbody></table>
</div>
<h2 id="sdk-compatibility-notes"><a class="header" href="#sdk-compatibility-notes">SDK Compatibility Notes</a></h2>
<h3 id="google-maps-play-services-maps-1920"><a class="header" href="#google-maps-play-services-maps-1920">Google Maps (Play Services Maps 19.2.0)</a></h3>
<ul>
<li><strong>Stability</strong>: Production-ready, stable API</li>
<li><strong>Compatibility</strong>: Android API 21+ (same as MapConductor min SDK 26)</li>
<li><strong>Features</strong>: Full feature support including markers, circles, polylines, polygons</li>
<li><strong>Updates</strong>: Regular updates through Google Play Services</li>
</ul>
<h3 id="mapbox-11143"><a class="header" href="#mapbox-11143">Mapbox (11.14.3)</a></h3>
<ul>
<li><strong>Stability</strong>: Stable, enterprise-grade mapping solution</li>
<li><strong>Compatibility</strong>: Android API 21+ with NDK27 support</li>
<li><strong>Features</strong>: Advanced styling, custom data sources, 3D capabilities</li>
<li><strong>Notes</strong>: Requires Mapbox access token for production use</li>
</ul>
<h3 id="here-maps-42320210004"><a class="header" href="#here-maps-42320210004">HERE Maps (4.23.2.0.210004)</a></h3>
<ul>
<li><strong>Stability</strong>: Enterprise mapping solution</li>
<li><strong>Compatibility</strong>: Distributed as local AAR file</li>
<li><strong>Features</strong>: Professional-grade mapping with routing capabilities</li>
<li><strong>Installation</strong>: Requires manual AAR placement in <code>libs/</code> directory</li>
</ul>
<h3 id="arcgis-maps-20070"><a class="header" href="#arcgis-maps-20070">ArcGIS Maps (200.7.0)</a></h3>
<ul>
<li><strong>Stability</strong>: Professional GIS mapping platform</li>
<li><strong>Compatibility</strong>: Includes Jetpack Compose toolkit integration</li>
<li><strong>Features</strong>: Advanced GIS capabilities, spatial analysis</li>
<li><strong>Toolkit</strong>: Uses BOM for consistent version management</li>
</ul>
<h2 id="android-framework-dependencies"><a class="header" href="#android-framework-dependencies">Android Framework Dependencies</a></h2>
<h3 id="common-dependencies-all-modules"><a class="header" href="#common-dependencies-all-modules">Common Dependencies (All Modules)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Version</th><th>Purpose</th></tr></thead><tbody>
<tr><td>Android Gradle Plugin</td><td>8.10.1</td><td>Build system</td></tr>
<tr><td>Kotlin</td><td>2.0.21</td><td>Programming language</td></tr>
<tr><td>Jetpack Compose BOM</td><td>2025.05.00</td><td>UI framework version alignment</td></tr>
<tr><td>Compose Compiler</td><td>1.8.1</td><td>Compose compilation</td></tr>
<tr><td>AndroidX Core KTX</td><td>1.15.0</td><td>Android extensions</td></tr>
<tr><td>AndroidX Lifecycle</td><td>2.9.0</td><td>Lifecycle management</td></tr>
</tbody></table>
</div>
<h3 id="target-platform"><a class="header" href="#target-platform">Target Platform</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Setting</th><th>Value</th><th>Description</th></tr></thead><tbody>
<tr><td>Compile SDK</td><td>35</td><td>Android 15</td></tr>
<tr><td>Target SDK</td><td>35</td><td>Android 15</td></tr>
<tr><td>Min SDK</td><td>26</td><td>Android 8.0 (API level 26)</td></tr>
<tr><td>Java Version</td><td>17</td><td>JDK compatibility</td></tr>
</tbody></table>
</div>
<h2 id="version-update-strategy"><a class="header" href="#version-update-strategy">Version Update Strategy</a></h2>
<h3 id="mapconductor-versioning"><a class="header" href="#mapconductor-versioning">MapConductor Versioning</a></h3>
<p>MapConductor follows a unified versioning strategy across all modules:</p>
<ol>
<li><strong>Major Version</strong>: Updated when breaking API changes occur across the entire SDK</li>
<li><strong>Minor Version</strong>: Updated when new features are added to core modules or significant map SDK updates</li>
<li><strong>Patch Version</strong>: Updated for bug fixes and minor improvements</li>
</ol>
<h3 id="map-sdk-updates"><a class="header" href="#map-sdk-updates">Map SDK Updates</a></h3>
<p>Map SDK dependencies are updated based on:</p>
<ol>
<li><strong>Stability</strong>: Only stable, production-ready versions are used</li>
<li><strong>Feature Compatibility</strong>: Updates that maintain feature parity across providers</li>
<li><strong>Security</strong>: Critical security updates are applied promptly</li>
<li><strong>Performance</strong>: Updates that provide performance improvements</li>
</ol>
<h2 id="compatibility-testing"><a class="header" href="#compatibility-testing">Compatibility Testing</a></h2>
<h3 id="testing-matrix"><a class="header" href="#testing-matrix">Testing Matrix</a></h3>
<p>Each MapConductor release is tested against:</p>
<ul>
<li>All supported map provider SDKs</li>
<li>Minimum and target Android API levels</li>
<li>Various device configurations (phones, tablets)</li>
<li>Different Android versions (API 26-35)</li>
</ul>
<h3 id="known-issues"><a class="header" href="#known-issues">Known Issues</a></h3>
<ul>
<li>HERE SDK requires manual AAR management</li>
<li>Mapbox requires valid access token for all functionality</li>
<li>ArcGIS requires ArcGIS Developer account for some features</li>
</ul>
<h2 id="migration-guides"><a class="header" href="#migration-guides">Migration Guides</a></h2>
<h3 id="updating-map-sdk-dependencies"><a class="header" href="#updating-map-sdk-dependencies">Updating Map SDK Dependencies</a></h3>
<p>When updating to newer versions of underlying map SDKs:</p>
<ol>
<li><strong>Check compatibility</strong> with your MapConductor version</li>
<li><strong>Test thoroughly</strong> on your target devices</li>
<li><strong>Update API keys</strong> if required by the map provider</li>
<li><strong>Review breaking changes</strong> in the map provider’s changelog</li>
</ol>
<h3 id="mapconductor-version-updates"><a class="header" href="#mapconductor-version-updates">MapConductor Version Updates</a></h3>
<p>When updating MapConductor versions:</p>
<ol>
<li><strong>Review the changelog</strong> for breaking changes</li>
<li><strong>Update all MapConductor modules</strong> to the same version</li>
<li><strong>Test provider-specific functionality</strong> thoroughly</li>
<li><strong>Update dependencies</strong> in your app’s build.gradle</li>
</ol>
<h2 id="support-and-compatibility-1"><a class="header" href="#support-and-compatibility-1">Support and Compatibility</a></h2>
<h3 id="supported-configurations"><a class="header" href="#supported-configurations">Supported Configurations</a></h3>
<ul>
<li><strong>Android API</strong>: 26-35 (Android 8.0 to Android 15)</li>
<li><strong>Kotlin</strong>: 2.0.21+</li>
<li><strong>Jetpack Compose</strong>: BOM 2025.05.00+</li>
<li><strong>Java</strong>: JDK 17+</li>
</ul>
<h3 id="reporting-issues"><a class="header" href="#reporting-issues">Reporting Issues</a></h3>
<p>If you encounter compatibility issues:</p>
<ol>
<li>Check this compatibility matrix</li>
<li>Verify your SDK versions match the supported versions</li>
<li>Check the map provider’s documentation for known issues</li>
<li>Report issues with detailed version information</li>
</ol>
<hr />
<p><em>Last updated: September 24, 2024</em>
<em>MapConductor SDK Version: 1.0.0</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="provider-compatibility"><a class="header" href="#provider-compatibility">Provider Compatibility</a></h1>
<p>This page shows which MapConductor components are supported by each map provider. While MapConductor aims to provide a unified API, some features are not available on all map providers due to underlying SDK limitations.</p>
<h2 id="component-support-matrix"><a class="header" href="#component-support-matrix">Component Support Matrix</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Google Maps</th><th>Mapbox</th><th>HERE Maps</th><th>ArcGIS</th></tr></thead><tbody>
<tr><td><strong>MapViewComponent</strong></td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr>
<tr><td><strong>Marker</strong></td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr>
<tr><td><strong>Circle</strong></td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr>
<tr><td><strong>Polyline</strong></td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr>
<tr><td><strong>Polygon</strong></td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr>
<tr><td><strong>GroundImage</strong></td><td>✅</td><td>❌</td><td>❌</td><td>❌</td></tr>
</tbody></table>
</div>
<h3 id="legend"><a class="header" href="#legend">Legend</a></h3>
<ul>
<li>✅ <strong>Fully Supported</strong>: Feature is available and tested</li>
<li>❌ <strong>Not Supported</strong>: Feature is not available due to SDK limitations</li>
<li>⚠️ <strong>Limited Support</strong>: Feature is available with restrictions (none currently)</li>
</ul>
<h2 id="detailed-compatibility-information"><a class="header" href="#detailed-compatibility-information">Detailed Compatibility Information</a></h2>
<h3 id="core-components-all-providers"><a class="header" href="#core-components-all-providers">Core Components (All Providers)</a></h3>
<h4 id="mapviewcomponent"><a class="header" href="#mapviewcomponent">MapViewComponent</a></h4>
<p>All map providers support the basic map view functionality including:</p>
<ul>
<li>Camera positioning and movement</li>
<li>User interaction (pan, zoom, rotate, tilt)</li>
<li>Map styling and appearance</li>
<li>Event handling (tap, long press, camera change)</li>
</ul>
<h4 id="marker"><a class="header" href="#marker">Marker</a></h4>
<p>All providers support marker functionality with:</p>
<ul>
<li>Custom icons and colors</li>
<li>Click events and interactions</li>
<li>Drag and drop</li>
<li>Info windows (where supported by provider)</li>
<li>Clustering (through strategies)</li>
</ul>
<h4 id="circle"><a class="header" href="#circle">Circle</a></h4>
<p>All providers support circular overlays with:</p>
<ul>
<li>Center point and radius</li>
<li>Fill and stroke styling</li>
<li>Interactive events</li>
<li>Dynamic updates</li>
</ul>
<h4 id="polyline"><a class="header" href="#polyline">Polyline</a></h4>
<p>All providers support polyline rendering with:</p>
<ul>
<li>Multiple point paths</li>
<li>Stroke styling and width</li>
<li>Pattern support (where available)</li>
<li>Interactive events</li>
</ul>
<h4 id="polygon"><a class="header" href="#polygon">Polygon</a></h4>
<p>All providers support polygon rendering with:</p>
<ul>
<li>Closed shape definitions</li>
<li>Fill and stroke styling</li>
<li>Hole support (where available)</li>
<li>Interactive events</li>
</ul>
<h3 id="provider-specific-limitations"><a class="header" href="#provider-specific-limitations">Provider-Specific Limitations</a></h3>
<h4 id="groundimage-google-maps-only"><a class="header" href="#groundimage-google-maps-only">GroundImage (Google Maps Only)</a></h4>
<p>GroundImage overlays are only supported on Google Maps because:</p>
<p><strong>Google Maps</strong>: Native <code>GroundOverlay</code> API provides direct support for image overlays with geographic bounds.</p>
<p><strong>Mapbox</strong>: No direct equivalent to ground overlays in the Mapbox Maps SDK. While custom layers could potentially implement similar functionality, it would require significant custom implementation.</p>
<p><strong>HERE Maps</strong>: The HERE SDK does not provide built-in ground overlay functionality. Custom implementation would be complex and potentially unstable.</p>
<p><strong>ArcGIS</strong>: While ArcGIS supports raster layers, the mobile SDK doesn’t provide simple ground overlay functionality equivalent to Google Maps.</p>
<h2 id="usage-considerations"><a class="header" href="#usage-considerations">Usage Considerations</a></h2>
<h3 id="provider-selection"><a class="header" href="#provider-selection">Provider Selection</a></h3>
<p>When choosing a map provider, consider these compatibility factors:</p>
<h4 id="choose-google-maps-if"><a class="header" href="#choose-google-maps-if">Choose Google Maps if:</a></h4>
<ul>
<li>You need GroundImage overlays</li>
<li>You want the most complete feature set</li>
<li>You’re targeting primarily Android users</li>
</ul>
<h4 id="choose-mapbox-if"><a class="header" href="#choose-mapbox-if">Choose Mapbox if:</a></h4>
<ul>
<li>You need extensive map styling customization</li>
<li>You want vector-based rendering</li>
<li>You need offline map support</li>
</ul>
<h4 id="choose-here-maps-if"><a class="header" href="#choose-here-maps-if">Choose HERE Maps if:</a></h4>
<ul>
<li>You need advanced routing and navigation</li>
<li>You want enterprise-grade mapping</li>
<li>You need global coverage with local expertise</li>
</ul>
<h4 id="choose-arcgis-if"><a class="header" href="#choose-arcgis-if">Choose ArcGIS if:</a></h4>
<ul>
<li>You need GIS and enterprise features</li>
<li>You want 3D mapping capabilities</li>
<li>You need extensive spatial analysis</li>
</ul>
<h3 id="handling-unsupported-features"><a class="header" href="#handling-unsupported-features">Handling Unsupported Features</a></h3>
<p>When using components that aren’t supported on all providers:</p>
<h4 id="runtime-detection"><a class="header" href="#runtime-detection">Runtime Detection</a></h4>
<pre><code class="language-kotlin">@Composable
fun CompatibilityAwareMap() {
    val mapViewState = rememberGoogleMapViewState()
    val supportsGroundImage = mapViewState is GoogleMapViewStateImpl

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    MapView(state = mapViewState) {
        // Always supported components
        Marker(
            position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
            icon = DefaultIcon()
        )

        Circle(
            center = GeoPointImpl.fromLatLong(37.7749, -122.4194),
            radius = 1000.0,
            fillColor = Color.Blue.copy(alpha = 0.3f)
        )

        // Conditionally supported components
        if (supportsGroundImage) {
            val imageBounds = GeoRectBounds(
                southWest = GeoPointImpl.fromLatLong(37.7649, -122.4294),
                northEast = GeoPointImpl.fromLatLong(37.7849, -122.4094)
            )

            val context = LocalContext.current
            AppCompatResources.getDrawable(context, R.drawable.overlay_image)?.let { drawable -&gt;
                GroundImage(
                    bounds = imageBounds,
                    image = drawable,
                    opacity = 0.7f
                )
            }
        }
    }
}
</code></pre>
<h4 id="graceful-degradation"><a class="header" href="#graceful-degradation">Graceful Degradation</a></h4>
<pre><code class="language-kotlin">@Composable
fun GracefulDegradationExample() {
    val mapViewState = remember { /* your map state */ }
    val isGoogleMaps = mapViewState is GoogleMapViewStateImpl

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    MapView(state = mapViewState) {
        if (isGoogleMaps) {
            // Use GroundImage on Google Maps
            GroundImageOverlay()
        } else {
            // Fallback: Use polygon with pattern fill
            PolygonFallback()
        }
    }
}

@Composable
fun GroundImageOverlay() {
    val imageBounds = GeoRectBounds(
        southWest = GeoPointImpl.fromLatLong(37.7649, -122.4294),
        northEast = GeoPointImpl.fromLatLong(37.7849, -122.4094)
    )

    val context = LocalContext.current
    AppCompatResources.getDrawable(context, R.drawable.overlay_image)?.let { drawable -&gt;
        GroundImage(
            bounds = imageBounds,
            image = drawable,
            opacity = 0.7f
        )
    }
}

@Composable
fun PolygonFallback() {
    // Approximate ground image with styled polygon
    val bounds = GeoRectBounds(
        southWest = GeoPointImpl.fromLatLong(37.7649, -122.4294),
        northEast = GeoPointImpl.fromLatLong(37.7849, -122.4094)
    )

    val sw = bounds.southWest!!
    val ne = bounds.northEast!!

    Polygon(
        points = listOf(
            sw,
            GeoPointImpl.fromLatLong(sw.latitude, ne.longitude),
            ne,
            GeoPointImpl.fromLatLong(ne.latitude, sw.longitude),
            sw
        ),
        fillColor = Color.Blue.copy(alpha = 0.3f),
        strokeColor = Color.Blue,
        strokeWidth = 2.dp
    )
}
</code></pre>
<h4 id="provider-agnostic-abstractions"><a class="header" href="#provider-agnostic-abstractions">Provider-Agnostic Abstractions</a></h4>
<pre><code class="language-kotlin">interface ImageOverlayStrategy {
    fun canDisplayImageOverlay(): Boolean

    @Composable
    fun ImageOverlay(
        bounds: GeoRectBounds,
        image: Drawable,
        opacity: Float
    )
}

class GoogleMapsImageStrategy : ImageOverlayStrategy {
    override fun canDisplayImageOverlay() = true

    @Composable
    override fun ImageOverlay(bounds: GeoRectBounds, image: Drawable, opacity: Float) {
        GroundImage(
            bounds = bounds,
            image = image,
            opacity = opacity
        )
    }
}

class FallbackImageStrategy : ImageOverlayStrategy {
    override fun canDisplayImageOverlay() = false

    @Composable
    override fun ImageOverlay(bounds: GeoRectBounds, image: Drawable, opacity: Float) {
        // Fallback implementation or empty
        Text("Image overlays not supported on this provider")
    }
}

@Composable
fun AdaptiveImageOverlay() {
    val strategy = when (mapViewState) {
        is GoogleMapViewStateImpl -&gt; GoogleMapsImageStrategy()
        else -&gt; FallbackImageStrategy()
    }

    if (strategy.canDisplayImageOverlay()) {
        strategy.ImageOverlay(
            bounds = imageBounds,
            image = overlayImage,
            opacity = 0.7f
        )
    }
}
</code></pre>
<h2 id="future-compatibility"><a class="header" href="#future-compatibility">Future Compatibility</a></h2>
<h3 id="planned-features"><a class="header" href="#planned-features">Planned Features</a></h3>
<p>Future MapConductor releases may include:</p>
<ul>
<li>Additional overlay types (heatmaps, tile overlays)</li>
<li>Advanced clustering algorithms</li>
<li>Offline map support</li>
</ul>
<h3 id="provider-updates"><a class="header" href="#provider-updates">Provider Updates</a></h3>
<p>As map provider SDKs evolve, compatibility may change:</p>
<ul>
<li>New features may become available</li>
<li>Existing features may be deprecated</li>
<li>Performance characteristics may improve</li>
</ul>
<h3 id="migration-strategies"><a class="header" href="#migration-strategies">Migration Strategies</a></h3>
<p>When provider compatibility changes:</p>
<ol>
<li><strong>Version Pinning</strong>: Pin MapConductor versions for stable feature sets</li>
<li><strong>Feature Detection</strong>: Use runtime detection for new capabilities</li>
<li><strong>Gradual Migration</strong>: Update applications incrementally</li>
<li><strong>Fallback Support</strong>: Maintain fallback implementations</li>
</ol>
<h2 id="testing-across-providers"><a class="header" href="#testing-across-providers">Testing Across Providers</a></h2>
<h3 id="compatibility-testing-1"><a class="header" href="#compatibility-testing-1">Compatibility Testing</a></h3>
<pre><code class="language-kotlin">@RunWith(Parameterized::class)
class ProviderCompatibilityTest(
    private val providerName: String,
    private val stateFactory: () -&gt; MapViewState
) {
    companion object {
        @JvmStatic
        @Parameterized.Parameters(name = "{0}")
        fun providers() = listOf(
            arrayOf("Google Maps", { GoogleMapViewStateImpl() }),
            arrayOf("Mapbox", { MapboxViewStateImpl() }),
            arrayOf("HERE Maps", { HereViewStateImpl() }),
            arrayOf("ArcGIS", { ArcGISMapViewStateImpl() })
        )
    }

    @Test
    fun testBasicComponents() {
        val state = stateFactory()

        // Test components that should work on all providers
        assertTrue("Markers should be supported", supportsMarkers(state))
        assertTrue("Circles should be supported", supportsCircles(state))
        assertTrue("Polylines should be supported", supportsPolylines(state))
        assertTrue("Polygons should be supported", supportsPolygons(state))
    }

    @Test
    fun testProviderSpecificFeatures() {
        val state = stateFactory()

        when (state) {
            is GoogleMapViewStateImpl -&gt; {
                assertTrue("GroundImage should be supported on Google Maps",
                    supportsGroundImage(state))
            }
            else -&gt; {
                assertFalse("GroundImage should not be supported on $providerName",
                    supportsGroundImage(state))
            }
        }
    }
}
</code></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<ol>
<li><strong>Feature Detection</strong>: Always check provider capabilities before using provider-specific features</li>
<li><strong>Graceful Degradation</strong>: Provide fallbacks for unsupported features</li>
<li><strong>Documentation</strong>: Document which providers your app supports</li>
<li><strong>Testing</strong>: Test your app with all target providers</li>
<li><strong>User Communication</strong>: Inform users about provider-specific limitations</li>
</ol>
<p>Understanding provider compatibility helps you make informed decisions about map provider selection and ensures your application works consistently across different mapping platforms.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="google-maps-setup"><a class="header" href="#google-maps-setup">Google Maps Setup</a></h1>
<p>This section covers the setup process for Google Maps SDK integration with MapConductor.</p>
<blockquote>
<p><strong>Important</strong>: MapConductor provides a unified API layer on top of existing map SDKs. You must set up the Google Maps SDK independently before using MapConductor’s Google Maps integration.</p>
</blockquote>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<ul>
<li>Android development environment</li>
<li>Google Cloud Console account</li>
<li>Maps SDK for Android enabled in your Google Cloud project</li>
</ul>
<h2 id="setup-steps"><a class="header" href="#setup-steps">Setup Steps</a></h2>
<h3 id="1-google-cloud-console-configuration"><a class="header" href="#1-google-cloud-console-configuration">1. Google Cloud Console Configuration</a></h3>
<ol>
<li>Go to the <a href="https://console.cloud.google.com/">Google Cloud Console</a></li>
<li>Create a new project or select an existing one</li>
<li>Enable the <strong>Maps SDK for Android</strong> API</li>
<li>Go to <strong>Credentials</strong> and create an API key</li>
<li>Restrict the API key to your app’s package name and SHA-1 certificate fingerprint</li>
</ol>
<h3 id="2-gradle-configuration"><a class="header" href="#2-gradle-configuration">2. Gradle Configuration</a></h3>
<p>First, add the Secrets Gradle Plugin to your project’s root <code>build.gradle.kts</code>:</p>
<pre><code class="language-kotlin">// Root build.gradle.kts
plugins {
    id("com.google.android.libraries.mapsplatform.secrets-gradle-plugin") version "2.0.1" apply false
}
</code></pre>
<p>Then, add the dependencies and apply the plugin in your app’s <code>build.gradle.kts</code>:</p>
<pre><code class="language-kotlin">// App build.gradle.kts
plugins {
    // ... other plugins
    id("com.google.android.libraries.mapsplatform.secrets-gradle-plugin")
}

dependencies {
    // Google Maps SDK - Version 19.2.0 (as used by MapConductor 1.0.0)
    implementation("com.google.android.gms:play-services-maps:19.2.0")

    // MapConductor BOM for version management
    implementation(platform("com.mapconductor:mapconductor-bom:1.0.0"))

    // MapConductor modules (versions managed by BOM)
    implementation("com.mapconductor:core")
    implementation("com.mapconductor:for-googlemaps")
}
</code></pre>
<p>The Secrets Gradle Plugin automatically reads your <code>secrets.properties</code> file and injects the values into your AndroidManifest.xml at build time.</p>
<h3 id="3-android-manifest-configuration"><a class="header" href="#3-android-manifest-configuration">3. Android Manifest Configuration</a></h3>
<p>Add the Google Maps API key placeholder to your <code>AndroidManifest.xml</code>:</p>
<pre><code class="language-xml">&lt;application&gt;
    &lt;!-- Google Maps API Key --&gt;
    &lt;meta-data
        android:name="com.google.android.geo.API_KEY"
        android:value="${GOOGLE_MAPS_API_KEY}" /&gt;

    &lt;!-- Add location permissions --&gt;
    &lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" /&gt;
    &lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&gt;
&lt;/application&gt;
</code></pre>
<h3 id="4-api-key-configuration"><a class="header" href="#4-api-key-configuration">4. API Key Configuration</a></h3>
<p>Add your actual API key to your <code>secrets.properties</code> file (create if it doesn’t exist):</p>
<pre><code class="language-properties"># secrets.properties
GOOGLE_MAPS_API_KEY=your_actual_google_maps_api_key_here
</code></pre>
<p><strong>Important</strong>:</p>
<ul>
<li>Never commit your <code>secrets.properties</code> file to version control. Add it to <code>.gitignore</code>.</li>
<li>The Secrets Gradle Plugin automatically replaces <code>${GOOGLE_MAPS_API_KEY}</code> in your AndroidManifest.xml with the actual value from this file.</li>
<li>For CI/CD builds, you can set environment variables or use other secure methods to provide these values.</li>
</ul>
<h3 id="5-proguard-configuration-if-applicable"><a class="header" href="#5-proguard-configuration-if-applicable">5. ProGuard Configuration (if applicable)</a></h3>
<p>If you’re using ProGuard/R8, add these rules to your <code>proguard-rules.pro</code>:</p>
<pre><code class="language-proguard"># Google Play Services
-keep class com.google.android.gms.maps.** { *; }
-keep interface com.google.android.gms.maps.** { *; }
-dontwarn com.google.android.gms.**
</code></pre>
<h2 id="verification"><a class="header" href="#verification">Verification</a></h2>
<p>To verify your Google Maps setup:</p>
<ol>
<li>Build and run your app</li>
<li>Check that the map displays without errors</li>
<li>Verify location permissions are working</li>
<li>Test basic map interactions (zoom, pan)</li>
</ol>
<pre><code class="language-kotlin">@Composable
fun TestGoogleMaps() {
    val mapState = rememberGoogleMapViewState()

    GoogleMapsView(state = mapState) {
        // If this displays correctly, your setup is working
    }
}
</code></pre>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="common-issues"><a class="header" href="#common-issues">Common Issues</a></h3>
<p><strong>Map not displaying (gray screen)</strong></p>
<ul>
<li>Verify API key is correct in <code>secrets.properties</code></li>
<li>Check that Maps SDK for Android is enabled in Google Cloud Console</li>
<li>Ensure API key restrictions match your app’s package name and SHA-1</li>
</ul>
<p><strong>API key errors in logs</strong></p>
<ul>
<li>Double-check the API key value</li>
<li>Verify the key has not expired</li>
<li>Check API key restrictions in Google Cloud Console</li>
</ul>
<p><strong>Build errors</strong></p>
<ul>
<li>Ensure Google Play Services Maps version matches: <code>19.2.0</code></li>
<li>Verify <code>secrets.properties</code> file exists and is properly formatted</li>
<li>Check that <code>secrets.properties</code> is not in <code>.gitignore</code> for local builds</li>
</ul>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<p>Once Google Maps SDK is properly configured, you can use MapConductor’s <code>GoogleMapsView</code> component as described in the <a href="setup/../components/mapviewcomponent.html">MapViewComponent</a> documentation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mapbox-setup"><a class="header" href="#mapbox-setup">Mapbox Setup</a></h1>
<p>This section covers the setup process for Mapbox Maps SDK integration with MapConductor.</p>
<blockquote>
<p><strong>Important</strong>: MapConductor provides a unified API layer on top of existing map SDKs. You must set up the Mapbox Maps SDK independently before using MapConductor’s Mapbox integration.</p>
</blockquote>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<ul>
<li>Android development environment</li>
<li>Mapbox account</li>
<li>Mapbox access token</li>
</ul>
<h2 id="setup-steps-1"><a class="header" href="#setup-steps-1">Setup Steps</a></h2>
<h3 id="1-mapbox-account-configuration"><a class="header" href="#1-mapbox-account-configuration">1. Mapbox Account Configuration</a></h3>
<ol>
<li>Sign up for a <a href="https://www.mapbox.com/">Mapbox account</a></li>
<li>Go to your <a href="https://account.mapbox.com/">Mapbox Account Dashboard</a></li>
<li>Navigate to <strong>Access tokens</strong></li>
<li>Create a new access token or use the default public token</li>
<li>Copy the access token for use in your app</li>
</ol>
<h3 id="2-gradle-configuration-1"><a class="header" href="#2-gradle-configuration-1">2. Gradle Configuration</a></h3>
<p>First, add the Mapbox repository to your project’s <code>settings.gradle.kts</code>:</p>
<pre><code class="language-kotlin">// settings.gradle.kts
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()

        // Mapbox Maven repository
        maven {
            url = uri("https://api.mapbox.com/downloads/v2/releases/maven")
        }
    }
}
</code></pre>
<p>Then, add the Secrets Gradle Plugin to your project’s root <code>build.gradle.kts</code>:</p>
<pre><code class="language-kotlin">// Root build.gradle.kts
plugins {
    id("com.google.android.libraries.mapsplatform.secrets-gradle-plugin") version "2.0.1" apply false
}
</code></pre>
<p>Then, add the dependencies and apply the plugin in your app’s <code>build.gradle.kts</code>:</p>
<pre><code class="language-kotlin">// App build.gradle.kts
plugins {
    // ... other plugins
    id("com.google.android.libraries.mapsplatform.secrets-gradle-plugin")
}

dependencies {
    // Mapbox Maps SDK - Version 11.14.3 (NDK27 variant, as used by MapConductor 1.0.0)
    implementation("com.mapbox.maps:android-ndk27:11.14.3")

    // MapConductor BOM for version management
    implementation(platform("com.mapconductor:mapconductor-bom:1.0.0"))

    // MapConductor modules (versions managed by BOM)
    implementation("com.mapconductor:core")
    implementation("com.mapconductor:for-mapbox")
}
</code></pre>
<p>The Secrets Gradle Plugin automatically reads your <code>secrets.properties</code> file and injects the values into your AndroidManifest.xml at build time.</p>
<h3 id="3-android-manifest-configuration-1"><a class="header" href="#3-android-manifest-configuration-1">3. Android Manifest Configuration</a></h3>
<p>Add the Mapbox access token placeholder to your <code>AndroidManifest.xml</code>:</p>
<pre><code class="language-xml">&lt;application&gt;
    &lt;!-- Mapbox Access Token --&gt;
    &lt;meta-data
        android:name="MAPBOX_ACCESS_TOKEN"
        android:value="${MAPBOX_ACCESS_TOKEN}" /&gt;

    &lt;!-- Add internet and location permissions --&gt;
    &lt;uses-permission android:name="android.permission.INTERNET" /&gt;
    &lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" /&gt;
    &lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&gt;
&lt;/application&gt;
</code></pre>
<h3 id="4-access-token-configuration"><a class="header" href="#4-access-token-configuration">4. Access Token Configuration</a></h3>
<p>Add your actual access token to your <code>secrets.properties</code> file:</p>
<pre><code class="language-properties"># secrets.properties
MAPBOX_ACCESS_TOKEN=your_actual_mapbox_access_token_here
</code></pre>
<p><strong>Important</strong>:</p>
<ul>
<li>Never commit your <code>secrets.properties</code> file to version control. Add it to <code>.gitignore</code>.</li>
<li>The Secrets Gradle Plugin automatically replaces <code>${MAPBOX_ACCESS_TOKEN}</code> in your AndroidManifest.xml with the actual value from this file.</li>
<li>For CI/CD builds, you can set environment variables or use other secure methods to provide these values.</li>
</ul>
<h3 id="5-style-configuration"><a class="header" href="#5-style-configuration">5. Style Configuration</a></h3>
<p>Mapbox allows custom map styles. You can use built-in styles or create custom ones:</p>
<pre><code class="language-kotlin">// Using built-in styles
val mapStyle = Style.MAPBOX_STREETS
// or Style.SATELLITE, Style.OUTDOORS, etc.

// Using custom style URL
val customStyle = "mapbox://styles/your-username/your-style-id"
</code></pre>
<h2 id="verification-1"><a class="header" href="#verification-1">Verification</a></h2>
<p>To verify your Mapbox setup:</p>
<ol>
<li>Build and run your app</li>
<li>Check that the map displays with Mapbox styling</li>
<li>Test map interactions (zoom, pan, rotate)</li>
<li>Verify custom styles load correctly (if using)</li>
</ol>
<pre><code class="language-kotlin">@Composable
fun TestMapbox() {
    val mapState = rememberMapboxMapViewState()

    MapboxMapView(state = mapState) {
        // If this displays correctly, your setup is working
    }
}
</code></pre>
<h2 id="troubleshooting-1"><a class="header" href="#troubleshooting-1">Troubleshooting</a></h2>
<h3 id="common-issues-1"><a class="header" href="#common-issues-1">Common Issues</a></h3>
<p><strong>Map not displaying (blank screen)</strong></p>
<ul>
<li>Verify access token is correct in <code>secrets.properties</code></li>
<li>Check that the token has not expired</li>
<li>Ensure internet connectivity for tile loading</li>
</ul>
<p><strong>Access token errors</strong></p>
<ul>
<li>Double-check the token value (should start with <code>pk.</code>)</li>
<li>Verify token permissions in Mapbox account dashboard</li>
<li>Check token scopes include required permissions</li>
</ul>
<p><strong>Build errors</strong></p>
<ul>
<li>Ensure Mapbox SDK version matches: <code>com.mapbox.maps:android-ndk27:11.14.3</code></li>
<li>Verify NDK27 variant is used (not the standard variant)</li>
<li>Check that <code>secrets.properties</code> file exists and contains the token</li>
</ul>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<p>Once Mapbox Maps SDK is properly configured, you can use MapConductor’s <code>MapboxMapView</code> component as described in the <a href="setup/../components/mapviewcomponent.html">MapViewComponent</a> documentation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="here-maps-setup"><a class="header" href="#here-maps-setup">HERE Maps Setup</a></h1>
<p>This section covers the setup process for HERE SDK integration with MapConductor.</p>
<blockquote>
<p><strong>Important</strong>: MapConductor provides a unified API layer on top of existing map SDKs. You must set up the HERE SDK independently before using MapConductor’s HERE Maps integration.</p>
</blockquote>
<h2 id="prerequisites-2"><a class="header" href="#prerequisites-2">Prerequisites</a></h2>
<ul>
<li>Android development environment</li>
<li>HERE developer account</li>
<li>HERE API key</li>
</ul>
<h2 id="setup-steps-2"><a class="header" href="#setup-steps-2">Setup Steps</a></h2>
<h3 id="1-here-developer-portal-configuration"><a class="header" href="#1-here-developer-portal-configuration">1. HERE Developer Portal Configuration</a></h3>
<ol>
<li>Sign up for a <a href="https://developer.here.com/">HERE Developer account</a></li>
<li>Go to the <a href="https://developer.here.com/projects">HERE Developer Portal</a></li>
<li>Create a new project</li>
<li>Generate API credentials (Access Key ID and Secret)</li>
<li>Download the HERE SDK AAR file</li>
</ol>
<h3 id="2-here-sdk-installation"><a class="header" href="#2-here-sdk-installation">2. HERE SDK Installation</a></h3>
<ol>
<li>Download HERE SDK Explore Android version <strong>4.23.2.0.210004</strong> (as used by MapConductor 1.0.0)</li>
<li>Place the AAR file in your project’s <code>libs/</code> directory:
<pre><code>libs/heresdk-explore-android-4.23.2.0.210004.aar
</code></pre>
</li>
<li>The AAR file must match the exact version specified in <code>gradle.properties</code></li>
</ol>
<h3 id="3-gradle-configuration"><a class="header" href="#3-gradle-configuration">3. Gradle Configuration</a></h3>
<p>First, add the Secrets Gradle Plugin to your project’s root <code>build.gradle.kts</code>:</p>
<pre><code class="language-kotlin">// Root build.gradle.kts
plugins {
    id("com.google.android.libraries.mapsplatform.secrets-gradle-plugin") version "2.0.1" apply false
}
</code></pre>
<p>Then, add the dependencies and apply the plugin in your app’s <code>build.gradle.kts</code>:</p>
<pre><code class="language-kotlin">// App build.gradle.kts
plugins {
    // ... other plugins
    id("com.google.android.libraries.mapsplatform.secrets-gradle-plugin")
}

dependencies {
    // HERE SDK - Version 4.23.2.0.210004 (as used by MapConductor 1.0.0)
    implementation(files("${rootProject.projectDir}/libs/heresdk-explore-android-4.23.2.0.210004.aar"))

    // MapConductor BOM for version management
    implementation(platform("com.mapconductor:mapconductor-bom:1.0.0"))

    // MapConductor modules (versions managed by BOM)
    implementation("com.mapconductor:core")
    implementation("com.mapconductor:for-here")
}
</code></pre>
<p>The Secrets Gradle Plugin automatically reads your <code>secrets.properties</code> file and injects the values into your AndroidManifest.xml at build time.</p>
<h3 id="4-android-manifest-configuration"><a class="header" href="#4-android-manifest-configuration">4. Android Manifest Configuration</a></h3>
<p>Add the HERE API key placeholders to your <code>AndroidManifest.xml</code>:</p>
<pre><code class="language-xml">&lt;application&gt;
    &lt;!-- HERE API Credentials --&gt;
    &lt;meta-data
        android:name="HERE_ACCESS_KEY_ID"
        android:value="${HERE_ACCESS_KEY_ID}" /&gt;
    &lt;meta-data
        android:name="HERE_ACCESS_KEY_SECRET"
        android:value="${HERE_ACCESS_KEY_SECRET}" /&gt;

    &lt;!-- Add internet and location permissions --&gt;
    &lt;uses-permission android:name="android.permission.INTERNET" /&gt;
    &lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" /&gt;
    &lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&gt;
&lt;/application&gt;
</code></pre>
<h3 id="5-api-key-configuration"><a class="header" href="#5-api-key-configuration">5. API Key Configuration</a></h3>
<p>Add your actual API credentials to your <code>secrets.properties</code> file:</p>
<pre><code class="language-properties"># secrets.properties
HERE_ACCESS_KEY_ID=your_actual_here_access_key_id
HERE_ACCESS_KEY_SECRET=your_actual_here_access_key_secret
</code></pre>
<p><strong>Important</strong>:</p>
<ul>
<li>Never commit your <code>secrets.properties</code> file to version control. Add it to <code>.gitignore</code>.</li>
<li>The Secrets Gradle Plugin automatically replaces <code>${HERE_ACCESS_KEY_ID}</code> and <code>${HERE_ACCESS_KEY_SECRET}</code> in your AndroidManifest.xml with the actual values from this file.</li>
<li>The HERE SDK AAR file is not publicly available and must be obtained from HERE Developer Portal.</li>
<li>For CI/CD builds, you can set environment variables or use other secure methods to provide these values.</li>
</ul>
<h2 id="verification-2"><a class="header" href="#verification-2">Verification</a></h2>
<p>To verify your HERE Maps setup:</p>
<ol>
<li>Build and run your app</li>
<li>Check that the HERE map displays correctly</li>
<li>Test map interactions and HERE-specific features</li>
<li>Verify offline capabilities (if using)</li>
</ol>
<pre><code class="language-kotlin">@Composable
fun TestHERE() {
    val mapState = rememberHereMapViewState()

    HereMapView(state = mapState) {
        // If this displays correctly, your setup is working
    }
}
</code></pre>
<h2 id="troubleshooting-2"><a class="header" href="#troubleshooting-2">Troubleshooting</a></h2>
<h3 id="common-issues-2"><a class="header" href="#common-issues-2">Common Issues</a></h3>
<p><strong>Map not loading</strong></p>
<ul>
<li>Verify HERE credentials are correct in <code>secrets.properties</code></li>
<li>Check that Access Key ID and Secret are properly configured</li>
<li>Ensure HERE Developer account is active</li>
</ul>
<p><strong>AAR file not found</strong></p>
<ul>
<li>Verify AAR file is in <code>libs/</code> directory</li>
<li>Check filename matches exactly: <code>heresdk-explore-android-4.23.2.0.210004.aar</code></li>
<li>Ensure AAR file was downloaded from HERE Developer Portal</li>
</ul>
<p><strong>Build errors</strong></p>
<ul>
<li>Verify AAR file version matches gradle configuration</li>
<li>Check that HERE credentials are set in <code>secrets.properties</code></li>
<li>Ensure <code>gradle.properties</code> contains correct <code>hereSdkAarName</code> value</li>
</ul>
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next Steps</a></h2>
<p>Once HERE SDK is properly configured, you can use MapConductor’s <code>HereMapView</code> component as described in the <a href="setup/../components/mapviewcomponent.html">MapViewComponent</a> documentation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arcgis-maps-setup"><a class="header" href="#arcgis-maps-setup">ArcGIS Maps Setup</a></h1>
<p>This section covers the setup process for ArcGIS Maps SDK integration with MapConductor.</p>
<blockquote>
<p><strong>Important</strong>: MapConductor provides a unified API layer on top of existing map SDKs. You must set up the ArcGIS Maps SDK independently before using MapConductor’s ArcGIS integration.</p>
</blockquote>
<h2 id="prerequisites-3"><a class="header" href="#prerequisites-3">Prerequisites</a></h2>
<ul>
<li>Android development environment</li>
<li>ArcGIS developer account</li>
<li>ArcGIS API key</li>
</ul>
<h2 id="setup-steps-3"><a class="header" href="#setup-steps-3">Setup Steps</a></h2>
<h3 id="1-arcgis-developer-dashboard-configuration"><a class="header" href="#1-arcgis-developer-dashboard-configuration">1. ArcGIS Developer Dashboard Configuration</a></h3>
<ol>
<li>Sign up for an <a href="https://developers.arcgis.com/">ArcGIS Developer account</a></li>
<li>Go to the <a href="https://developers.arcgis.com/dashboard">ArcGIS Developer Dashboard</a></li>
<li>Create a new application or select an existing one</li>
<li>Generate an API key with appropriate scopes</li>
<li>Note the API key for use in your app</li>
</ol>
<h3 id="2-gradle-configuration-2"><a class="header" href="#2-gradle-configuration-2">2. Gradle Configuration</a></h3>
<p>First, add the Esri repository to your project’s <code>settings.gradle.kts</code>:</p>
<pre><code class="language-kotlin">// settings.gradle.kts
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()

        // Esri public repository for ArcGIS Maps SDK
        maven {
            url = uri("https://esri.jfrog.io/artifactory/arcgis")
        }
    }
}
</code></pre>
<p>Then, add the Secrets Gradle Plugin to your project’s root <code>build.gradle.kts</code>:</p>
<pre><code class="language-kotlin">// Root build.gradle.kts
plugins {
    id("com.google.android.libraries.mapsplatform.secrets-gradle-plugin") version "2.0.1" apply false
}
</code></pre>
<p>Then, add the dependencies and apply the plugin in your app’s <code>build.gradle.kts</code>:</p>
<pre><code class="language-kotlin">// App build.gradle.kts
plugins {
    // ... other plugins
    id("com.google.android.libraries.mapsplatform.secrets-gradle-plugin")
}

dependencies {
    // ArcGIS Maps SDK - Version 200.7.0 (as used by MapConductor 1.0.0)
    implementation(platform("com.esri:arcgis-maps-kotlin-toolkit-bom:200.7.0"))
    implementation("com.esri:arcgis-maps-kotlin:200.7.0")
    implementation("com.esri:arcgis-maps-kotlin-toolkit-geoview-compose")
    implementation("com.esri:arcgis-maps-kotlin-toolkit-authentication")

    // MapConductor BOM for version management
    implementation(platform("com.mapconductor:mapconductor-bom:1.0.0"))

    // MapConductor modules (versions managed by BOM)
    implementation("com.mapconductor:core")
    implementation("com.mapconductor:for-arcgis")
}
</code></pre>
<p>The Secrets Gradle Plugin automatically reads your <code>secrets.properties</code> file and injects the values into your AndroidManifest.xml at build time.</p>
<h3 id="3-android-manifest-configuration-2"><a class="header" href="#3-android-manifest-configuration-2">3. Android Manifest Configuration</a></h3>
<p>Add the ArcGIS API key placeholder to your <code>AndroidManifest.xml</code>:</p>
<pre><code class="language-xml">&lt;application&gt;
    &lt;!-- ArcGIS API Key --&gt;
    &lt;meta-data
        android:name="ARCGIS_API_KEY"
        android:value="${ARCGIS_API_KEY}" /&gt;

    &lt;!-- Add internet and location permissions --&gt;
    &lt;uses-permission android:name="android.permission.INTERNET" /&gt;
    &lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" /&gt;
    &lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&gt;
&lt;/application&gt;
</code></pre>
<h3 id="4-api-key-configuration-1"><a class="header" href="#4-api-key-configuration-1">4. API Key Configuration</a></h3>
<p>Add your actual API key to your <code>secrets.properties</code> file:</p>
<pre><code class="language-properties"># secrets.properties
ARCGIS_API_KEY=your_actual_arcgis_api_key_here
</code></pre>
<p><strong>Important</strong>:</p>
<ul>
<li>Never commit your <code>secrets.properties</code> file to version control. Add it to <code>.gitignore</code>.</li>
<li>The Secrets Gradle Plugin automatically replaces <code>${ARCGIS_API_KEY}</code> in your AndroidManifest.xml with the actual value from this file.</li>
<li>For CI/CD builds, you can set environment variables or use other secure methods to provide these values.</li>
</ul>
<h3 id="5-license-configuration"><a class="header" href="#5-license-configuration">5. License Configuration</a></h3>
<p>ArcGIS SDK requires proper license configuration. Set the license in your application:</p>
<pre><code class="language-kotlin">// In your Application class or MainActivity
ArcGISEnvironment.setApiKey("your_api_key_here")

// For development/testing
ArcGISEnvironment.setLicense("your_license_key_here") // Optional for basic use
</code></pre>
<p>For production apps, consider using a <a href="https://developers.arcgis.com/documentation/security-and-authentication/licensing/">Named User License</a> or <a href="https://developers.arcgis.com/documentation/security-and-authentication/licensing/">License Key</a>.</p>
<h2 id="verification-3"><a class="header" href="#verification-3">Verification</a></h2>
<p>To verify your ArcGIS setup:</p>
<ol>
<li>Build and run your app</li>
<li>Check that the ArcGIS map displays correctly</li>
<li>Test GIS-specific features (if using)</li>
<li>Verify authentication is working</li>
</ol>
<pre><code class="language-kotlin">@Composable
fun TestArcGIS() {
    val mapState = rememberArcGISMapViewState()

    ArcGISMapView(state = mapState) {
        // If this displays correctly, your setup is working
    }
}
</code></pre>
<h2 id="troubleshooting-3"><a class="header" href="#troubleshooting-3">Troubleshooting</a></h2>
<h3 id="common-issues-3"><a class="header" href="#common-issues-3">Common Issues</a></h3>
<p><strong>Map not loading</strong></p>
<ul>
<li>Verify API key is correct in <code>secrets.properties</code></li>
<li>Check that API key has proper scopes in ArcGIS Dashboard</li>
<li>Ensure ArcGIS Developer account is in good standing</li>
</ul>
<p><strong>License errors</strong></p>
<ul>
<li>Set API key using <code>ArcGISEnvironment.setApiKey()</code></li>
<li>For production apps, configure proper licensing</li>
<li>Check ArcGIS license terms for your use case</li>
</ul>
<p><strong>Build errors</strong></p>
<ul>
<li>Ensure ArcGIS SDK version matches: <code>200.7.0</code></li>
<li>Verify BOM is used for version management</li>
<li>Check that Compose toolkit dependencies are included</li>
<li>Ensure <code>secrets.properties</code> contains the API key</li>
</ul>
<h2 id="next-steps-4"><a class="header" href="#next-steps-4">Next Steps</a></h2>
<p>Once ArcGIS Maps SDK is properly configured, you can use MapConductor’s <code>ArcGISMapView</code> component as described in the <a href="setup/../components/mapviewcomponent.html">MapViewComponent</a> documentation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mapviewcomponent-1"><a class="header" href="#mapviewcomponent-1">MapViewComponent</a></h1>
<p>MapConductor provides provider-specific map view components that serve as the foundation for displaying maps in your application. Each map provider has its own implementation while maintaining a consistent API interface.</p>
<h2 id="provider-specific-components"><a class="header" href="#provider-specific-components">Provider-Specific Components</a></h2>
<p>MapConductor supports multiple map providers, each with their dedicated component:</p>
<h3 id="googlemapsview"><a class="header" href="#googlemapsview">GoogleMapsView</a></h3>
<p>For Google Maps integration:</p>
<pre><code class="language-kotlin">GoogleMapsView(
    modifier: Modifier = Modifier,
    markerRenderingStrategy: MarkerRenderingStrategy&lt;GoogleMapActualMarker&gt;? = null,
    state: GoogleMapViewStateImpl,
    onMapViewInitialized: OnMapViewInitializedHandler? = null,
    onMapLoaded: OnMapLoadedHandler? = null,
    onMapClick: OnMapEventHandler? = null,
    onMarkerClick: OnMarkerEventHandler? = null,
    onMarkerDragStart: OnMarkerEventHandler? = null,
    onMarkerDrag: OnMarkerEventHandler? = null,
    onMarkerDragEnd: OnMarkerEventHandler? = null,
    onMarkerAnimateStart: OnMarkerEventHandler? = null,
    onMarkerAnimateEnd: OnMarkerEventHandler? = null,
    onCircleClick: OnCircleEventHandler? = null,
    onPolylineClick: OnPolylineEventHandler? = null,
    onPolygonClick: OnPolygonEventHandler? = null,
    onGroundImageClick: OnGroundImageEventHandler? = null,
    shouldInitialize: Boolean = true,
    content: (@Composable MapViewScope.() -&gt; Unit)? = null
)
</code></pre>
<h3 id="mapboxmapview"><a class="header" href="#mapboxmapview">MapboxMapView</a></h3>
<p>For Mapbox integration:</p>
<pre><code class="language-kotlin">MapboxMapView(
    modifier: Modifier = Modifier,
    markerRenderingStrategy: MarkerRenderingStrategy&lt;MapboxActualMarker&gt;? = null,
    state: MapboxViewStateImpl,
    onMapViewInitialized: OnMapViewInitializedHandler? = null,
    onMapLoaded: OnMapLoadedHandler? = null,
    onMapClick: OnMapEventHandler? = null,
    onMarkerClick: OnMarkerEventHandler? = null,
    onMarkerDragStart: OnMarkerEventHandler? = null,
    onMarkerDrag: OnMarkerEventHandler? = null,
    onMarkerDragEnd: OnMarkerEventHandler? = null,
    onMarkerAnimateStart: OnMarkerEventHandler? = null,
    onMarkerAnimateEnd: OnMarkerEventHandler? = null,
    onCircleClick: OnCircleEventHandler? = null,
    onPolylineClick: OnPolylineEventHandler? = null,
    onPolygonClick: OnPolygonEventHandler? = null,
    shouldInitialize: Boolean = true,
    content: (@Composable MapViewScope.() -&gt; Unit)? = null
)
</code></pre>
<h3 id="heremapview"><a class="header" href="#heremapview">HereMapView</a></h3>
<p>For HERE Maps integration:</p>
<pre><code class="language-kotlin">HereMapView(
    modifier: Modifier = Modifier,
    markerRenderingStrategy: MarkerRenderingStrategy&lt;HereActualMarker&gt;? = null,
    state: HereViewStateImpl,
    onMapViewInitialized: OnMapViewInitializedHandler? = null,
    onMapLoaded: OnMapLoadedHandler? = null,
    onMapClick: OnMapEventHandler? = null,
    onMarkerClick: OnMarkerEventHandler? = null,
    onMarkerDragStart: OnMarkerEventHandler? = null,
    onMarkerDrag: OnMarkerEventHandler? = null,
    onMarkerDragEnd: OnMarkerEventHandler? = null,
    onMarkerAnimateStart: OnMarkerEventHandler? = null,
    onMarkerAnimateEnd: OnMarkerEventHandler? = null,
    onCircleClick: OnCircleEventHandler? = null,
    onPolylineClick: OnPolylineEventHandler? = null,
    onPolygonClick: OnPolygonEventHandler? = null,
    content: (@Composable MapViewScope.() -&gt; Unit)? = null
)
</code></pre>
<h3 id="arcgismapview"><a class="header" href="#arcgismapview">ArcGISMapView</a></h3>
<p>For ArcGIS integration:</p>
<pre><code class="language-kotlin">ArcGISMapView(
    modifier: Modifier = Modifier,
    markerRenderingStrategy: MarkerRenderingStrategy&lt;ArcGISActualMarker&gt;? = null,
    state: ArcGISMapViewStateImpl,
    onMapViewInitialized: OnMapViewInitializedHandler? = null,
    onMapLoaded: OnMapLoadedHandler? = null,
    onMapClick: OnMapEventHandler? = null,
    onMarkerClick: OnMarkerEventHandler? = null,
    onMarkerDragStart: OnMarkerEventHandler? = null,
    onMarkerDrag: OnMarkerEventHandler? = null,
    onMarkerDragEnd: OnMarkerEventHandler? = null,
    onMarkerAnimateStart: OnMarkerEventHandler? = null,
    onMarkerAnimateEnd: OnMarkerEventHandler? = null,
    onCircleClick: OnCircleEventHandler? = null,
    onPolylineClick: OnPolylineEventHandler? = null,
    onPolygonClick: OnPolygonEventHandler? = null,
    content: (@Composable MapViewScope.() -&gt; Unit)? = null
)
</code></pre>
<h2 id="common-parameters"><a class="header" href="#common-parameters">Common Parameters</a></h2>
<p>All map view components share the following parameters:</p>
<h3 id="core-parameters"><a class="header" href="#core-parameters">Core Parameters</a></h3>
<ul>
<li><strong><code>modifier</code></strong>: Compose modifier for styling and layout</li>
<li><strong><code>state</code></strong>: Provider-specific map view state implementation</li>
<li><strong><code>shouldInitialize</code></strong>: Whether to initialize the map immediately (default: <code>true</code>)</li>
<li><strong><code>content</code></strong>: Composable content containing map overlays (markers, circles, etc.)</li>
</ul>
<h3 id="event-handlers"><a class="header" href="#event-handlers">Event Handlers</a></h3>
<ul>
<li><strong><code>onMapViewInitialized</code></strong>: Called when the map view is first initialized</li>
<li><strong><code>onMapLoaded</code></strong>: Called when the map has finished loading</li>
<li><strong><code>onMapClick</code></strong>: Called when the user taps on the map</li>
<li><strong>Marker Events</strong>: <code>onMarkerClick</code>, <code>onMarkerDragStart</code>, <code>onMarkerDrag</code>, <code>onMarkerDragEnd</code>, <code>onMarkerAnimateStart</code>, <code>onMarkerAnimateEnd</code></li>
<li><strong>Overlay Events</strong>: <code>onCircleClick</code>, <code>onPolylineClick</code>, <code>onPolygonClick</code>, <code>onGroundImageClick</code></li>
</ul>
<h3 id="advanced-parameters"><a class="header" href="#advanced-parameters">Advanced Parameters</a></h3>
<ul>
<li><strong><code>markerRenderingStrategy</code></strong>: Custom marker rendering strategy for performance optimization</li>
</ul>
<h2 id="usage-examples"><a class="header" href="#usage-examples">Usage Examples</a></h2>
<h3 id="basic-google-maps-implementation"><a class="header" href="#basic-google-maps-implementation">Basic Google Maps Implementation</a></h3>
<pre><code class="language-kotlin">@Composable
fun GoogleMapsExample() {
    val mapViewState = rememberGoogleMapViewState()

    GoogleMapsView(
        state = mapViewState,
        onMapClick = { geoPoint -&gt;
            println("Map clicked at: ${geoPoint.latitude}, ${geoPoint.longitude}")
        },
        onMarkerClick = { markerState -&gt;
            println("Marker clicked: ${markerState.extra}")
        }
    ) {
        Marker(
            position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
            icon = DefaultIcon(label = "SF"),
            extra = "San Francisco"
        )

        Circle(
            center = GeoPointImpl.fromLatLong(37.7749, -122.4194),
            radius = 1000.0,
            strokeColor = Color.Blue,
            fillColor = Color.Blue.copy(alpha = 0.3f)
        )
    }
}
</code></pre>
<h3 id="basic-mapbox-implementation"><a class="header" href="#basic-mapbox-implementation">Basic Mapbox Implementation</a></h3>
<pre><code class="language-kotlin">@Composable
fun MapboxExample() {
    val mapViewState = remember { MapboxViewStateImpl() }

    MapboxMapView(
        state = mapViewState,
        onMapClick = { geoPoint -&gt;
            println("Map clicked at: ${geoPoint.latitude}, ${geoPoint.longitude}")
        }
    ) {
        Marker(
            position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
            icon = DefaultIcon(label = "MB"),
            extra = "Mapbox marker"
        )

        Polyline(
            points = listOf(
                GeoPointImpl.fromLatLong(37.7749, -122.4194),
                GeoPointImpl.fromLatLong(37.7849, -122.4094),
                GeoPointImpl.fromLatLong(37.7949, -122.3994)
            ),
            strokeColor = Color.Red,
            strokeWidth = 3.dp
        )
    }
}
</code></pre>
<h3 id="provider-agnostic-pattern"><a class="header" href="#provider-agnostic-pattern">Provider-Agnostic Pattern</a></h3>
<p>While each provider requires its specific component, you can create provider-agnostic content:</p>
<pre><code class="language-kotlin">@Composable
fun MapContent() {
    Marker(
        position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
        icon = DefaultIcon(label = "Point"),
        extra = "Common marker"
    )

    Circle(
        center = GeoPointImpl.fromLatLong(37.7749, -122.4194),
        radius = 500.0,
        strokeColor = Color.Green,
        fillColor = Color.Green.copy(alpha = 0.2f)
    )
}

@Composable
fun GoogleMapsScreen() {
    val state = rememberGoogleMapViewState()
    GoogleMapsView(state = state) {
        MapContent() // Reusable content
    }
}

@Composable
fun MapboxScreen() {
    val state = remember { MapboxViewStateImpl() }
    MapboxMapView(state = state) {
        MapContent() // Same content, different provider
    }
}
</code></pre>
<h3 id="advanced-event-handling"><a class="header" href="#advanced-event-handling">Advanced Event Handling</a></h3>
<pre><code class="language-kotlin">@Composable
fun AdvancedMapExample() {
    val mapViewState = rememberGoogleMapViewState()
    var selectedMarker by remember { mutableStateOf&lt;MarkerState?&gt;(null) }

    GoogleMapsView(
        state = mapViewState,
        onMapViewInitialized = {
            println("Map initialized successfully")
        },
        onMapLoaded = {
            println("Map loaded and ready")
        },
        onMapClick = { geoPoint -&gt;
            selectedMarker = null // Deselect on map click
        },
        onMarkerClick = { markerState -&gt;
            selectedMarker = markerState
        },
        onMarkerDragStart = { markerState -&gt;
            println("Started dragging marker: ${markerState.id}")
        },
        onMarkerDrag = { markerState -&gt;
            println("Dragging marker to: ${markerState.position}")
        },
        onMarkerDragEnd = { markerState -&gt;
            println("Finished dragging marker: ${markerState.id}")
        }
    ) {
        // Map content with interactive markers
        Marker(
            position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
            icon = DefaultIcon(
                fillColor = if (selectedMarker?.id == "marker1") Color.Yellow else Color.Blue,
                label = "1"
            ),
            draggable = true,
            extra = "Draggable marker 1"
        )

        Marker(
            position = GeoPointImpl.fromLatLong(37.7849, -122.4094),
            icon = DefaultIcon(
                fillColor = if (selectedMarker?.id == "marker2") Color.Yellow else Color.Red,
                label = "2"
            ),
            extra = "Clickable marker 2"
        )

        // Show info for selected marker
        selectedMarker?.let { marker -&gt;
            // You could show an InfoBubble or other UI here
        }
    }
}
</code></pre>
<h2 id="provider-differences"><a class="header" href="#provider-differences">Provider Differences</a></h2>
<p>While the API is consistent across providers, there are some differences in:</p>
<h3 id="supported-features"><a class="header" href="#supported-features">Supported Features</a></h3>
<ul>
<li><strong>GroundImage</strong>: Currently supported on Google Maps and ArcGIS</li>
<li><strong>Marker Animation</strong>: Available on Google Maps and Mapbox</li>
<li><strong>Custom Styling</strong>: Each provider has different map style options</li>
</ul>
<h3 id="performance-characteristics"><a class="header" href="#performance-characteristics">Performance Characteristics</a></h3>
<ul>
<li><strong>Google Maps</strong>: Excellent for general use, good marker performance</li>
<li><strong>Mapbox</strong>: Great for custom styling and large datasets</li>
<li><strong>HERE Maps</strong>: Optimized for location services integration</li>
<li><strong>ArcGIS</strong>: Best for GIS and enterprise applications</li>
</ul>
<h3 id="platform-integration"><a class="header" href="#platform-integration">Platform Integration</a></h3>
<p>Each provider may have different requirements for API keys, permissions, and platform setup. Refer to the initialization documentation for provider-specific setup instructions.</p>
<h2 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h2>
<ol>
<li><strong>Choose the Right Provider</strong>: Select based on your app’s specific needs (styling, performance, features)</li>
<li><strong>Consistent State Management</strong>: Use the same state patterns regardless of provider</li>
<li><strong>Reusable Content</strong>: Create provider-agnostic composable content when possible</li>
<li><strong>Event Handling</strong>: Implement comprehensive event handling for better user experience</li>
<li><strong>Error Handling</strong>: Always handle initialization failures and provide fallback UI</li>
<li><strong>Performance</strong>: Consider using custom rendering strategies for large numbers of markers</li>
<li><strong>Testing</strong>: Test your application with multiple providers to ensure compatibility</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="marker-1"><a class="header" href="#marker-1">Marker</a></h1>
<p>Markers are point annotations that can be placed on the map at specific geographic locations. They support custom icons, interactions, and animations.</p>
<h2 id="composable-functions"><a class="header" href="#composable-functions">Composable Functions</a></h2>
<h3 id="basic-marker"><a class="header" href="#basic-marker">Basic Marker</a></h3>
<pre><code class="language-kotlin">@Composable
fun MapViewScope.Marker(
    position: GeoPoint,
    clickable: Boolean = true,
    draggable: Boolean = false,
    icon: MarkerIcon? = null,
    extra: Serializable? = null,
    id: String? = null
)
</code></pre>
<h3 id="marker-with-state"><a class="header" href="#marker-with-state">Marker with State</a></h3>
<pre><code class="language-kotlin">@Composable
fun MapViewScope.Marker(state: MarkerState)
</code></pre>
<h2 id="parameters"><a class="header" href="#parameters">Parameters</a></h2>
<ul>
<li><strong><code>position</code></strong>: Geographic coordinates (<code>GeoPoint</code>)</li>
<li><strong><code>clickable</code></strong>: Whether the marker responds to clicks (default: <code>true</code>)</li>
<li><strong><code>draggable</code></strong>: Whether the marker can be dragged (default: <code>false</code>)</li>
<li><strong><code>icon</code></strong>: Custom icon for the marker (<code>MarkerIcon?</code>)</li>
<li><strong><code>extra</code></strong>: Additional data attached to the marker (<code>Serializable?</code>)</li>
<li><strong><code>id</code></strong>: Unique identifier for the marker (<code>String?</code>)</li>
</ul>
<h2 id="icon-types"><a class="header" href="#icon-types">Icon Types</a></h2>
<h3 id="defaulticon"><a class="header" href="#defaulticon">DefaultIcon</a></h3>
<p>Standard marker with customizable appearance:</p>
<pre><code class="language-kotlin">DefaultIcon(
    scale: Float = 1.0f,
    label: String? = null,
    fillColor: Color = Color.Red,
    strokeColor: Color = Color.Black,
    strokeWidth: Dp = 1.dp,
    labelTextColor: Color = Color.White,
    labelStrokeColor: Color? = null,
    debug: Boolean = false
)
</code></pre>
<h3 id="drawabledefaulticon"><a class="header" href="#drawabledefaulticon">DrawableDefaultIcon</a></h3>
<p>Marker using a drawable resource as background:</p>
<pre><code class="language-kotlin">DrawableDefaultIcon(
    backgroundDrawable: Drawable,
    scale: Float = 1.0f,
    strokeColor: Color? = null,
    strokeWidth: Dp = 1.dp
)
</code></pre>
<h3 id="imageicon"><a class="header" href="#imageicon">ImageIcon</a></h3>
<p>Marker using a custom drawable image:</p>
<pre><code class="language-kotlin">ImageIcon(
    drawable: Drawable,
    anchor: Offset = Offset(0.5f, 0.5f),
    debug: Boolean = false
)
</code></pre>
<h2 id="usage-examples-1"><a class="header" href="#usage-examples-1">Usage Examples</a></h2>
<h3 id="basic-marker-1"><a class="header" href="#basic-marker-1">Basic Marker</a></h3>
<pre><code class="language-kotlin">// Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
    Marker(
        position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
        extra = "San Francisco",
        id = "san-francisco-marker"
    )
}
</code></pre>
<h3 id="custom-icon-marker"><a class="header" href="#custom-icon-marker">Custom Icon Marker</a></h3>
<pre><code class="language-kotlin">// Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
    Marker(
        position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
        icon = DefaultIcon(
            scale = 1.5f,
            label = "SF",
            fillColor = Color.Blue,
            strokeColor = Color.White,
            strokeWidth = 2.dp
        ),
        extra = "San Francisco with custom icon",
        id = "custom-sf-marker"
    )
}
</code></pre>
<h3 id="draggable-marker"><a class="header" href="#draggable-marker">Draggable Marker</a></h3>
<pre><code class="language-kotlin">@Composable
fun DraggableMarkerExample() {
    var markerPosition by remember {
        mutableStateOf(GeoPointImpl.fromLatLong(37.7749, -122.4194))
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(
        state = mapViewState,
        onMarkerDrag = { markerState -&gt;
            markerPosition = markerState.position
        }
    ) {
        Marker(
            position = markerPosition,
            draggable = true,
            icon = DefaultIcon(
                label = "Drag me",
                fillColor = Color.Green
            )
        )
    }
}
</code></pre>
<h3 id="multiple-markers-with-different-icons"><a class="header" href="#multiple-markers-with-different-icons">Multiple Markers with Different Icons</a></h3>
<pre><code class="language-kotlin">// Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
    // Default icon with different scales
    Marker(
        position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
        icon = DefaultIcon(scale = 0.7f, label = "Small")
    )

    Marker(
        position = GeoPointImpl.fromLatLong(37.7849, -122.4094),
        icon = DefaultIcon(scale = 1.0f, label = "Normal")
    )

    Marker(
        position = GeoPointImpl.fromLatLong(37.7949, -122.3994),
        icon = DefaultIcon(scale = 1.4f, label = "Large")
    )

    // Custom colored marker
    Marker(
        position = GeoPointImpl.fromLatLong(37.7649, -122.4294),
        icon = DefaultIcon(
            fillColor = Color.Yellow,
            strokeColor = Color.Black,
            strokeWidth = 2.dp,
            label = "Custom"
        )
    )

    // Drawable icon marker
    val context = LocalContext.current
    AppCompatResources.getDrawable(context, R.drawable.custom_icon)?.let { drawable -&gt;
        Marker(
            position = GeoPointImpl.fromLatLong(37.7549, -122.4394),
            icon = DrawableDefaultIcon(
                backgroundDrawable = drawable,
                scale = 1.2f
            )
        )
    }
}
</code></pre>
<h3 id="marker-with-info-bubble"><a class="header" href="#marker-with-info-bubble">Marker with Info Bubble</a></h3>
<pre><code class="language-kotlin">@Composable
fun MarkerWithInfoExample() {
    var selectedMarker by remember { mutableStateOf&lt;MarkerState?&gt;(null) }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(
        state = mapViewState,
        onMapClick = { selectedMarker = null },
        onMarkerClick = { markerState -&gt; selectedMarker = markerState }
    ) {
        val markerState = MarkerState(
            position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
            icon = DefaultIcon(label = "SF"),
            extra = "San Francisco - The Golden City"
        )

        Marker(markerState)

        // Show info bubble for selected marker
        selectedMarker?.let { marker -&gt;
            InfoBubble(
                marker = marker,
                bubbleColor = Color.White
            ) {
                Text(
                    text = marker.extra as? String ?: "No info",
                    modifier = Modifier.padding(8.dp)
                )
            }
        }
    }
}
</code></pre>
<h3 id="image-icon-marker"><a class="header" href="#image-icon-marker">Image Icon Marker</a></h3>
<pre><code class="language-kotlin">// Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
    val context = LocalContext.current
    AppCompatResources.getDrawable(context, R.drawable.weather_icon)?.let { icon -&gt;
        Marker(
            position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
            icon = ImageIcon(
                drawable = icon,
                anchor = Offset(0.5f, 1.0f), // Bottom center anchor
                debug = true
            ),
            extra = "Weather station"
        )
    }
}
</code></pre>
<h2 id="event-handling-1"><a class="header" href="#event-handling-1">Event Handling</a></h2>
<p>Marker events are handled with your map provider component:</p>
<pre><code class="language-kotlin">// Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(
    state = mapViewState,
    onMarkerClick = { markerState -&gt;
        println("Marker clicked: ${markerState.extra}")
    },
    onMarkerDragStart = { markerState -&gt;
        println("Drag started for marker: ${markerState.id}")
    },
    onMarkerDrag = { markerState -&gt;
        println("Marker dragged to: ${markerState.position}")
    },
    onMarkerDragEnd = { markerState -&gt;
        println("Drag ended for marker: ${markerState.id}")
    }
) {
    // Markers
}
</code></pre>
<h2 id="marker-identification"><a class="header" href="#marker-identification">Marker Identification</a></h2>
<h3 id="using-the-id-property"><a class="header" href="#using-the-id-property">Using the ID Property</a></h3>
<p>The <code>id</code> property provides a unique identifier for markers, enabling efficient tracking and management:</p>
<pre><code class="language-kotlin">// Creating markers with unique IDs
val markers = listOf(
    Marker(
        position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
        icon = DefaultIcon(fillColor = Color.Red, label = "1"),
        extra = "Location A",
        id = "marker-location-a"
    ),
    Marker(
        position = GeoPointImpl.fromLatLong(37.7849, -122.4094),
        icon = DefaultIcon(fillColor = Color.Blue, label = "2"),
        extra = "Location B",
        id = "marker-location-b"
    )
)

// Using IDs for event handling
MapView(
    state = mapViewState,
    onMarkerClick = { markerState -&gt;
        when (markerState.id) {
            "marker-location-a" -&gt; handleLocationA()
            "marker-location-b" -&gt; handleLocationB()
            else -&gt; handleUnknownMarker()
        }
    }
) {
    markers.forEach { marker -&gt; Marker(marker) }
}
</code></pre>
<h3 id="benefits-of-using-ids"><a class="header" href="#benefits-of-using-ids">Benefits of Using IDs</a></h3>
<ul>
<li><strong>Unique Identification</strong>: Distinguish between markers even when they have identical properties</li>
<li><strong>Event Handling</strong>: Easier to handle click events and interactions</li>
<li><strong>State Management</strong>: Simplifies selection and multi-selection scenarios</li>
<li><strong>Performance</strong>: Enables efficient updates when marker properties change</li>
</ul>
<h2 id="best-practices-2"><a class="header" href="#best-practices-2">Best Practices</a></h2>
<ol>
<li><strong>Use Meaningful Extra Data</strong>: Store useful information in the <code>extra</code> property for event handling</li>
<li><strong>Provide Unique IDs</strong>: Always set unique <code>id</code> values when working with multiple markers</li>
<li><strong>Optimize Icon Resources</strong>: Reuse drawable resources and avoid creating new icons unnecessarily</li>
<li><strong>Handle Drag Events</strong>: When using draggable markers, always handle drag events to update your data</li>
<li><strong>Consider Performance</strong>: Large numbers of markers may impact performance - consider clustering</li>
<li><strong>Anchor Points</strong>: Use appropriate anchor points for custom icons to ensure proper positioning</li>
<li><strong>Consistent Styling</strong>: Maintain consistent icon styling across your application</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="infobubble"><a class="header" href="#infobubble">InfoBubble</a></h1>
<p>InfoBubble is a component that displays custom content in a speech bubble attached to a marker on the map. It provides a way to show detailed information about markers without cluttering the map interface.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>InfoBubble creates a floating overlay that appears above a specific marker, with customizable styling and content. The bubble automatically positions itself relative to the marker and follows the marker’s position when the map is panned or zoomed.</p>
<h2 id="composable-function"><a class="header" href="#composable-function">Composable Function</a></h2>
<pre><code class="language-kotlin">@Composable
fun MapViewScope.InfoBubble(
    marker: MarkerState,
    bubbleColor: Color = Color.White,
    borderColor: Color = Color.Black,
    contentPadding: Dp = 8.dp,
    cornerRadius: Dp = 4.dp,
    tailSize: Dp = 8.dp,
    content: @Composable () -&gt; Unit
)
</code></pre>
<h2 id="parameters-1"><a class="header" href="#parameters-1">Parameters</a></h2>
<ul>
<li><strong><code>marker</code></strong>: The <code>MarkerState</code> to which the bubble is attached</li>
<li><strong><code>bubbleColor</code></strong>: Background color of the bubble (default: White)</li>
<li><strong><code>borderColor</code></strong>: Border color of the bubble (default: Black)</li>
<li><strong><code>contentPadding</code></strong>: Internal padding around the content (default: 8dp)</li>
<li><strong><code>cornerRadius</code></strong>: Radius of the bubble’s rounded corners (default: 4dp)</li>
<li><strong><code>tailSize</code></strong>: Size of the speech bubble tail pointing to the marker (default: 8dp)</li>
<li><strong><code>content</code></strong>: Composable content to display inside the bubble</li>
</ul>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h2>
<h3 id="simple-text-bubble"><a class="header" href="#simple-text-bubble">Simple Text Bubble</a></h3>
<pre><code class="language-kotlin">@Composable
fun SimpleInfoBubbleExample() {
    val mapViewState = rememberGoogleMapViewState()
    var selectedMarker by remember { mutableStateOf&lt;MarkerState?&gt;(null) }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    MapView(
        state = mapViewState,
        onMapClick = { selectedMarker = null },
        onMarkerClick = { markerState -&gt; selectedMarker = markerState }
    ) {
        val markerState = MarkerState(
            position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
            icon = DefaultIcon(fillColor = Color.Blue, label = "SF"),
            extra = "San Francisco - The Golden Gate City",
            id = "sf-marker"
        )

        Marker(markerState)

        // Show info bubble for selected marker
        selectedMarker?.let { marker -&gt;
            InfoBubble(marker = marker) {
                Text(
                    text = marker.extra as? String ?: "No information",
                    style = MaterialTheme.typography.bodyMedium,
                    modifier = Modifier.padding(4.dp)
                )
            }
        }
    }
}
</code></pre>
<h3 id="custom-styled-bubble"><a class="header" href="#custom-styled-bubble">Custom Styled Bubble</a></h3>
<pre><code class="language-kotlin">@Composable
fun StyledInfoBubbleExample() {
    val mapViewState = rememberGoogleMapViewState()
    var selectedMarker by remember { mutableStateOf&lt;MarkerState?&gt;(null) }
    val isDarkTheme = isSystemInDarkTheme()

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    MapView(
        state = mapViewState,
        onMapClick = { selectedMarker = null },
        onMarkerClick = { markerState -&gt; selectedMarker = markerState }
    ) {
        val markerState = MarkerState(
            position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
            icon = DefaultIcon(fillColor = Color.Green, label = "POI"),
            extra = "Point of Interest",
            id = "poi-marker"
        )

        Marker(markerState)

        selectedMarker?.let { marker -&gt;
            InfoBubble(
                marker = marker,
                bubbleColor = if (isDarkTheme) Color.Black else Color.White,
                borderColor = if (isDarkTheme) Color.Gray else Color.Black,
                contentPadding = 12.dp,
                cornerRadius = 8.dp,
                tailSize = 10.dp
            ) {
                Text(
                    text = marker.extra as? String ?: "",
                    color = if (isDarkTheme) Color.White else Color.Black,
                    style = MaterialTheme.typography.bodyLarge
                )
            }
        }
    }
}
</code></pre>
<h2 id="advanced-usage"><a class="header" href="#advanced-usage">Advanced Usage</a></h2>
<h3 id="rich-content-bubble"><a class="header" href="#rich-content-bubble">Rich Content Bubble</a></h3>
<pre><code class="language-kotlin">data class LocationInfo(
    val name: String,
    val description: String,
    val rating: Float,
    val imageUrl: String? = null
) : java.io.Serializable

@Composable
fun RichContentBubbleExample() {
    val mapViewState = rememberGoogleMapViewState()
    var selectedMarker by remember { mutableStateOf&lt;MarkerState?&gt;(null) }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    MapView(
        state = mapViewState,
        onMapClick = { selectedMarker = null },
        onMarkerClick = { markerState -&gt; selectedMarker = markerState }
    ) {
        val locationInfo = LocationInfo(
            name = "Golden Gate Park",
            description = "A large urban park with gardens, museums, and recreational areas.",
            rating = 4.5f
        )

        val markerState = MarkerState(
            position = GeoPointImpl.fromLatLong(37.7694, -122.4862),
            icon = DefaultIcon(fillColor = Color.Green, label = "🌳"),
            extra = locationInfo,
            id = "park-marker"
        )

        Marker(markerState)

        selectedMarker?.let { marker -&gt;
            val info = marker.extra as? LocationInfo
            info?.let {
                InfoBubble(
                    marker = marker,
                    bubbleColor = Color.White,
                    borderColor = Color.Gray,
                    contentPadding = 16.dp,
                    cornerRadius = 12.dp
                ) {
                    Column(
                        modifier = Modifier.width(200.dp)
                    ) {
                        Text(
                            text = info.name,
                            style = MaterialTheme.typography.headlineSmall,
                            fontWeight = FontWeight.Bold
                        )

                        Spacer(modifier = Modifier.height(8.dp))

                        Text(
                            text = info.description,
                            style = MaterialTheme.typography.bodyMedium,
                            color = Color.Gray
                        )

                        Spacer(modifier = Modifier.height(8.dp))

                        Row(verticalAlignment = Alignment.CenterVertically) {
                            repeat(5) { index -&gt;
                                Icon(
                                    Icons.Default.Star,
                                    contentDescription = null,
                                    tint = if (index &lt; info.rating.toInt()) Color.Yellow else Color.Gray,
                                    modifier = Modifier.size(16.dp)
                                )
                            }
                            Text(
                                text = " ${info.rating}/5",
                                style = MaterialTheme.typography.bodySmall,
                                modifier = Modifier.padding(start = 4.dp)
                            )
                        }
                    }
                }
            }
        }
    }
}
</code></pre>
<h3 id="interactive-bubble-with-actions"><a class="header" href="#interactive-bubble-with-actions">Interactive Bubble with Actions</a></h3>
<pre><code class="language-kotlin">@Composable
fun InteractiveBubbleExample() {
    val mapViewState = rememberGoogleMapViewState()
    var selectedMarker by remember { mutableStateOf&lt;MarkerState?&gt;(null) }
    val context = LocalContext.current

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    MapView(
        state = mapViewState,
        onMapClick = { selectedMarker = null },
        onMarkerClick = { markerState -&gt; selectedMarker = markerState }
    ) {
        val storeInfo = StoreInfo(
            name = "Coffee Shop",
            address = "123 Main St, San Francisco",
            phone = "+1 (555) 123-4567",
            type = "coffee"
        )

        val markerState = MarkerState(
            position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
            icon = DefaultIcon(fillColor = Color(0xFF8B4513), label = "☕"),
            extra = storeInfo,
            id = "coffee-shop-marker"
        )

        Marker(markerState)

        selectedMarker?.let { marker -&gt;
            val store = marker.extra as? StoreInfo
            store?.let {
                InfoBubble(
                    marker = marker,
                    bubbleColor = Color.White,
                    borderColor = Color.Black,
                    contentPadding = 12.dp,
                    cornerRadius = 8.dp
                ) {
                    Column(
                        modifier = Modifier.width(250.dp)
                    ) {
                        Text(
                            text = store.name,
                            style = MaterialTheme.typography.titleMedium,
                            fontWeight = FontWeight.Bold
                        )

                        Text(
                            text = store.address,
                            style = MaterialTheme.typography.bodySmall,
                            color = Color.Gray,
                            modifier = Modifier.padding(vertical = 4.dp)
                        )

                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.SpaceEvenly
                        ) {
                            Button(
                                onClick = {
                                    // Handle call action
                                    val intent = Intent(Intent.ACTION_DIAL).apply {
                                        data = Uri.parse("tel:${store.phone}")
                                    }
                                    context.startActivity(intent)
                                },
                                colors = ButtonDefaults.buttonColors(backgroundColor = Color.Blue)
                            ) {
                                Icon(Icons.Default.Phone, contentDescription = "Call")
                                Text("Call", modifier = Modifier.padding(start = 4.dp))
                            }

                            Button(
                                onClick = {
                                    // Handle directions action
                                    val position = marker.position
                                    val gmmIntentUri = Uri.parse("google.navigation:q=${position.latitude},${position.longitude}")
                                    val mapIntent = Intent(Intent.ACTION_VIEW, gmmIntentUri)
                                    mapIntent.setPackage("com.google.android.apps.maps")
                                    context.startActivity(mapIntent)
                                },
                                colors = ButtonDefaults.buttonColors(backgroundColor = Color.Green)
                            ) {
                                Icon(Icons.Default.Directions, contentDescription = "Directions")
                                Text("Go", modifier = Modifier.padding(start = 4.dp))
                            }
                        }
                    }
                }
            }
        }
    }
}

data class StoreInfo(
    val name: String,
    val address: String,
    val phone: String,
    val type: String
) : java.io.Serializable
</code></pre>
<h3 id="multiple-bubbles-management"><a class="header" href="#multiple-bubbles-management">Multiple Bubbles Management</a></h3>
<pre><code class="language-kotlin">@Composable
fun MultipleBubblesExample() {
    val mapViewState = rememberGoogleMapViewState()
    var selectedMarkers by remember { mutableStateOf(setOf&lt;String&gt;()) }

    val markerData = remember {
        listOf(
            Triple(GeoPointImpl.fromLatLong(37.7749, -122.4194), "Restaurant A", Color.Red),
            Triple(GeoPointImpl.fromLatLong(37.7849, -122.4094), "Hotel B", Color.Blue),
            Triple(GeoPointImpl.fromLatLong(37.7649, -122.4294), "Shop C", Color.Green)
        )
    }

    val markerStates = remember {
        markerData.mapIndexed { index, (position, name, color) -&gt;
            MarkerState(
                id = "marker_$index",
                position = position,
                icon = DefaultIcon(fillColor = color, label = "${index + 1}"),
                extra = name
            )
        }
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    MapView(
        state = mapViewState,
        onMapClick = {
            selectedMarkers = emptySet() // Clear all selections
        },
        onMarkerClick = { markerState -&gt;
            selectedMarkers = if (selectedMarkers.contains(markerState.id)) {
                selectedMarkers - markerState.id // Deselect
            } else {
                selectedMarkers + markerState.id // Select
            }
        }
    ) {
        markerStates.forEach { markerState -&gt;
            Marker(markerState)

            // Show bubble if marker is selected
            if (selectedMarkers.contains(markerState.id)) {
                InfoBubble(
                    marker = markerState,
                    bubbleColor = Color.White,
                    borderColor = Color.Black
                ) {
                    Column {
                        Text(
                            text = markerState.extra as String,
                            style = MaterialTheme.typography.bodyMedium,
                            fontWeight = FontWeight.Bold
                        )
                        Text(
                            text = "Tap to close",
                            style = MaterialTheme.typography.bodySmall,
                            color = Color.Gray
                        )
                    }
                }
            }
        }
    }
}
</code></pre>
<h2 id="positioning-and-behavior"><a class="header" href="#positioning-and-behavior">Positioning and Behavior</a></h2>
<h3 id="automatic-positioning"><a class="header" href="#automatic-positioning">Automatic Positioning</a></h3>
<p>InfoBubble automatically positions itself above the associated marker:</p>
<ul>
<li>The bubble’s tail points to the center of the marker</li>
<li>The bubble adjusts its position to stay visible within the map viewport</li>
<li>The bubble follows the marker when the map is panned or zoomed</li>
</ul>
<h3 id="custom-positioning"><a class="header" href="#custom-positioning">Custom Positioning</a></h3>
<p>While InfoBubble automatically handles positioning, you can influence it through marker icon anchoring:</p>
<pre><code class="language-kotlin">// Marker with bottom-center anchor - bubble appears above
val markerWithBottomAnchor = MarkerState(
    position = position,
    icon = ImageDefaultIcon(
        drawable = customIcon,
        anchor = Offset(0.5f, 1.0f) // Bottom center
    )
)

// Marker with center anchor - bubble appears above center
val markerWithCenterAnchor = MarkerState(
    position = position,
    icon = ImageDefaultIcon(
        drawable = customIcon,
        anchor = Offset(0.5f, 0.5f) // Center
    )
)
</code></pre>
<h2 id="lifecycle-management"><a class="header" href="#lifecycle-management">Lifecycle Management</a></h2>
<p>InfoBubble automatically manages its lifecycle:</p>
<pre><code class="language-kotlin">// Bubble appears when component is composed
selectedMarker?.let { marker -&gt;
    InfoBubble(marker = marker) {
        // Content
    }
}

// Bubble disappears when component is removed from composition
// This happens automatically when selectedMarker becomes null
</code></pre>
<h3 id="manual-lifecycle-control"><a class="header" href="#manual-lifecycle-control">Manual Lifecycle Control</a></h3>
<pre><code class="language-kotlin">@Composable
fun ManualLifecycleExample() {
    var showBubble by remember { mutableStateOf(false) }
    val markerState = remember { /* marker state */ }

    LaunchedEffect(showBubble) {
        if (showBubble) {
            delay(3000) // Show for 3 seconds
            showBubble = false
        }
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    MapView(state = mapViewState) {
        Marker(markerState)

        if (showBubble) {
            InfoBubble(marker = markerState) {
                Text("Auto-hiding bubble")
            }
        }
    }
}
</code></pre>
<h2 id="styling-and-theming"><a class="header" href="#styling-and-theming">Styling and Theming</a></h2>
<h3 id="dark-mode-support"><a class="header" href="#dark-mode-support">Dark Mode Support</a></h3>
<pre><code class="language-kotlin">@Composable
fun DarkModeInfoBubble(marker: MarkerState) {
    val isDarkTheme = isSystemInDarkTheme()

    InfoBubble(
        marker = marker,
        bubbleColor = if (isDarkTheme) Color(0xFF2D2D2D) else Color.White,
        borderColor = if (isDarkTheme) Color(0xFF555555) else Color.Black,
        contentPadding = 12.dp,
        cornerRadius = 8.dp
    ) {
        Text(
            text = marker.extra as? String ?: "",
            color = if (isDarkTheme) Color.White else Color.Black,
            style = MaterialTheme.typography.bodyMedium
        )
    }
}
</code></pre>
<h3 id="custom-themes"><a class="header" href="#custom-themes">Custom Themes</a></h3>
<pre><code class="language-kotlin">data class BubbleTheme(
    val backgroundColor: Color,
    val borderColor: Color,
    val textColor: Color,
    val contentPadding: Dp,
    val cornerRadius: Dp,
    val tailSize: Dp
) : java.io.Serializable

val DefaultBubbleTheme = BubbleTheme(
    backgroundColor = Color.White,
    borderColor = Color.Black,
    textColor = Color.Black,
    contentPadding = 8.dp,
    cornerRadius = 4.dp,
    tailSize = 8.dp
)

val DarkBubbleTheme = BubbleTheme(
    backgroundColor = Color(0xFF2D2D2D),
    borderColor = Color(0xFF555555),
    textColor = Color.White,
    contentPadding = 12.dp,
    cornerRadius = 8.dp,
    tailSize = 10.dp
)

@Composable
fun ThemedInfoBubble(
    marker: MarkerState,
    theme: BubbleTheme = DefaultBubbleTheme,
    content: @Composable () -&gt; Unit
) {
    InfoBubble(
        marker = marker,
        bubbleColor = theme.backgroundColor,
        borderColor = theme.borderColor,
        contentPadding = theme.contentPadding,
        cornerRadius = theme.cornerRadius,
        tailSize = theme.tailSize,
        content = content
    )
}
</code></pre>
<h2 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h2>
<h3 id="efficient-updates"><a class="header" href="#efficient-updates">Efficient Updates</a></h3>
<pre><code class="language-kotlin">// Good: Use stable keys for markers
val markerStates = remember(markersData) {
    markersData.map { data -&gt;
        MarkerState(
            id = "marker_${data.id}", // Stable ID
            position = data.position,
            extra = data
        )
    }
}

// Avoid: Creating new marker states on each recomposition
val markerStates = markersData.map { data -&gt;
    MarkerState(position = data.position, extra = data) // New instance each time
}
</code></pre>
<h3 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h3>
<pre><code class="language-kotlin">// Clear selected markers when leaving screen
DisposableEffect(Unit) {
    onDispose {
        selectedMarker = null // Clears InfoBubble
    }
}
</code></pre>
<h2 id="best-practices-3"><a class="header" href="#best-practices-3">Best Practices</a></h2>
<h3 id="design-guidelines"><a class="header" href="#design-guidelines">Design Guidelines</a></h3>
<ol>
<li><strong>Keep Content Concise</strong>: InfoBubbles should provide essential information without overwhelming users</li>
<li><strong>Use Appropriate Sizing</strong>: Limit bubble width to maintain readability on mobile devices</li>
<li><strong>Provide Clear Actions</strong>: If including buttons, make their purpose obvious</li>
<li><strong>Consider Touch Targets</strong>: Ensure interactive elements meet minimum touch target sizes</li>
</ol>
<h3 id="user-experience"><a class="header" href="#user-experience">User Experience</a></h3>
<ol>
<li><strong>Dismiss Behavior</strong>: Allow users to dismiss bubbles by tapping the map or marker</li>
<li><strong>Loading States</strong>: Show loading indicators for content that requires network requests</li>
<li><strong>Error Handling</strong>: Gracefully handle missing or invalid data</li>
<li><strong>Accessibility</strong>: Provide content descriptions for screen readers</li>
</ol>
<h3 id="implementation-tips"><a class="header" href="#implementation-tips">Implementation Tips</a></h3>
<pre><code class="language-kotlin">// Good: Stable marker references
val markerState = remember(markerId) {
    MarkerState(id = markerId, position = position)
}

// Good: Efficient content updates
LaunchedEffect(selectedMarkerId) {
    if (selectedMarkerId != null) {
        // Load additional data if needed
    }
}

// Avoid: Heavy computations in bubble content
InfoBubble(marker = marker) {
    // Avoid expensive operations here
    val processedData = remember(marker.extra) {
        processData(marker.extra) // Move to remember
    }
    DisplayContent(processedData)
}
</code></pre>
<h2 id="troubleshooting-4"><a class="header" href="#troubleshooting-4">Troubleshooting</a></h2>
<h3 id="common-issues-4"><a class="header" href="#common-issues-4">Common Issues</a></h3>
<ol>
<li><strong>Bubble Not Appearing</strong>: Verify marker is properly composed and InfoBubble is inside MapViewScope</li>
<li><strong>Bubble Not Dismissing</strong>: Check that the conditional rendering properly responds to state changes</li>
<li><strong>Poor Performance</strong>: Limit number of simultaneous bubbles and optimize content composition</li>
<li><strong>Layout Issues</strong>: Use appropriate sizing constraints and test on different screen sizes</li>
</ol>
<h3 id="debug-mode"><a class="header" href="#debug-mode">Debug Mode</a></h3>
<pre><code class="language-kotlin">// Enable debug logging for InfoBubble positioning
InfoBubble(
    marker = marker,
    bubbleColor = Color.Yellow.copy(alpha = 0.8f), // Highlight for debugging
    borderColor = Color.Red
) {
    Column {
        Text("Marker ID: ${marker.id}")
        Text("Position: ${marker.position}")
        // Your actual content
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="circle-1"><a class="header" href="#circle-1">Circle</a></h1>
<p>Circles are circular overlays that can be drawn on the map with customizable radius, stroke, and fill properties. They are useful for representing areas, ranges, or zones.</p>
<h2 id="composable-functions-1"><a class="header" href="#composable-functions-1">Composable Functions</a></h2>
<h3 id="basic-circle"><a class="header" href="#basic-circle">Basic Circle</a></h3>
<pre><code class="language-kotlin">@Composable
fun MapViewScope.Circle(
    center: GeoPoint,
    radius: Double,
    strokeColor: Color = Color.Red,
    strokeWidth: Dp = 2.dp,
    fillColor: Color = Color.White.copy(alpha = 0.5f),
    extra: Serializable? = null,
    id: String? = null
)
</code></pre>
<h3 id="circle-with-state"><a class="header" href="#circle-with-state">Circle with State</a></h3>
<pre><code class="language-kotlin">@Composable
fun MapViewScope.Circle(state: CircleState)
</code></pre>
<h2 id="parameters-2"><a class="header" href="#parameters-2">Parameters</a></h2>
<ul>
<li><strong><code>center</code></strong>: Geographic center point of the circle (<code>GeoPoint</code>)</li>
<li><strong><code>radius</code></strong>: Radius in meters (<code>Double</code>)</li>
<li><strong><code>strokeColor</code></strong>: Color of the circle’s border (default: <code>Color.Red</code>)</li>
<li><strong><code>strokeWidth</code></strong>: Width of the border line (default: <code>2.dp</code>)</li>
<li><strong><code>fillColor</code></strong>: Fill color of the circle interior (default: semi-transparent white)</li>
<li><strong><code>extra</code></strong>: Additional data attached to the circle (<code>Serializable?</code>)</li>
<li><strong><code>id</code></strong>: Unique identifier for the circle (<code>String?</code>)</li>
</ul>
<h2 id="usage-examples-2"><a class="header" href="#usage-examples-2">Usage Examples</a></h2>
<h3 id="basic-circle-1"><a class="header" href="#basic-circle-1">Basic Circle</a></h3>
<pre><code class="language-kotlin">// Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
    Circle(
        center = GeoPointImpl.fromLatLong(37.7749, -122.4194),
        radius = 1000.0, // 1km radius
        strokeColor = Color.Blue,
        fillColor = Color.Blue.copy(alpha = 0.3f),
        id = "downtown-area"
    )
}
</code></pre>
<h3 id="interactive-circle-with-markers"><a class="header" href="#interactive-circle-with-markers">Interactive Circle with Markers</a></h3>
<p>Based on the example app, here’s how to create an interactive circle with draggable markers:</p>
<pre><code class="language-kotlin">@Composable
fun InteractiveCircleExample() {
    var centerPosition by remember {
        mutableStateOf(GeoPointImpl.fromLatLong(37.7749, -122.4194))
    }
    var radius by remember { mutableStateOf(1000.0) }

    // Calculate edge marker position
    val edgePosition = remember(centerPosition, radius) {
        // Calculate a point that's 'radius' meters away from center
        // This is simplified - actual calculation would consider Earth's curvature
        val latOffset = radius / 111000.0 // Rough meters per degree latitude
        GeoPointImpl.fromLatLong(
            centerPosition.latitude + latOffset,
            centerPosition.longitude
        )
    }

    val circleState = CircleState(
        center = centerPosition,
        radiusMeters = radius,
        strokeColor = Color.Blue,
        fillColor = Color.Blue.copy(alpha = 0.3f),
        clickable = true
    )

    val centerMarker = MarkerState(
        position = centerPosition,
        icon = DefaultIcon(
            fillColor = Color.Blue,
            label = "C"
        ),
        draggable = false
    )

    val edgeMarker = MarkerState(
        position = edgePosition,
        icon = DefaultIcon(
            fillColor = Color.Green,
            label = "E"
        ),
        draggable = true
    )

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(
        state = mapViewState,
        onMarkerDrag = { markerState -&gt;
            if (markerState.id == edgeMarker.id) {
                // Calculate new radius based on edge marker position
                val distance = calculateDistance(centerPosition, markerState.position)
                radius = distance
            }
        },
        onCircleClick = { circleEvent -&gt;
            println("Circle clicked at: ${circleEvent.clicked}")
        }
    ) {
        Circle(circleState)
        Marker(centerMarker)
        Marker(edgeMarker)
    }
}
</code></pre>
<h3 id="multiple-circles-with-different-styles"><a class="header" href="#multiple-circles-with-different-styles">Multiple Circles with Different Styles</a></h3>
<pre><code class="language-kotlin">// Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
    // Solid red circle
    Circle(
        center = GeoPointImpl.fromLatLong(37.7749, -122.4194),
        radius = 500.0,
        strokeColor = Color.Red,
        strokeWidth = 3.dp,
        fillColor = Color.Red.copy(alpha = 0.2f),
        extra = "Red zone"
    )

    // Blue circle with thick border
    Circle(
        center = GeoPointImpl.fromLatLong(37.7849, -122.4194),
        radius = 750.0,
        strokeColor = Color.Blue,
        strokeWidth = 5.dp,
        fillColor = Color.Transparent,
        extra = "Blue boundary"
    )

    // Green circle with pattern
    Circle(
        center = GeoPointImpl.fromLatLong(37.7649, -122.4194),
        radius = 300.0,
        strokeColor = Color.Green,
        strokeWidth = 2.dp,
        fillColor = Color.Green.copy(alpha = 0.4f),
        extra = "Green area"
    )
}
</code></pre>
<h3 id="dynamic-circle-updates"><a class="header" href="#dynamic-circle-updates">Dynamic Circle Updates</a></h3>
<pre><code class="language-kotlin">@Composable
fun DynamicCircleExample() {
    var circleRadius by remember { mutableStateOf(500.0) }
    var circleColor by remember { mutableStateOf(Color.Blue) }

    Column {
        // Controls
        Slider(
            value = circleRadius.toFloat(),
            onValueChange = { circleRadius = it.toDouble() },
            valueRange = 100f..2000f,
            modifier = Modifier.padding(16.dp)
        )

        Row {
            Button(onClick = { circleColor = Color.Red }) {
                Text("Red")
            }
            Button(onClick = { circleColor = Color.Blue }) {
                Text("Blue")
            }
            Button(onClick = { circleColor = Color.Green }) {
                Text("Green")
            }
        }

        // Map with dynamic circle
        // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
            Circle(
                center = GeoPointImpl.fromLatLong(37.7749, -122.4194),
                radius = circleRadius,
                strokeColor = circleColor,
                fillColor = circleColor.copy(alpha = 0.3f)
            )

            // Center marker
            Marker(
                position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
                icon = DefaultIcon(
                    fillColor = circleColor,
                    label = "${circleRadius.toInt()}m"
                )
            )
        }
    }
}
</code></pre>
<h3 id="overlapping-circles-with-z-index"><a class="header" href="#overlapping-circles-with-z-index">Overlapping Circles with Z-Index</a></h3>
<pre><code class="language-kotlin">// Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
    val centerPoint = GeoPointImpl.fromLatLong(37.7749, -122.4194)

    // Background circle (larger, lower z-index)
    Circle(
        center = centerPoint,
        radius = 1000.0,
        strokeColor = Color.Red,
        fillColor = Color.Red.copy(alpha = 0.2f),
        extra = CircleData(zIndex = 1, name = "Outer circle")
    )

    // Foreground circle (smaller, higher z-index)
    Circle(
        center = centerPoint,
        radius = 500.0,
        strokeColor = Color.Blue,
        fillColor = Color.Blue.copy(alpha = 0.4f),
        extra = CircleData(zIndex = 2, name = "Inner circle")
    )
}
</code></pre>
<h2 id="event-handling-2"><a class="header" href="#event-handling-2">Event Handling</a></h2>
<p>Circle interactions are handled with your map provider component:</p>
<pre><code class="language-kotlin">// Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(
    state = mapViewState,
    onCircleClick = { circleEvent -&gt;
        val circle = circleEvent.state
        val clickPoint = circleEvent.clicked

        println("Circle clicked:")
        println("  Center: ${circle.center}")
        println("  Radius: ${circle.radiusMeters}m")
        println("  Click point: ${clickPoint}")
        println("  Extra data: ${circle.extra}")
    }
) {
    Circle(
        center = GeoPointImpl.fromLatLong(37.7749, -122.4194),
        radius = 1000.0,
        clickable = true,
        extra = "Clickable circle"
    )
}
</code></pre>
<h2 id="styling-options"><a class="header" href="#styling-options">Styling Options</a></h2>
<h3 id="stroke-styles"><a class="header" href="#stroke-styles">Stroke Styles</a></h3>
<pre><code class="language-kotlin">// Thin border
Circle(
    center = center,
    radius = 500.0,
    strokeColor = Color.Black,
    strokeWidth = 1.dp
)

// Thick border
Circle(
    center = center,
    radius = 500.0,
    strokeColor = Color.Black,
    strokeWidth = 5.dp
)

// No border
Circle(
    center = center,
    radius = 500.0,
    strokeColor = Color.Transparent,
    strokeWidth = 0.dp
)
</code></pre>
<h3 id="fill-styles"><a class="header" href="#fill-styles">Fill Styles</a></h3>
<pre><code class="language-kotlin">// Solid fill
Circle(
    center = center,
    radius = 500.0,
    fillColor = Color.Red
)

// Semi-transparent fill
Circle(
    center = center,
    radius = 500.0,
    fillColor = Color.Red.copy(alpha = 0.5f)
)

// No fill
Circle(
    center = center,
    radius = 500.0,
    fillColor = Color.Transparent
)
</code></pre>
<h2 id="circle-identification"><a class="header" href="#circle-identification">Circle Identification</a></h2>
<h3 id="using-the-id-property-1"><a class="header" href="#using-the-id-property-1">Using the ID Property</a></h3>
<p>The <code>id</code> property provides a unique identifier for circles, enabling efficient tracking and management:</p>
<pre><code class="language-kotlin">// Creating circles with unique IDs
val circles = listOf(
    Circle(
        center = GeoPointImpl.fromLatLong(37.7749, -122.4194),
        radius = 1000.0,
        strokeColor = Color.Red,
        fillColor = Color.Red.copy(alpha = 0.3f),
        id = "zone-a"
    ),
    Circle(
        center = GeoPointImpl.fromLatLong(37.7849, -122.4094),
        radius = 1500.0,
        strokeColor = Color.Blue,
        fillColor = Color.Blue.copy(alpha = 0.3f),
        id = "zone-b"
    )
)

// Using IDs for event handling
MapView(
    state = mapViewState,
    onCircleClick = { circleEvent -&gt;
        when (circleEvent.state.id) {
            "zone-a" -&gt; handleZoneA()
            "zone-b" -&gt; handleZoneB()
            else -&gt; handleUnknownZone()
        }
    }
) {
    circles.forEach { circle -&gt; Circle(circle) }
}
</code></pre>
<h3 id="benefits-of-using-ids-1"><a class="header" href="#benefits-of-using-ids-1">Benefits of Using IDs</a></h3>
<ul>
<li><strong>Unique Identification</strong>: Distinguish between circles even when they have similar properties</li>
<li><strong>Event Handling</strong>: Simplifies click event handling and area-specific logic</li>
<li><strong>State Management</strong>: Enables efficient updates and selection management</li>
<li><strong>Performance</strong>: Facilitates optimized rendering and updates</li>
</ul>
<h2 id="best-practices-4"><a class="header" href="#best-practices-4">Best Practices</a></h2>
<ol>
<li><strong>Use Appropriate Radius</strong>: Consider the map zoom level when setting circle radius</li>
<li><strong>Provide Unique IDs</strong>: Always set unique <code>id</code> values when working with multiple circles</li>
<li><strong>Color Contrast</strong>: Ensure stroke and fill colors provide good visibility on the map</li>
<li><strong>Performance</strong>: Avoid creating too many large circles as they may impact rendering performance</li>
<li><strong>Interactive Feedback</strong>: Provide visual feedback when circles are clickable</li>
<li><strong>Consistent Styling</strong>: Maintain consistent circle styling across your application</li>
<li><strong>Extra Data</strong>: Use the <code>extra</code> parameter to store metadata for event handling</li>
<li><strong>Z-Index Management</strong>: Consider drawing order when circles overlap</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polyline-1"><a class="header" href="#polyline-1">Polyline</a></h1>
<p>Polylines are sequences of line segments that connect multiple geographic points. They are commonly used for routes, paths, boundaries, or any linear features on the map.</p>
<h2 id="composable-functions-2"><a class="header" href="#composable-functions-2">Composable Functions</a></h2>
<h3 id="basic-polyline"><a class="header" href="#basic-polyline">Basic Polyline</a></h3>
<pre><code class="language-kotlin">@Composable
fun MapViewScope.Polyline(
    points: List&lt;GeoPoint&gt;,
    id: String? = null,
    strokeColor: Color = Color.Black,
    strokeWidth: Dp = 1.dp,
    geodesic: Boolean = false,
    extra: Serializable? = null
)
</code></pre>
<h3 id="polyline-with-state"><a class="header" href="#polyline-with-state">Polyline with State</a></h3>
<pre><code class="language-kotlin">@Composable
fun MapViewScope.Polyline(state: PolylineState)
</code></pre>
<h2 id="parameters-3"><a class="header" href="#parameters-3">Parameters</a></h2>
<ul>
<li><strong><code>points</code></strong>: List of geographic coordinates that define the line segments (<code>List&lt;GeoPoint&gt;</code>)</li>
<li><strong><code>id</code></strong>: Optional unique identifier for the polyline (<code>String?</code>)</li>
<li><strong><code>strokeColor</code></strong>: Color of the line (default: <code>Color.Black</code>)</li>
<li><strong><code>strokeWidth</code></strong>: Width of the line (default: <code>1.dp</code>)</li>
<li><strong><code>geodesic</code></strong>: Whether to draw geodesic lines (following Earth’s curvature, default: <code>false</code>)</li>
<li><strong><code>extra</code></strong>: Additional data attached to the polyline (<code>Serializable?</code>)</li>
</ul>
<h2 id="usage-examples-3"><a class="header" href="#usage-examples-3">Usage Examples</a></h2>
<h3 id="basic-polyline-1"><a class="header" href="#basic-polyline-1">Basic Polyline</a></h3>
<pre><code class="language-kotlin">// Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
    val routePoints = listOf(
        GeoPointImpl.fromLatLong(37.7749, -122.4194), // San Francisco
        GeoPointImpl.fromLatLong(37.7849, -122.4094), // Point 2
        GeoPointImpl.fromLatLong(37.7949, -122.3994), // Point 3
        GeoPointImpl.fromLatLong(37.8049, -122.3894)  // Point 4
    )

    Polyline(
        points = routePoints,
        strokeColor = Color.Blue,
        strokeWidth = 3.dp
    )
}
</code></pre>
<h3 id="interactive-polyline-with-waypoint-markers"><a class="header" href="#interactive-polyline-with-waypoint-markers">Interactive Polyline with Waypoint Markers</a></h3>
<p>Based on the example app pattern:</p>
<pre><code class="language-kotlin">@Composable
fun InteractivePolylineExample() {
    var waypoints by remember {
        mutableStateOf(
            listOf(
                GeoPointImpl.fromLatLong(37.7749, -122.4194),
                GeoPointImpl.fromLatLong(37.7849, -122.4094),
                GeoPointImpl.fromLatLong(37.7949, -122.3994)
            )
        )
    }

    val polylineState = PolylineState(
        points = waypoints,
        strokeColor = Color.Blue,
        strokeWidth = 4.dp,
        geodesic = true
    )

    val waypointMarkers = waypoints.mapIndexed { index, point -&gt;
        MarkerState(
            position = point,
            icon = DefaultIcon(
                fillColor = Color.Blue,
                label = "${index + 1}"
            ),
            draggable = true,
            extra = "Waypoint $index"
        )
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(
        state = mapViewState,
        onMarkerDrag = { markerState -&gt;
            val markerIndex = markerState.extra.toString().substringAfter("Waypoint ").toIntOrNull()
            markerIndex?.let { index -&gt;
                waypoints = waypoints.toMutableList().apply {
                    if (index &lt; size) {
                        set(index, markerState.position)
                    }
                }
            }
        }
    ) {
        // Draw the polyline
        Polyline(polylineState)

        // Draw waypoint markers
        waypointMarkers.forEach { marker -&gt;
            Marker(marker)
        }
    }
}
</code></pre>
<h3 id="multiple-polylines-with-different-styles"><a class="header" href="#multiple-polylines-with-different-styles">Multiple Polylines with Different Styles</a></h3>
<pre><code class="language-kotlin">// Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
    // Route 1 - Highway (thick blue line)
    Polyline(
        points = listOf(
            GeoPointImpl.fromLatLong(37.7749, -122.4194),
            GeoPointImpl.fromLatLong(37.7849, -122.4094),
            GeoPointImpl.fromLatLong(37.7949, -122.3994)
        ),
        strokeColor = Color.Blue,
        strokeWidth = 6.dp,
        geodesic = true,
        extra = "Highway route"
    )

    // Route 2 - Walking path (thin green line)
    Polyline(
        points = listOf(
            GeoPointImpl.fromLatLong(37.7749, -122.4194),
            GeoPointImpl.fromLatLong(37.7799, -122.4144),
            GeoPointImpl.fromLatLong(37.7849, -122.4094)
        ),
        strokeColor = Color.Green,
        strokeWidth = 2.dp,
        geodesic = false,
        extra = "Walking path"
    )

    // Route 3 - Bike path (dashed-looking red line)
    Polyline(
        points = listOf(
            GeoPointImpl.fromLatLong(37.7749, -122.4194),
            GeoPointImpl.fromLatLong(37.7729, -122.4174),
            GeoPointImpl.fromLatLong(37.7709, -122.4154)
        ),
        strokeColor = Color.Red,
        strokeWidth = 3.dp,
        extra = "Bike path"
    )
}
</code></pre>
<h3 id="dynamic-polyline-construction"><a class="header" href="#dynamic-polyline-construction">Dynamic Polyline Construction</a></h3>
<pre><code class="language-kotlin">@Composable
fun DynamicPolylineExample() {
    var points by remember { mutableStateOf&lt;List&lt;GeoPoint&gt;&gt;(emptyList()) }
    var isDrawing by remember { mutableStateOf(false) }

    Column {
        Row {
            Button(
                onClick = { isDrawing = !isDrawing }
            ) {
                Text(if (isDrawing) "Stop Drawing" else "Start Drawing")
            }

            Button(
                onClick = { points = emptyList() }
            ) {
                Text("Clear")
            }
        }

        // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(
            state = mapViewState,
            onMapClick = { geoPoint -&gt;
                if (isDrawing) {
                    points = points + geoPoint
                }
            }
        ) {
            if (points.isNotEmpty()) {
                Polyline(
                    points = points,
                    strokeColor = Color.Red,
                    strokeWidth = 3.dp
                )

                // Add markers at each point
                points.forEachIndexed { index, point -&gt;
                    Marker(
                        position = point,
                        icon = DefaultIcon(
                            fillColor = if (index == 0) Color.Green
                                      else if (index == points.size - 1) Color.Red
                                      else Color.Blue,
                            label = "${index + 1}",
                            scale = 0.8f
                        )
                    )
                }
            }
        }
    }
}
</code></pre>
<h3 id="geodesic-vs-standard-lines"><a class="header" href="#geodesic-vs-standard-lines">Geodesic vs Standard Lines</a></h3>
<pre><code class="language-kotlin">// Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
    val longDistancePoints = listOf(
        GeoPointImpl.fromLatLong(37.7749, -122.4194), // San Francisco
        GeoPointImpl.fromLatLong(40.7128, -74.0060)   // New York
    )

    // Standard line (straight on map projection)
    Polyline(
        points = longDistancePoints,
        strokeColor = Color.Red,
        strokeWidth = 3.dp,
        geodesic = false,
        extra = "Straight line"
    )

    // Geodesic line (follows Earth's curvature)
    Polyline(
        points = longDistancePoints,
        strokeColor = Color.Blue,
        strokeWidth = 3.dp,
        geodesic = true,
        extra = "Geodesic line"
    )
}
</code></pre>
<h3 id="animated-route-progress"><a class="header" href="#animated-route-progress">Animated Route Progress</a></h3>
<pre><code class="language-kotlin">@Composable
fun AnimatedRouteExample() {
    val fullRoute = remember {
        listOf(
            GeoPointImpl.fromLatLong(37.7749, -122.4194),
            GeoPointImpl.fromLatLong(37.7849, -122.4094),
            GeoPointImpl.fromLatLong(37.7949, -122.3994),
            GeoPointImpl.fromLatLong(37.8049, -122.3894)
        )
    }

    var progress by remember { mutableStateOf(0f) }

    LaunchedEffect(Unit) {
        while (true) {
            delay(100)
            progress = (progress + 0.01f) % 1f
        }
    }

    val currentPointCount = (fullRoute.size * progress).toInt().coerceAtLeast(2)
    val visibleRoute = fullRoute.take(currentPointCount)

    Column {
        LinearProgressIndicator(
            progress = progress,
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp)
        )

        // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
            if (visibleRoute.size &gt;= 2) {
                // Completed route (gray)
                Polyline(
                    points = visibleRoute,
                    strokeColor = Color.Blue,
                    strokeWidth = 4.dp
                )

                // Current position marker
                Marker(
                    position = visibleRoute.last(),
                    icon = DefaultIcon(
                        fillColor = Color.Red,
                        label = "🚗"
                    )
                )
            }

            // Full route preview (light gray)
            Polyline(
                points = fullRoute,
                strokeColor = Color.LightGray,
                strokeWidth = 2.dp
            )
        }
    }
}
</code></pre>
<h2 id="event-handling-3"><a class="header" href="#event-handling-3">Event Handling</a></h2>
<p>Polyline interactions are handled with your map provider component:</p>
<pre><code class="language-kotlin">// Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(
    state = mapViewState,
    onPolylineClick = { polylineEvent -&gt;
        val polyline = polylineEvent.state
        val clickPoint = polylineEvent.clicked

        println("Polyline clicked:")
        println("  Points count: ${polyline.points.size}")
        println("  Click location: ${clickPoint}")
        println("  Extra data: ${polyline.extra}")
    }
) {
    Polyline(
        points = routePoints,
        strokeColor = Color.Blue,
        strokeWidth = 4.dp,
        extra = "Interactive route"
    )
}
</code></pre>
<h2 id="styling-options-1"><a class="header" href="#styling-options-1">Styling Options</a></h2>
<h3 id="line-width-variations"><a class="header" href="#line-width-variations">Line Width Variations</a></h3>
<pre><code class="language-kotlin">// Thin line
Polyline(
    points = points,
    strokeWidth = 1.dp
)

// Medium line
Polyline(
    points = points,
    strokeWidth = 3.dp
)

// Thick line
Polyline(
    points = points,
    strokeWidth = 8.dp
)
</code></pre>
<h3 id="color-variations"><a class="header" href="#color-variations">Color Variations</a></h3>
<pre><code class="language-kotlin">// Solid colors
Polyline(points = points, strokeColor = Color.Red)
Polyline(points = points, strokeColor = Color.Blue)
Polyline(points = points, strokeColor = Color.Green)

// Semi-transparent
Polyline(points = points, strokeColor = Color.Red.copy(alpha = 0.7f))

// Custom colors
Polyline(
    points = points,
    strokeColor = Color(0xFF4CAF50) // Material Green
)
</code></pre>
<h2 id="best-practices-5"><a class="header" href="#best-practices-5">Best Practices</a></h2>
<ol>
<li><strong>Point Density</strong>: Balance between detail and performance - too many points can slow rendering</li>
<li><strong>Geodesic Lines</strong>: Use geodesic lines for long-distance routes to show accurate paths</li>
<li><strong>Visual Hierarchy</strong>: Use different colors and widths to distinguish between different types of routes</li>
<li><strong>Interactive Feedback</strong>: Provide visual feedback when polylines are clickable</li>
<li><strong>Performance</strong>: Consider using simplified geometries for complex polylines at certain zoom levels</li>
<li><strong>Color Contrast</strong>: Ensure polyline colors stand out against the map background</li>
<li><strong>Route Direction</strong>: Consider adding arrows or markers to indicate direction along the route</li>
<li><strong>State Management</strong>: Store polyline data efficiently and update reactively when needed</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polygon-1"><a class="header" href="#polygon-1">Polygon</a></h1>
<p>Polygons are closed shapes that define areas on the map with customizable stroke and fill properties. They are useful for representing zones, regions, boundaries, or any area-based features.</p>
<h2 id="composable-functions-3"><a class="header" href="#composable-functions-3">Composable Functions</a></h2>
<h3 id="basic-polygon"><a class="header" href="#basic-polygon">Basic Polygon</a></h3>
<pre><code class="language-kotlin">@Composable
fun MapViewScope.Polygon(
    points: List&lt;GeoPoint&gt;,
    id: String? = null,
    strokeColor: Color = Color.Black,
    strokeWidth: Dp = 1.dp,
    fillColor: Color = Color.Transparent,
    geodesic: Boolean = false,
    extra: Serializable? = null
)
</code></pre>
<h3 id="polygon-with-state"><a class="header" href="#polygon-with-state">Polygon with State</a></h3>
<pre><code class="language-kotlin">@Composable
fun MapViewScope.Polygon(state: PolygonState)
</code></pre>
<h2 id="parameters-4"><a class="header" href="#parameters-4">Parameters</a></h2>
<ul>
<li><strong><code>points</code></strong>: List of geographic coordinates that define the polygon vertices (<code>List&lt;GeoPoint&gt;</code>)</li>
<li><strong><code>id</code></strong>: Optional unique identifier for the polygon (<code>String?</code>)</li>
<li><strong><code>strokeColor</code></strong>: Color of the polygon border (default: <code>Color.Black</code>)</li>
<li><strong><code>strokeWidth</code></strong>: Width of the border line (default: <code>1.dp</code>)</li>
<li><strong><code>fillColor</code></strong>: Fill color of the polygon interior (default: <code>Color.Transparent</code>)</li>
<li><strong><code>geodesic</code></strong>: Whether to draw geodesic edges (default: <code>false</code>)</li>
<li><strong><code>extra</code></strong>: Additional data attached to the polygon (<code>Serializable?</code>)</li>
</ul>
<h2 id="usage-examples-4"><a class="header" href="#usage-examples-4">Usage Examples</a></h2>
<h3 id="basic-polygon-1"><a class="header" href="#basic-polygon-1">Basic Polygon</a></h3>
<pre><code class="language-kotlin">// Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
    val trianglePoints = listOf(
        GeoPointImpl.fromLatLong(37.7749, -122.4194), // Point 1
        GeoPointImpl.fromLatLong(37.7849, -122.4094), // Point 2
        GeoPointImpl.fromLatLong(37.7749, -122.3994), // Point 3
        GeoPointImpl.fromLatLong(37.7749, -122.4194)  // Close the polygon
    )

    Polygon(
        points = trianglePoints,
        strokeColor = Color.Blue,
        strokeWidth = 2.dp,
        fillColor = Color.Blue.copy(alpha = 0.3f)
    )
}
</code></pre>
<h3 id="interactive-polygon-with-vertex-markers"><a class="header" href="#interactive-polygon-with-vertex-markers">Interactive Polygon with Vertex Markers</a></h3>
<p>Based on the example app pattern:</p>
<pre><code class="language-kotlin">@Composable
fun InteractivePolygonExample() {
    var vertices by remember {
        mutableStateOf(
            listOf(
                GeoPointImpl.fromLatLong(37.7749, -122.4194),
                GeoPointImpl.fromLatLong(37.7849, -122.4094),
                GeoPointImpl.fromLatLong(37.7799, -122.3994),
                GeoPointImpl.fromLatLong(37.7649, -122.4094)
            )
        )
    }

    // Close the polygon by adding the first point at the end
    val closedVertices = vertices + vertices.first()

    val polygonState = PolygonState(
        points = closedVertices,
        strokeColor = Color.Red,
        strokeWidth = 3.dp,
        fillColor = Color.Red.copy(alpha = 0.2f),
        geodesic = false
    )

    val vertexMarkers = vertices.mapIndexed { index, point -&gt;
        MarkerState(
            position = point,
            icon = DefaultIcon(
                fillColor = Color.Red,
                strokeColor = Color.White,
                label = "${index + 1}",
                scale = 0.8f
            ),
            draggable = true,
            extra = "Vertex $index"
        )
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(
        state = mapViewState,
        onMarkerDrag = { markerState -&gt;
            val vertexIndex = markerState.extra.toString().substringAfter("Vertex ").toIntOrNull()
            vertexIndex?.let { index -&gt;
                vertices = vertices.toMutableList().apply {
                    if (index &lt; size) {
                        set(index, markerState.position)
                    }
                }
            }
        },
        onPolygonClick = { polygonEvent -&gt;
            println("Polygon clicked at: ${polygonEvent.clicked}")
        }
    ) {
        // Draw the polygon
        Polygon(polygonState)

        // Draw vertex markers
        vertexMarkers.forEach { marker -&gt;
            Marker(marker)
        }
    }
}
</code></pre>
<h3 id="multiple-polygons-with-different-styles"><a class="header" href="#multiple-polygons-with-different-styles">Multiple Polygons with Different Styles</a></h3>
<pre><code class="language-kotlin">// Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
    // Solid filled polygon
    Polygon(
        points = listOf(
            GeoPointImpl.fromLatLong(37.7749, -122.4194),
            GeoPointImpl.fromLatLong(37.7849, -122.4194),
            GeoPointImpl.fromLatLong(37.7849, -122.4094),
            GeoPointImpl.fromLatLong(37.7749, -122.4094),
            GeoPointImpl.fromLatLong(37.7749, -122.4194)
        ),
        strokeColor = Color.Blue,
        strokeWidth = 2.dp,
        fillColor = Color.Blue.copy(alpha = 0.4f),
        extra = "Blue zone"
    )

    // Border-only polygon
    Polygon(
        points = listOf(
            GeoPointImpl.fromLatLong(37.7649, -122.4194),
            GeoPointImpl.fromLatLong(37.7749, -122.4194),
            GeoPointImpl.fromLatLong(37.7749, -122.4094),
            GeoPointImpl.fromLatLong(37.7649, -122.4094),
            GeoPointImpl.fromLatLong(37.7649, -122.4194)
        ),
        strokeColor = Color.Red,
        strokeWidth = 3.dp,
        fillColor = Color.Transparent,
        extra = "Red boundary"
    )

    // Semi-transparent polygon
    Polygon(
        points = listOf(
            GeoPointImpl.fromLatLong(37.7549, -122.4194),
            GeoPointImpl.fromLatLong(37.7649, -122.4194),
            GeoPointImpl.fromLatLong(37.7649, -122.4094),
            GeoPointImpl.fromLatLong(37.7549, -122.4094),
            GeoPointImpl.fromLatLong(37.7549, -122.4194)
        ),
        strokeColor = Color.Green,
        strokeWidth = 1.dp,
        fillColor = Color.Green.copy(alpha = 0.2f),
        extra = "Green area"
    )
}
</code></pre>
<h3 id="complex-polygon-shapes"><a class="header" href="#complex-polygon-shapes">Complex Polygon Shapes</a></h3>
<pre><code class="language-kotlin">@Composable
fun ComplexPolygonExample() {
    // Star-shaped polygon
    val starPoints = remember {
        val centerLat = 37.7749
        val centerLng = -122.4194
        val outerRadius = 0.01
        val innerRadius = 0.005

        buildList {
            for (i in 0 until 10) {
                val angle = (i * 36.0) * Math.PI / 180.0
                val radius = if (i % 2 == 0) outerRadius else innerRadius
                val lat = centerLat + radius * cos(angle)
                val lng = centerLng + radius * sin(angle)
                add(GeoPointImpl.fromLatLong(lat, lng))
            }
            // Close the polygon
            add(first())
        }
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
        Polygon(
            points = starPoints,
            strokeColor = Color.Magenta,
            strokeWidth = 2.dp,
            fillColor = Color.Magenta.copy(alpha = 0.3f),
            extra = "Star polygon"
        )

        // Center marker
        Marker(
            position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
            icon = DefaultIcon(
                fillColor = Color.Magenta,
                label = "⭐"
            )
        )
    }
}
</code></pre>
<h3 id="dynamic-polygon-creation"><a class="header" href="#dynamic-polygon-creation">Dynamic Polygon Creation</a></h3>
<pre><code class="language-kotlin">@Composable
fun DynamicPolygonExample() {
    var polygonPoints by remember { mutableStateOf&lt;List&lt;GeoPoint&gt;&gt;(emptyList()) }
    var isCreating by remember { mutableStateOf(false) }

    Column {
        Row {
            Button(
                onClick = {
                    isCreating = !isCreating
                    if (!isCreating &amp;&amp; polygonPoints.isNotEmpty()) {
                        // Close the polygon
                        polygonPoints = polygonPoints + polygonPoints.first()
                    }
                }
            ) {
                Text(if (isCreating) "Finish Polygon" else "Create Polygon")
            }

            Button(
                onClick = { polygonPoints = emptyList() }
            ) {
                Text("Clear")
            }
        }

        Text("Points: ${polygonPoints.size}")

        // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(
            state = mapViewState,
            onMapClick = { geoPoint -&gt;
                if (isCreating) {
                    polygonPoints = polygonPoints + geoPoint
                }
            }
        ) {
            if (polygonPoints.size &gt;= 3) {
                val displayPoints = if (isCreating) polygonPoints
                                  else polygonPoints // Already closed

                Polygon(
                    points = displayPoints,
                    strokeColor = Color.Purple,
                    strokeWidth = 2.dp,
                    fillColor = if (isCreating)
                        Color.Purple.copy(alpha = 0.1f)
                    else
                        Color.Purple.copy(alpha = 0.3f)
                )
            }

            // Show vertex markers
            polygonPoints.forEachIndexed { index, point -&gt;
                Marker(
                    position = point,
                    icon = DefaultIcon(
                        fillColor = if (index == 0) Color.Green
                                  else if (index == polygonPoints.size - 1 &amp;&amp; !isCreating) Color.Red
                                  else Color.Blue,
                        label = "${index + 1}",
                        scale = 0.7f
                    )
                )
            }
        }
    }
}
</code></pre>
<h2 id="event-handling-4"><a class="header" href="#event-handling-4">Event Handling</a></h2>
<p>Polygon interactions are handled with your map provider component:</p>
<pre><code class="language-kotlin">// Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(
    state = mapViewState,
    onPolygonClick = { polygonEvent -&gt;
        val polygon = polygonEvent.state
        val clickPoint = polygonEvent.clicked

        println("Polygon clicked:")
        println("  Vertices: ${polygon.points.size}")
        println("  Click location: ${clickPoint}")
        println("  Extra data: ${polygon.extra}")

        // Calculate area (simplified)
        val area = calculatePolygonArea(polygon.points)
        println("  Approximate area: $area sq meters")
    }
) {
    Polygon(
        points = polygonPoints,
        strokeColor = Color.Green,
        fillColor = Color.Green.copy(alpha = 0.3f),
        extra = "Interactive polygon"
    )
}
</code></pre>
<h2 id="styling-options-2"><a class="header" href="#styling-options-2">Styling Options</a></h2>
<h3 id="fill-variations"><a class="header" href="#fill-variations">Fill Variations</a></h3>
<pre><code class="language-kotlin">// Solid fill
Polygon(
    points = points,
    fillColor = Color.Red
)

// Semi-transparent fill
Polygon(
    points = points,
    fillColor = Color.Red.copy(alpha = 0.5f)
)

// No fill (border only)
Polygon(
    points = points,
    fillColor = Color.Transparent
)

// Gradient-like effect with multiple polygons
Polygon(points = points, fillColor = Color.Blue.copy(alpha = 0.1f))
Polygon(points = smallerPoints, fillColor = Color.Blue.copy(alpha = 0.2f))
</code></pre>
<h3 id="stroke-variations"><a class="header" href="#stroke-variations">Stroke Variations</a></h3>
<pre><code class="language-kotlin">// Thin border
Polygon(
    points = points,
    strokeColor = Color.Black,
    strokeWidth = 1.dp
)

// Thick border
Polygon(
    points = points,
    strokeColor = Color.Black,
    strokeWidth = 5.dp
)

// No border
Polygon(
    points = points,
    strokeColor = Color.Transparent,
    strokeWidth = 0.dp
)
</code></pre>
<h2 id="best-practices-6"><a class="header" href="#best-practices-6">Best Practices</a></h2>
<ol>
<li><strong>Close Polygons</strong>: Always ensure the last point equals the first point to properly close the polygon</li>
<li><strong>Vertex Order</strong>: Use consistent vertex ordering (clockwise or counter-clockwise) for predictable results</li>
<li><strong>Performance</strong>: Avoid overly complex polygons with hundreds of vertices</li>
<li><strong>Visual Clarity</strong>: Use appropriate colors and transparency for good visibility</li>
<li><strong>Interactive Feedback</strong>: Provide visual feedback when polygons are clickable</li>
<li><strong>Hole Handling</strong>: Use overlapping polygons with different colors to simulate holes</li>
<li><strong>Geodesic Edges</strong>: Use geodesic edges for large polygons to account for Earth’s curvature</li>
<li><strong>State Management</strong>: Efficiently manage polygon vertex data and handle updates reactively</li>
<li><strong>Validation</strong>: Validate polygon geometry to ensure it forms a valid shape</li>
<li><strong>Error Handling</strong>: Handle edge cases like polygons with fewer than 3 vertices</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="groundimage"><a class="header" href="#groundimage">GroundImage</a></h1>
<p>Ground images are image overlays that are positioned geographically on the map. They are useful for displaying floor plans, satellite imagery, weather overlays, or any image-based data that needs to be anchored to specific geographic coordinates.</p>
<h2 id="composable-functions-4"><a class="header" href="#composable-functions-4">Composable Functions</a></h2>
<h3 id="basic-groundimage"><a class="header" href="#basic-groundimage">Basic GroundImage</a></h3>
<pre><code class="language-kotlin">@Composable
fun MapViewScope.GroundImage(
    bounds: GeoRectBounds,
    image: Drawable,
    opacity: Float = 0.5f,
    id: String? = null,
    extra: Serializable? = null
)
</code></pre>
<h3 id="groundimage-with-state"><a class="header" href="#groundimage-with-state">GroundImage with State</a></h3>
<pre><code class="language-kotlin">@Composable
fun MapViewScope.GroundImage(state: GroundImageState)
</code></pre>
<h2 id="parameters-5"><a class="header" href="#parameters-5">Parameters</a></h2>
<ul>
<li><strong><code>bounds</code></strong>: Geographic rectangular bounds where the image should be positioned (<code>GeoRectBounds</code>)</li>
<li><strong><code>image</code></strong>: The drawable image to display (<code>Drawable</code>)</li>
<li><strong><code>opacity</code></strong>: Transparency level from 0.0 (transparent) to 1.0 (opaque) (default: <code>0.5f</code>)</li>
<li><strong><code>id</code></strong>: Optional unique identifier for the ground image (<code>String?</code>)</li>
<li><strong><code>extra</code></strong>: Additional data attached to the ground image (<code>Serializable?</code>)</li>
</ul>
<h2 id="usage-examples-5"><a class="header" href="#usage-examples-5">Usage Examples</a></h2>
<h3 id="basic-groundimage-1"><a class="header" href="#basic-groundimage-1">Basic GroundImage</a></h3>
<pre><code class="language-kotlin">@Composable
fun BasicGroundImageExample() {
    val context = LocalContext.current

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
        AppCompatResources.getDrawable(context, R.drawable.overlay_image)?.let { drawable -&gt;
            GroundImage(
                bounds = GeoRectBounds(
                    southwest = GeoPointImpl.fromLatLong(37.7649, -122.4294),
                    northeast = GeoPointImpl.fromLatLong(37.7849, -122.4094)
                ),
                image = drawable,
                opacity = 0.7f
            )
        }
    }
}
</code></pre>
<h3 id="interactive-groundimage-with-bounds-markers"><a class="header" href="#interactive-groundimage-with-bounds-markers">Interactive GroundImage with Bounds Markers</a></h3>
<p>Based on the example app pattern:</p>
<pre><code class="language-kotlin">@Composable
fun InteractiveGroundImageExample() {
    var southwest by remember {
        mutableStateOf(GeoPointImpl.fromLatLong(37.7649, -122.4294))
    }
    var northeast by remember {
        mutableStateOf(GeoPointImpl.fromLatLong(37.7849, -122.4094))
    }
    var opacity by remember { mutableStateOf(0.7f) }

    val context = LocalContext.current
    val groundImageDrawable = AppCompatResources.getDrawable(context, R.drawable.map_overlay)

    val bounds = GeoRectBounds(southwest = southwest, northeast = northeast)

    val groundImageState = groundImageDrawable?.let { drawable -&gt;
        GroundImageState(
            bounds = bounds,
            image = drawable,
            opacity = opacity
        )
    }

    // Bounds markers
    val swMarker = MarkerState(
        position = southwest,
        icon = DefaultIcon(
            fillColor = Color.Green,
            label = "SW",
            scale = 0.8f
        ),
        draggable = true,
        extra = "southwest"
    )

    val neMarker = MarkerState(
        position = northeast,
        icon = DefaultIcon(
            fillColor = Color.Red,
            label = "NE",
            scale = 0.8f
        ),
        draggable = true,
        extra = "northeast"
    )

    Column {
        // Opacity control
        Slider(
            value = opacity,
            onValueChange = { opacity = it },
            valueRange = 0f..1f,
            modifier = Modifier.padding(16.dp)
        )
        Text("Opacity: ${(opacity * 100).toInt()}%", modifier = Modifier.padding(horizontal = 16.dp))

        // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(
            state = mapViewState,
            onMarkerDrag = { markerState -&gt;
                when (markerState.extra as String) {
                    "southwest" -&gt; southwest = markerState.position
                    "northeast" -&gt; northeast = markerState.position
                }
            },
            onGroundImageClick = { groundImageEvent -&gt;
                println("Ground image clicked at: ${groundImageEvent.clicked}")
            }
        ) {
            // Draw ground image
            groundImageState?.let { state -&gt;
                GroundImage(state)
            }

            // Draw corner markers
            Marker(swMarker)
            Marker(neMarker)

            // Draw bounds rectangle for reference
            val boundsPoints = listOf(
                southwest,
                GeoPointImpl.fromLatLong(southwest.latitude, northeast.longitude),
                northeast,
                GeoPointImpl.fromLatLong(northeast.latitude, southwest.longitude),
                southwest
            )

            Polyline(
                points = boundsPoints,
                strokeColor = Color.Blue,
                strokeWidth = 2.dp
            )
        }
    }
}
</code></pre>
<h3 id="multiple-groundimages-with-different-opacities"><a class="header" href="#multiple-groundimages-with-different-opacities">Multiple GroundImages with Different Opacities</a></h3>
<pre><code class="language-kotlin">@Composable
fun MultipleGroundImagesExample() {
    val context = LocalContext.current

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
        // Base satellite image (low opacity)
        AppCompatResources.getDrawable(context, R.drawable.satellite_base)?.let { drawable -&gt;
            GroundImage(
                bounds = GeoRectBounds(
                    southwest = GeoPointImpl.fromLatLong(37.7549, -122.4394),
                    northeast = GeoPointImpl.fromLatLong(37.7949, -122.3994)
                ),
                image = drawable,
                opacity = 0.3f,
                extra = "Satellite base"
            )
        }

        // Weather overlay (medium opacity)
        AppCompatResources.getDrawable(context, R.drawable.weather_overlay)?.let { drawable -&gt;
            GroundImage(
                bounds = GeoRectBounds(
                    southwest = GeoPointImpl.fromLatLong(37.7649, -122.4294),
                    northeast = GeoPointImpl.fromLatLong(37.7849, -122.4094)
                ),
                image = drawable,
                opacity = 0.6f,
                extra = "Weather data"
            )
        }

        // Traffic overlay (high opacity)
        AppCompatResources.getDrawable(context, R.drawable.traffic_overlay)?.let { drawable -&gt;
            GroundImage(
                bounds = GeoRectBounds(
                    southwest = GeoPointImpl.fromLatLong(37.7699, -122.4244),
                    northeast = GeoPointImpl.fromLatLong(37.7799, -122.4144)
                ),
                image = drawable,
                opacity = 0.8f,
                extra = "Traffic data"
            )
        }
    }
}
</code></pre>
<h3 id="dynamic-groundimage-loading"><a class="header" href="#dynamic-groundimage-loading">Dynamic GroundImage Loading</a></h3>
<pre><code class="language-kotlin">@Composable
fun DynamicGroundImageExample() {
    var selectedImageResource by remember { mutableStateOf(R.drawable.overlay1) }
    var isVisible by remember { mutableStateOf(true) }

    val context = LocalContext.current
    val imageDrawable = AppCompatResources.getDrawable(context, selectedImageResource)

    val bounds = GeoRectBounds(
        southwest = GeoPointImpl.fromLatLong(37.7649, -122.4294),
        northeast = GeoPointImpl.fromLatLong(37.7849, -122.4094)
    )

    Column {
        Row {
            Button(onClick = { selectedImageResource = R.drawable.overlay1 }) {
                Text("Image 1")
            }
            Button(onClick = { selectedImageResource = R.drawable.overlay2 }) {
                Text("Image 2")
            }
            Button(onClick = { selectedImageResource = R.drawable.overlay3 }) {
                Text("Image 3")
            }
        }

        Switch(
            checked = isVisible,
            onCheckedChange = { isVisible = it },
            modifier = Modifier.padding(16.dp)
        )

        // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
            if (isVisible &amp;&amp; imageDrawable != null) {
                GroundImage(
                    bounds = bounds,
                    image = imageDrawable,
                    opacity = 0.7f,
                    extra = "Dynamic overlay"
                )
            }

            // Reference markers at corners
            Marker(
                position = bounds.southwest,
                icon = DefaultIcon(fillColor = Color.Green, label = "SW", scale = 0.6f)
            )
            Marker(
                position = bounds.northeast,
                icon = DefaultIcon(fillColor = Color.Red, label = "NE", scale = 0.6f)
            )
        }
    }
}
</code></pre>
<h3 id="animated-groundimage-opacity"><a class="header" href="#animated-groundimage-opacity">Animated GroundImage Opacity</a></h3>
<pre><code class="language-kotlin">@Composable
fun AnimatedGroundImageExample() {
    var isAnimating by remember { mutableStateOf(false) }
    var opacity by remember { mutableStateOf(0.5f) }

    LaunchedEffect(isAnimating) {
        if (isAnimating) {
            while (isAnimating) {
                delay(50)
                opacity = (sin(System.currentTimeMillis() / 1000.0).toFloat() + 1f) / 2f
            }
        }
    }

    val context = LocalContext.current

    Column {
        Button(
            onClick = { isAnimating = !isAnimating }
        ) {
            Text(if (isAnimating) "Stop Animation" else "Start Animation")
        }

        Text("Current opacity: ${(opacity * 100).toInt()}%")

        // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
            AppCompatResources.getDrawable(context, R.drawable.animated_overlay)?.let { drawable -&gt;
                GroundImage(
                    bounds = GeoRectBounds(
                        southwest = GeoPointImpl.fromLatLong(37.7649, -122.4294),
                        northeast = GeoPointImpl.fromLatLong(37.7849, -122.4094)
                    ),
                    image = drawable,
                    opacity = opacity,
                    extra = "Animated overlay"
                )
            }
        }
    }
}
</code></pre>
<h3 id="floor-plan-overlay"><a class="header" href="#floor-plan-overlay">Floor Plan Overlay</a></h3>
<pre><code class="language-kotlin">@Composable
fun FloorPlanExample() {
    val context = LocalContext.current

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
        // Building floor plan
        AppCompatResources.getDrawable(context, R.drawable.building_floor_plan)?.let { drawable -&gt;
            GroundImage(
                bounds = GeoRectBounds(
                    southwest = GeoPointImpl.fromLatLong(37.7749, -122.4194),
                    northeast = GeoPointImpl.fromLatLong(37.7759, -122.4184)
                ),
                image = drawable,
                opacity = 0.8f,
                extra = "Building floor plan"
            )
        }

        // Room markers
        Marker(
            position = GeoPointImpl.fromLatLong(37.7751, -122.4191),
            icon = DefaultIcon(fillColor = Color.Blue, label = "A", scale = 0.6f),
            extra = "Room A"
        )

        Marker(
            position = GeoPointImpl.fromLatLong(37.7754, -122.4189),
            icon = DefaultIcon(fillColor = Color.Red, label = "B", scale = 0.6f),
            extra = "Room B"
        )

        Marker(
            position = GeoPointImpl.fromLatLong(37.7756, -122.4187),
            icon = DefaultIcon(fillColor = Color.Green, label = "C", scale = 0.6f),
            extra = "Room C"
        )
    }
}
</code></pre>
<h2 id="event-handling-5"><a class="header" href="#event-handling-5">Event Handling</a></h2>
<p>GroundImage interactions are handled with your map provider component:</p>
<pre><code class="language-kotlin">// Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(
    state = mapViewState,
    onGroundImageClick = { groundImageEvent -&gt;
        val groundImage = groundImageEvent.state
        val clickPoint = groundImageEvent.clicked

        println("Ground image clicked:")
        println("  Bounds: ${groundImage.bounds}")
        println("  Opacity: ${groundImage.opacity}")
        println("  Click location: ${clickPoint}")
        println("  Extra data: ${groundImage.extra}")
    }
) {
    GroundImage(
        bounds = bounds,
        image = drawable,
        opacity = 0.7f,
        extra = "Interactive overlay"
    )
}
</code></pre>
<h2 id="image-resources"><a class="header" href="#image-resources">Image Resources</a></h2>
<h3 id="loading-from-resources"><a class="header" href="#loading-from-resources">Loading from Resources</a></h3>
<pre><code class="language-kotlin">val context = LocalContext.current
val drawable = AppCompatResources.getDrawable(context, R.drawable.overlay_image)
</code></pre>
<h3 id="loading-from-assets"><a class="header" href="#loading-from-assets">Loading from Assets</a></h3>
<pre><code class="language-kotlin">val context = LocalContext.current
val inputStream = context.assets.open("overlays/map_overlay.png")
val drawable = Drawable.createFromStream(inputStream, null)
</code></pre>
<h3 id="loading-from-network-with-caching"><a class="header" href="#loading-from-network-with-caching">Loading from Network (with caching)</a></h3>
<pre><code class="language-kotlin">// Using a library like Coil or Glide
val imageLoader = ImageLoader(context)
val request = ImageRequest.Builder(context)
    .data("https://example.com/overlay.png")
    .build()

LaunchedEffect(request) {
    val drawable = imageLoader.execute(request).drawable
    // Use drawable with GroundImage
}
</code></pre>
<h2 id="best-practices-7"><a class="header" href="#best-practices-7">Best Practices</a></h2>
<ol>
<li><strong>Image Size</strong>: Use appropriately sized images to balance quality and performance</li>
<li><strong>Opacity</strong>: Use transparency to blend overlays naturally with the map</li>
<li><strong>Bounds Accuracy</strong>: Ensure ground image bounds are precisely aligned with geographic features</li>
<li><strong>Resource Management</strong>: Optimize image resources and consider memory usage</li>
<li><strong>Layer Order</strong>: Consider the drawing order when overlapping multiple ground images</li>
<li><strong>Interactive Elements</strong>: Provide clear visual feedback for interactive ground images</li>
<li><strong>Caching</strong>: Cache image resources efficiently, especially for network-loaded images</li>
<li><strong>Error Handling</strong>: Handle cases where images fail to load</li>
<li><strong>Performance</strong>: Avoid rendering too many large ground images simultaneously</li>
<li><strong>User Experience</strong>: Provide controls for opacity and visibility when appropriate</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mapviewstate"><a class="header" href="#mapviewstate">MapViewState</a></h1>
<p><code>MapViewState</code> is the core component that manages map initialization, camera position, and overall map state. Each map provider has its own implementation while maintaining a consistent interface.</p>
<h2 id="provider-implementations"><a class="header" href="#provider-implementations">Provider Implementations</a></h2>
<p>MapConductor supports four map providers, each with their own <code>MapViewState</code> implementation:</p>
<ul>
<li><code>GoogleMapViewStateImpl</code> - Google Maps</li>
<li><code>MapboxViewStateImpl</code> - Mapbox Maps</li>
<li><code>HereViewStateImpl</code> - HERE Maps</li>
<li><code>ArcGISMapViewStateImpl</code> - ArcGIS Maps</li>
</ul>
<h2 id="core-properties"><a class="header" href="#core-properties">Core Properties</a></h2>
<h3 id="initialization-state"><a class="header" href="#initialization-state">Initialization State</a></h3>
<ul>
<li><strong><code>isInitialized: StateFlow&lt;InitState&gt;</code></strong>: Tracks the map initialization status
<ul>
<li><code>NotStarted</code>: Map initialization has not begun</li>
<li><code>Initializing</code>: Map is currently being initialized</li>
<li><code>Initialized</code>: Map is ready to use</li>
<li><code>Failed</code>: Initialization failed</li>
</ul>
</li>
</ul>
<h3 id="camera-management"><a class="header" href="#camera-management">Camera Management</a></h3>
<ul>
<li><strong><code>cameraPosition: StateFlow&lt;MapCameraPositionImpl?&gt;</code></strong>: Current camera position</li>
<li><strong><code>initCameraPosition: MapCameraPositionImpl</code></strong>: Initial camera position when map loads</li>
</ul>
<h3 id="map-design"><a class="header" href="#map-design">Map Design</a></h3>
<ul>
<li><strong><code>mapDesignType: ActualMapDesignType</code></strong>: Map style/design (provider-specific)</li>
</ul>
<h2 id="core-methods"><a class="header" href="#core-methods">Core Methods</a></h2>
<h3 id="initialization"><a class="header" href="#initialization">Initialization</a></h3>
<pre><code class="language-kotlin">fun initAsync(init: suspend () -&gt; Boolean)
</code></pre>
<p>Initializes the map asynchronously. Returns <code>true</code> if successful.</p>
<pre><code class="language-kotlin">fun resetInitState()
</code></pre>
<p>Resets the initialization state to <code>NotStarted</code>.</p>
<h3 id="camera-movement"><a class="header" href="#camera-movement">Camera Movement</a></h3>
<pre><code class="language-kotlin">fun moveCameraTo(
    cameraPosition: MapCameraPositionImpl,
    durationMs: Long? = 0,
    listener: MoveCameraCallback? = null
)
</code></pre>
<p>Moves the camera to a specific position with optional animation.</p>
<pre><code class="language-kotlin">fun moveCameraTo(
    position: GeoPointImpl,
    durationMs: Long? = 0,
    listener: MoveCameraCallback? = null
)
</code></pre>
<p>Moves the camera to focus on a specific geographic point.</p>
<h2 id="usage-example"><a class="header" href="#usage-example">Usage Example</a></h2>
<h3 id="basic-setup"><a class="header" href="#basic-setup">Basic Setup</a></h3>
<pre><code class="language-kotlin">@Composable
fun MapExample() {
    // Create map state (choose your provider)
    val mapViewState = rememberGoogleMapViewState()

    // Monitor initialization state
    val initState by mapViewState.isInitialized.collectAsState()

    when (initState) {
        InitState.NotStarted -&gt; Text("Map not started")
        InitState.Initializing -&gt; CircularProgressIndicator()
        InitState.Initialized -&gt; {
            // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
                // Add map content here
            }
        }
        InitState.Failed -&gt; Text("Map failed to load")
    }
}
</code></pre>
<h3 id="camera-control"><a class="header" href="#camera-control">Camera Control</a></h3>
<pre><code class="language-kotlin">@Composable
fun CameraControlExample() {
    val mapViewState = rememberGoogleMapViewState()

    Column {
        Button(
            onClick = {
                val sanFrancisco = GeoPointImpl.fromLatLong(37.7749, -122.4194)
                mapViewState.moveCameraTo(
                    position = sanFrancisco,
                    durationMs = 1000,
                    listener = object : MapViewState.MoveCameraCallback {
                        override fun onComplete() {
                            println("Camera movement completed")
                        }
                    }
                )
            }
        ) {
            Text("Move to San Francisco")
        }

        // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
            // Map content
        }
    }
}
</code></pre>
<h3 id="provider-switching"><a class="header" href="#provider-switching">Provider Switching</a></h3>
<pre><code class="language-kotlin">@Composable
fun ProviderSwitchExample() {
    var selectedProvider by remember { mutableStateOf("google") }

    val mapViewState = remember(selectedProvider) {
        when (selectedProvider) {
            "google" -&gt; GoogleMapViewStateImpl()
            "mapbox" -&gt; MapboxViewStateImpl()
            "here" -&gt; HereViewStateImpl()
            "arcgis" -&gt; ArcGISMapViewStateImpl()
            else -&gt; GoogleMapViewStateImpl()
        }
    }

    Column {
        Row {
            Button(onClick = { selectedProvider = "google" }) {
                Text("Google Maps")
            }
            Button(onClick = { selectedProvider = "mapbox" }) {
                Text("Mapbox")
            }
            Button(onClick = { selectedProvider = "here" }) {
                Text("HERE")
            }
            Button(onClick = { selectedProvider = "arcgis" }) {
                Text("ArcGIS")
            }
        }

        // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
            Marker(
                position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
                icon = DefaultIcon(label = selectedProvider)
            )
        }
    }
}
</code></pre>
<h2 id="event-handling-6"><a class="header" href="#event-handling-6">Event Handling</a></h2>
<p>The <code>MapViewState</code> works with your chosen map provider component to provide comprehensive event handling:</p>
<pre><code class="language-kotlin">// Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(
    state = mapViewState,
    onMapViewInitialized = {
        println("Map view initialized")
    },
    onMapLoaded = {
        println("Map loaded successfully")
    },
    onMapClick = { geoPoint -&gt;
        println("Map clicked at: ${geoPoint.latitude}, ${geoPoint.longitude}")
    }
) {
    // Map content
}
</code></pre>
<h2 id="best-practices-8"><a class="header" href="#best-practices-8">Best Practices</a></h2>
<ol>
<li><strong>Remember State</strong>: Always use <code>remember</code> to maintain state across recompositions</li>
<li><strong>Monitor Initialization</strong>: Check initialization state before adding content</li>
<li><strong>Handle Failures</strong>: Provide fallback UI for initialization failures</li>
<li><strong>Provider Abstraction</strong>: Write code that works with any provider implementation</li>
<li><strong>Resource Management</strong>: Allow the SDK to handle lifecycle management automatically</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="markerstate"><a class="header" href="#markerstate">MarkerState</a></h1>
<p><code>MarkerState</code> manages the configuration and behavior of markers on the map. It provides reactive properties that automatically update the marker’s appearance and position when modified.</p>
<h2 id="constructor"><a class="header" href="#constructor">Constructor</a></h2>
<pre><code class="language-kotlin">MarkerState(
    position: GeoPoint,
    id: String? = null,
    extra: Serializable? = null,
    icon: MarkerIcon? = null,
    animation: MarkerAnimation? = null,
    clickable: Boolean = true,
    draggable: Boolean = false
)
</code></pre>
<h2 id="properties"><a class="header" href="#properties">Properties</a></h2>
<h3 id="core-properties-1"><a class="header" href="#core-properties-1">Core Properties</a></h3>
<ul>
<li><strong><code>id: String</code></strong>: Unique identifier for the marker (auto-generated if not provided)</li>
<li><strong><code>position: GeoPoint</code></strong>: Current geographic position of the marker</li>
<li><strong><code>extra: Serializable?</code></strong>: Additional data attached to the marker</li>
</ul>
<h3 id="visual-properties"><a class="header" href="#visual-properties">Visual Properties</a></h3>
<ul>
<li><strong><code>icon: MarkerIcon?</code></strong>: Custom icon for the marker (uses default if null)</li>
<li><strong><code>clickable: Boolean</code></strong>: Whether the marker responds to click events</li>
<li><strong><code>draggable: Boolean</code></strong>: Whether the marker can be dragged by the user</li>
</ul>
<h3 id="interactive-properties"><a class="header" href="#interactive-properties">Interactive Properties</a></h3>
<ul>
<li><strong><code>isDragging: Boolean</code></strong> (read-only): Current dragging state</li>
<li><strong><code>internalPosition: GeoPoint</code></strong> (read-only): Position used for rendering (accounts for drag state)</li>
</ul>
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<h3 id="animation"><a class="header" href="#animation">Animation</a></h3>
<pre><code class="language-kotlin">fun setAnimation(animation: MarkerAnimation?)
</code></pre>
<p>Sets or clears the marker animation.</p>
<pre><code class="language-kotlin">internal fun getAnimation(): MarkerAnimation?
</code></pre>
<p>Gets the current animation (internal use).</p>
<h3 id="state-management"><a class="header" href="#state-management">State Management</a></h3>
<pre><code class="language-kotlin">fun copy(
    id: String? = this.id,
    position: GeoPoint = this.position,
    extra: Serializable? = this.extra,
    icon: MarkerIcon? = this.icon,
    clickable: Boolean? = this.clickable,
    draggable: Boolean? = this.draggable
): MarkerState
</code></pre>
<p>Creates a copy of the marker state with modified properties.</p>
<h3 id="reactive-updates"><a class="header" href="#reactive-updates">Reactive Updates</a></h3>
<pre><code class="language-kotlin">fun asFlow(): Flow&lt;MarkerFingerPrint&gt;
</code></pre>
<p>Returns a flow that emits when the marker state changes.</p>
<pre><code class="language-kotlin">fun fingerPrint(): MarkerFingerPrint
</code></pre>
<p>Creates a fingerprint for efficient change detection.</p>
<h2 id="usage-examples-6"><a class="header" href="#usage-examples-6">Usage Examples</a></h2>
<h3 id="basic-markerstate"><a class="header" href="#basic-markerstate">Basic MarkerState</a></h3>
<pre><code class="language-kotlin">val markerState = MarkerState(
    position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
    extra = "San Francisco marker"
)

// Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
    Marker(markerState)
}
</code></pre>
<h3 id="customized-markerstate"><a class="header" href="#customized-markerstate">Customized MarkerState</a></h3>
<pre><code class="language-kotlin">val customMarkerState = MarkerState(
    position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
    icon = DefaultIcon(
        fillColor = Color.Blue,
        label = "SF",
        scale = 1.2f
    ),
    clickable = true,
    draggable = true,
    extra = "Draggable San Francisco marker"
)

// Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(
    state = mapViewState,
    onMarkerClick = { markerState -&gt;
        println("Clicked marker: ${markerState.extra}")
    },
    onMarkerDrag = { markerState -&gt;
        println("Marker dragged to: ${markerState.position}")
    }
) {
    Marker(customMarkerState)
}
</code></pre>
<h3 id="dynamic-markerstate-updates"><a class="header" href="#dynamic-markerstate-updates">Dynamic MarkerState Updates</a></h3>
<pre><code class="language-kotlin">@Composable
fun DynamicMarkerExample() {
    var markerState by remember {
        mutableStateOf(
            MarkerState(
                position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
                icon = DefaultIcon(fillColor = Color.Red, label = "1"),
                extra = "Counter: 1"
            )
        )
    }

    var counter by remember { mutableStateOf(1) }

    Column {
        Button(
            onClick = {
                counter++
                markerState = markerState.copy(
                    icon = DefaultIcon(
                        fillColor = Color.Blue,
                        label = counter.toString()
                    ),
                    extra = "Counter: $counter"
                )
            }
        ) {
            Text("Update Marker ($counter)")
        }

        // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
            Marker(markerState)
        }
    }
}
</code></pre>
<h3 id="markerstate-with-position-animation"><a class="header" href="#markerstate-with-position-animation">MarkerState with Position Animation</a></h3>
<pre><code class="language-kotlin">@Composable
fun AnimatedMarkerExample() {
    val startPosition = GeoPointImpl.fromLatLong(37.7749, -122.4194)
    val endPosition = GeoPointImpl.fromLatLong(37.7849, -122.4094)

    var markerState by remember {
        mutableStateOf(
            MarkerState(
                position = startPosition,
                icon = DefaultIcon(fillColor = Color.Green, label = "Moving"),
                extra = "Animated marker"
            )
        )
    }

    LaunchedEffect(Unit) {
        while (true) {
            delay(2000)
            markerState = markerState.copy(
                position = if (markerState.position == startPosition) endPosition else startPosition
            )
        }
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
        Marker(markerState)
    }
}
</code></pre>
<h3 id="markerstate-with-drag-handling"><a class="header" href="#markerstate-with-drag-handling">MarkerState with Drag Handling</a></h3>
<pre><code class="language-kotlin">@Composable
fun DraggableMarkerExample() {
    var markerState by remember {
        mutableStateOf(
            MarkerState(
                position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
                icon = DefaultIcon(
                    fillColor = Color.Purple,
                    label = "Drag",
                    scale = 1.2f
                ),
                draggable = true,
                extra = "Draggable marker"
            )
        )
    }

    Column {
        Text("Marker Position:")
        Text("Lat: ${markerState.position.latitude}")
        Text("Lng: ${markerState.position.longitude}")
        Text("Is Dragging: ${markerState.isDragging}")

        // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(
            state = mapViewState,
            onMarkerDragStart = { draggedMarker -&gt;
                println("Drag started: ${draggedMarker.id}")
            },
            onMarkerDrag = { draggedMarker -&gt;
                if (draggedMarker.id == markerState.id) {
                    markerState = markerState.copy(position = draggedMarker.position)
                }
            },
            onMarkerDragEnd = { draggedMarker -&gt;
                println("Drag ended: ${draggedMarker.id}")
            }
        ) {
            Marker(markerState)
        }
    }
}
</code></pre>
<h3 id="multiple-markerstates-with-different-behaviors"><a class="header" href="#multiple-markerstates-with-different-behaviors">Multiple MarkerStates with Different Behaviors</a></h3>
<pre><code class="language-kotlin">@Composable
fun MultipleMarkersExample() {
    val markerStates = remember {
        listOf(
            MarkerState(
                position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
                icon = DefaultIcon(fillColor = Color.Red, label = "Static"),
                clickable = true,
                draggable = false,
                extra = "Static marker"
            ),
            MarkerState(
                position = GeoPointImpl.fromLatLong(37.7849, -122.4094),
                icon = DefaultIcon(fillColor = Color.Green, label = "Drag"),
                clickable = true,
                draggable = true,
                extra = "Draggable marker"
            ),
            MarkerState(
                position = GeoPointImpl.fromLatLong(37.7649, -122.4294),
                icon = DefaultIcon(fillColor = Color.Blue, label = "Info"),
                clickable = true,
                draggable = false,
                extra = "Information marker with long description"
            )
        )
    }

    var selectedMarker by remember { mutableStateOf&lt;MarkerState?&gt;(null) }

    Column {
        selectedMarker?.let { marker -&gt;
            Card(modifier = Modifier.padding(8.dp)) {
                Column(modifier = Modifier.padding(16.dp)) {
                    Text("Selected: ${marker.extra}")
                    Text("Position: ${marker.position.latitude}, ${marker.position.longitude}")
                    Text("Draggable: ${marker.draggable}")
                }
            }
        }

        // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(
            state = mapViewState,
            onMarkerClick = { clickedMarker -&gt;
                selectedMarker = clickedMarker
            },
            onMapClick = {
                selectedMarker = null
            }
        ) {
            markerStates.forEach { markerState -&gt;
                Marker(markerState)
            }
        }
    }
}
</code></pre>
<h3 id="markerstate-with-custom-icons"><a class="header" href="#markerstate-with-custom-icons">MarkerState with Custom Icons</a></h3>
<pre><code class="language-kotlin">@Composable
fun CustomIconMarkerExample() {
    val context = LocalContext.current

    val markerStates = remember {
        listOf(
            MarkerState(
                position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
                icon = DefaultIcon(
                    scale = 1.5f,
                    fillColor = Color.Red,
                    strokeColor = Color.White,
                    strokeWidth = 2.dp,
                    label = "XL"
                ),
                extra = "Large default icon"
            ),
            MarkerState(
                position = GeoPointImpl.fromLatLong(37.7849, -122.4094),
                icon = AppCompatResources.getDrawable(context, R.drawable.custom_pin)?.let { drawable -&gt;
                    DrawableDefaultIcon(
                        backgroundDrawable = drawable,
                        scale = 1.2f
                    )
                },
                extra = "Custom drawable icon"
            ),
            MarkerState(
                position = GeoPointImpl.fromLatLong(37.7649, -122.4294),
                icon = AppCompatResources.getDrawable(context, R.drawable.weather_icon)?.let { drawable -&gt;
                    ImageIcon(
                        drawable = drawable,
                        anchor = Offset(0.5f, 1.0f)
                    )
                },
                extra = "Weather image icon"
            )
        )
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
        markerStates.forEach { markerState -&gt;
            Marker(markerState)
        }
    }
}
</code></pre>
<h2 id="state-observation"><a class="header" href="#state-observation">State Observation</a></h2>
<h3 id="observing-markerstate-changes"><a class="header" href="#observing-markerstate-changes">Observing MarkerState Changes</a></h3>
<pre><code class="language-kotlin">@Composable
fun MarkerStateObserver() {
    val markerState = remember {
        MarkerState(
            position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
            extra = "Observed marker"
        )
    }

    // Observe state changes
    val markerFingerprint by markerState.asFlow().collectAsState(
        initial = markerState.fingerPrint()
    )

    LaunchedEffect(markerFingerprint) {
        println("Marker state changed: $markerFingerprint")
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
        Marker(markerState)
    }
}
</code></pre>
<h2 id="performance-considerations-1"><a class="header" href="#performance-considerations-1">Performance Considerations</a></h2>
<h3 id="efficient-state-updates"><a class="header" href="#efficient-state-updates">Efficient State Updates</a></h3>
<pre><code class="language-kotlin">// Good: Update properties directly
markerState.position = newPosition
markerState.icon = newIcon

// Good: Use copy for multiple changes
val updatedState = markerState.copy(
    position = newPosition,
    icon = newIcon,
    extra = newExtra
)

// Avoid: Creating new states unnecessarily
// This creates a new state object each time
val newState = MarkerState(position = newPosition, icon = newIcon)
</code></pre>
<h3 id="memory-management-1"><a class="header" href="#memory-management-1">Memory Management</a></h3>
<pre><code class="language-kotlin">// Store marker states efficiently
val markerStates = remember { mutableStateMapOf&lt;String, MarkerState&gt;() }

// Add marker
markerStates[markerId] = MarkerState(...)

// Update marker
markerStates[markerId]?.let { state -&gt;
    state.position = newPosition
}

// Remove marker
markerStates.remove(markerId)
</code></pre>
<h2 id="best-practices-9"><a class="header" href="#best-practices-9">Best Practices</a></h2>
<ol>
<li><strong>Use Meaningful IDs</strong>: Provide custom IDs for markers you need to reference later</li>
<li><strong>Store Useful Data</strong>: Use the <code>extra</code> property to store data needed for event handling</li>
<li><strong>Reactive Updates</strong>: Leverage Compose’s reactive system - modify properties directly rather than recreating states</li>
<li><strong>Performance</strong>: Use <code>copy()</code> when updating multiple properties simultaneously</li>
<li><strong>Memory</strong>: Clean up marker states that are no longer needed</li>
<li><strong>Consistency</strong>: Maintain consistent icon styling across similar marker types</li>
<li><strong>User Feedback</strong>: Provide appropriate visual feedback for interactive markers</li>
<li><strong>Validation</strong>: Ensure position coordinates are valid before creating marker states</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="circlestate"><a class="header" href="#circlestate">CircleState</a></h1>
<p><code>CircleState</code> manages the configuration and behavior of circular overlays on the map. It provides reactive properties for center position, radius, styling, and interaction settings.</p>
<h2 id="constructor-1"><a class="header" href="#constructor-1">Constructor</a></h2>
<pre><code class="language-kotlin">CircleState(
    center: GeoPoint,
    radiusMeters: Double,
    clickable: Boolean = true,
    strokeColor: Color = Color.Red,
    strokeWidth: Dp = 1.dp,
    fillColor: Color = Color(red = 255, green = 255, blue = 255, alpha = 127),
    id: String? = null,
    zIndex: Int? = null,
    extra: Serializable? = null
)
</code></pre>
<h2 id="properties-1"><a class="header" href="#properties-1">Properties</a></h2>
<h3 id="core-properties-2"><a class="header" href="#core-properties-2">Core Properties</a></h3>
<ul>
<li><strong><code>id: String</code></strong>: Unique identifier (auto-generated if not provided)</li>
<li><strong><code>center: GeoPoint</code></strong>: Geographic center of the circle</li>
<li><strong><code>radiusMeters: Double</code></strong>: Radius in meters</li>
<li><strong><code>clickable: Boolean</code></strong>: Whether the circle responds to click events</li>
<li><strong><code>extra: Serializable?</code></strong>: Additional data attached to the circle</li>
</ul>
<h3 id="visual-properties-1"><a class="header" href="#visual-properties-1">Visual Properties</a></h3>
<ul>
<li><strong><code>strokeColor: Color</code></strong>: Border color</li>
<li><strong><code>strokeWidth: Dp</code></strong>: Border width</li>
<li><strong><code>fillColor: Color</code></strong>: Interior fill color</li>
<li><strong><code>zIndex: Int?</code></strong>: Drawing order (higher values drawn on top)</li>
</ul>
<h2 id="methods-1"><a class="header" href="#methods-1">Methods</a></h2>
<pre><code class="language-kotlin">fun copy(...): CircleState // Create a modified copy
fun fingerPrint(): CircleFingerPrint // Change detection
fun asFlow(): Flow&lt;CircleFingerPrint&gt; // Reactive updates
</code></pre>
<h2 id="usage-examples-7"><a class="header" href="#usage-examples-7">Usage Examples</a></h2>
<h3 id="basic-circle-2"><a class="header" href="#basic-circle-2">Basic Circle</a></h3>
<pre><code class="language-kotlin">val circleState = CircleState(
    center = GeoPointImpl.fromLatLong(37.7749, -122.4194),
    radiusMeters = 1000.0,
    strokeColor = Color.Blue,
    fillColor = Color.Blue.copy(alpha = 0.3f)
)

// Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
    Circle(circleState)
}
</code></pre>
<h3 id="interactive-circle"><a class="header" href="#interactive-circle">Interactive Circle</a></h3>
<pre><code class="language-kotlin">@Composable
fun InteractiveCircleExample() {
    var circleState by remember {
        mutableStateOf(
            CircleState(
                center = GeoPointImpl.fromLatLong(37.7749, -122.4194),
                radiusMeters = 500.0,
                strokeColor = Color.Red,
                fillColor = Color.Red.copy(alpha = 0.2f),
                clickable = true
            )
        )
    }

    Column {
        Slider(
            value = circleState.radiusMeters.toFloat(),
            onValueChange = {
                circleState = circleState.copy(radiusMeters = it.toDouble())
            },
            valueRange = 100f..2000f
        )

        // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(
            state = mapViewState,
            onCircleClick = { event -&gt;
                println("Circle clicked at: ${event.clicked}")
            }
        ) {
            Circle(circleState)
        }
    }
}
</code></pre>
<h3 id="multiple-circles-with-z-index"><a class="header" href="#multiple-circles-with-z-index">Multiple Circles with Z-Index</a></h3>
<pre><code class="language-kotlin">val circles = listOf(
    CircleState(
        center = GeoPointImpl.fromLatLong(37.7749, -122.4194),
        radiusMeters = 1000.0,
        fillColor = Color.Red.copy(alpha = 0.3f),
        zIndex = 1
    ),
    CircleState(
        center = GeoPointImpl.fromLatLong(37.7749, -122.4194),
        radiusMeters = 500.0,
        fillColor = Color.Blue.copy(alpha = 0.5f),
        zIndex = 2
    )
)

// Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
    circles.forEach { circleState -&gt;
        Circle(circleState)
    }
}
</code></pre>
<h2 id="event-handling-7"><a class="header" href="#event-handling-7">Event Handling</a></h2>
<p>Circle events provide both the state and click location:</p>
<pre><code class="language-kotlin">data class CircleEvent(
    val state: CircleState,
    val clicked: GeoPoint
)

typealias OnCircleEventHandler = (CircleEvent) -&gt; Unit
</code></pre>
<h2 id="best-practices-10"><a class="header" href="#best-practices-10">Best Practices</a></h2>
<ol>
<li><strong>Radius Units</strong>: Always specify radius in meters for consistency</li>
<li><strong>Color Alpha</strong>: Use alpha transparency for better map visibility</li>
<li><strong>Z-Index</strong>: Use z-index to control overlapping circles</li>
<li><strong>Performance</strong>: Avoid creating too many large circles</li>
<li><strong>Reactivity</strong>: Update properties directly for efficient re-rendering</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polylinestate"><a class="header" href="#polylinestate">PolylineState</a></h1>
<p><code>PolylineState</code> manages the configuration and behavior of polylines (line segments) on the map. It provides reactive properties for points, styling, and geodesic options.</p>
<h2 id="constructor-2"><a class="header" href="#constructor-2">Constructor</a></h2>
<pre><code class="language-kotlin">PolylineState(
    points: List&lt;GeoPoint&gt;,
    id: String? = null,
    strokeColor: Color = Color.Black,
    strokeWidth: Dp = 1.dp,
    geodesic: Boolean = false,
    extra: Serializable? = null
)
</code></pre>
<h2 id="properties-2"><a class="header" href="#properties-2">Properties</a></h2>
<h3 id="core-properties-3"><a class="header" href="#core-properties-3">Core Properties</a></h3>
<ul>
<li><strong><code>id: String</code></strong>: Unique identifier (auto-generated if not provided)</li>
<li><strong><code>points: List&lt;GeoPoint&gt;</code></strong>: List of geographic coordinates defining the line</li>
<li><strong><code>extra: Serializable?</code></strong>: Additional data attached to the polyline</li>
</ul>
<h3 id="visual-properties-2"><a class="header" href="#visual-properties-2">Visual Properties</a></h3>
<ul>
<li><strong><code>strokeColor: Color</code></strong>: Line color</li>
<li><strong><code>strokeWidth: Dp</code></strong>: Line width</li>
<li><strong><code>geodesic: Boolean</code></strong>: Whether to draw geodesic lines (following Earth’s curvature)</li>
</ul>
<h2 id="methods-2"><a class="header" href="#methods-2">Methods</a></h2>
<pre><code class="language-kotlin">fun copy(...): PolylineState // Create a modified copy
fun fingerPrint(): PolylineFingerPrint // Change detection
fun asFlow(): Flow&lt;PolylineFingerPrint&gt; // Reactive updates
</code></pre>
<h2 id="usage-examples-8"><a class="header" href="#usage-examples-8">Usage Examples</a></h2>
<h3 id="basic-polyline-2"><a class="header" href="#basic-polyline-2">Basic Polyline</a></h3>
<pre><code class="language-kotlin">val polylineState = PolylineState(
    points = listOf(
        GeoPointImpl.fromLatLong(37.7749, -122.4194),
        GeoPointImpl.fromLatLong(37.7849, -122.4094),
        GeoPointImpl.fromLatLong(37.7949, -122.3994)
    ),
    strokeColor = Color.Blue,
    strokeWidth = 3.dp
)

// Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
    Polyline(polylineState)
}
</code></pre>
<h3 id="dynamic-polyline"><a class="header" href="#dynamic-polyline">Dynamic Polyline</a></h3>
<pre><code class="language-kotlin">@Composable
fun DynamicPolylineExample() {
    var polylineState by remember {
        mutableStateOf(
            PolylineState(
                points = listOf(
                    GeoPointImpl.fromLatLong(37.7749, -122.4194),
                    GeoPointImpl.fromLatLong(37.7849, -122.4094)
                ),
                strokeColor = Color.Red,
                strokeWidth = 4.dp
            )
        )
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(
        state = mapViewState,
        onMapClick = { geoPoint -&gt;
            polylineState = polylineState.copy(
                points = polylineState.points + geoPoint
            )
        }
    ) {
        Polyline(polylineState)
    }
}
</code></pre>
<h3 id="geodesic-polyline"><a class="header" href="#geodesic-polyline">Geodesic Polyline</a></h3>
<pre><code class="language-kotlin">val geodesicPolyline = PolylineState(
    points = listOf(
        GeoPointImpl.fromLatLong(37.7749, -122.4194), // San Francisco
        GeoPointImpl.fromLatLong(40.7128, -74.0060)   // New York
    ),
    strokeColor = Color.Green,
    strokeWidth = 3.dp,
    geodesic = true, // Follows Earth's curvature
    extra = "Cross-country route"
)
</code></pre>
<h3 id="multi-segment-route"><a class="header" href="#multi-segment-route">Multi-segment Route</a></h3>
<pre><code class="language-kotlin">@Composable
fun RouteExample() {
    val routeSegments = remember {
        listOf(
            PolylineState(
                points = highway1Points,
                strokeColor = Color.Blue,
                strokeWidth = 6.dp,
                extra = "Highway segment"
            ),
            PolylineState(
                points = localRoadPoints,
                strokeColor = Color.Green,
                strokeWidth = 3.dp,
                extra = "Local road segment"
            ),
            PolylineState(
                points = walkingPathPoints,
                strokeColor = Color.Orange,
                strokeWidth = 2.dp,
                extra = "Walking path"
            )
        )
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
        routeSegments.forEach { segment -&gt;
            Polyline(segment)
        }
    }
}
</code></pre>
<h2 id="event-handling-8"><a class="header" href="#event-handling-8">Event Handling</a></h2>
<p>Polyline events provide both the state and click location:</p>
<pre><code class="language-kotlin">data class PolylineEvent(
    val state: PolylineState,
    val clicked: GeoPoint
)

typealias OnPolylineEventHandler = (PolylineEvent) -&gt; Unit
</code></pre>
<h2 id="best-practices-11"><a class="header" href="#best-practices-11">Best Practices</a></h2>
<ol>
<li><strong>Point Density</strong>: Balance detail with performance - avoid excessive points</li>
<li><strong>Geodesic Lines</strong>: Use for long-distance routes to show accurate paths</li>
<li><strong>Color Coding</strong>: Use different colors to distinguish route types</li>
<li><strong>Width Hierarchy</strong>: Use stroke width to indicate importance</li>
<li><strong>Performance</strong>: Consider simplification for complex polylines at different zoom levels</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polygonstate"><a class="header" href="#polygonstate">PolygonState</a></h1>
<p><code>PolygonState</code> manages the configuration and behavior of polygon (filled area) overlays on the map. It provides reactive properties for vertices, stroke, fill, and geodesic options.</p>
<h2 id="constructor-3"><a class="header" href="#constructor-3">Constructor</a></h2>
<pre><code class="language-kotlin">PolygonState(
    points: List&lt;GeoPoint&gt;,
    id: String? = null,
    strokeColor: Color = Color.Black,
    strokeWidth: Dp = 2.dp,
    fillColor: Color = Color.Transparent,
    geodesic: Boolean = false,
    extra: Serializable? = null
)
</code></pre>
<h2 id="properties-3"><a class="header" href="#properties-3">Properties</a></h2>
<h3 id="core-properties-4"><a class="header" href="#core-properties-4">Core Properties</a></h3>
<ul>
<li><strong><code>id: String</code></strong>: Unique identifier (auto-generated if not provided)</li>
<li><strong><code>points: List&lt;GeoPoint&gt;</code></strong>: List of vertices defining the polygon (should be closed)</li>
<li><strong><code>extra: Serializable?</code></strong>: Additional data attached to the polygon</li>
</ul>
<h3 id="visual-properties-3"><a class="header" href="#visual-properties-3">Visual Properties</a></h3>
<ul>
<li><strong><code>strokeColor: Color</code></strong>: Border color</li>
<li><strong><code>strokeWidth: Dp</code></strong>: Border width</li>
<li><strong><code>fillColor: Color</code></strong>: Interior fill color</li>
<li><strong><code>geodesic: Boolean</code></strong>: Whether to draw geodesic edges</li>
</ul>
<h2 id="methods-3"><a class="header" href="#methods-3">Methods</a></h2>
<pre><code class="language-kotlin">fun copy(...): PolygonState // Create a modified copy
fun fingerPrint(): PolygonFingerPrint // Change detection
fun asFlow(): Flow&lt;PolygonFingerPrint&gt; // Reactive updates
</code></pre>
<h2 id="usage-examples-9"><a class="header" href="#usage-examples-9">Usage Examples</a></h2>
<h3 id="basic-polygon-2"><a class="header" href="#basic-polygon-2">Basic Polygon</a></h3>
<pre><code class="language-kotlin">val polygonState = PolygonState(
    points = listOf(
        GeoPointImpl.fromLatLong(37.7749, -122.4194),
        GeoPointImpl.fromLatLong(37.7849, -122.4094),
        GeoPointImpl.fromLatLong(37.7749, -122.3994),
        GeoPointImpl.fromLatLong(37.7749, -122.4194) // Close the polygon
    ),
    strokeColor = Color.Blue,
    strokeWidth = 2.dp,
    fillColor = Color.Blue.copy(alpha = 0.3f)
)

// Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
    Polygon(polygonState)
}
</code></pre>
<h3 id="interactive-polygon"><a class="header" href="#interactive-polygon">Interactive Polygon</a></h3>
<pre><code class="language-kotlin">@Composable
fun EditablePolygonExample() {
    var polygonState by remember {
        mutableStateOf(
            PolygonState(
                points = listOf(
                    GeoPointImpl.fromLatLong(37.7749, -122.4194),
                    GeoPointImpl.fromLatLong(37.7849, -122.4094),
                    GeoPointImpl.fromLatLong(37.7799, -122.3994),
                    GeoPointImpl.fromLatLong(37.7749, -122.4194)
                ),
                strokeColor = Color.Red,
                fillColor = Color.Red.copy(alpha = 0.2f)
            )
        )
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(
        state = mapViewState,
        onPolygonClick = { event -&gt;
            println("Polygon clicked at: ${event.clicked}")
        }
    ) {
        Polygon(polygonState)

        // Vertex markers (excluding the closing point)
        polygonState.points.dropLast(1).forEachIndexed { index, point -&gt;
            Marker(
                position = point,
                icon = DefaultIcon(
                    fillColor = Color.Red,
                    label = "${index + 1}",
                    scale = 0.8f
                ),
                draggable = true,
                extra = "vertex_$index"
            )
        }
    }
}
</code></pre>
<h3 id="zone-polygons"><a class="header" href="#zone-polygons">Zone Polygons</a></h3>
<pre><code class="language-kotlin">val zonePolygons = listOf(
    PolygonState(
        points = restrictedZonePoints,
        strokeColor = Color.Red,
        strokeWidth = 3.dp,
        fillColor = Color.Red.copy(alpha = 0.2f),
        extra = "Restricted Zone"
    ),
    PolygonState(
        points = parkingZonePoints,
        strokeColor = Color.Blue,
        strokeWidth = 2.dp,
        fillColor = Color.Blue.copy(alpha = 0.2f),
        extra = "Parking Zone"
    ),
    PolygonState(
        points = safeZonePoints,
        strokeColor = Color.Green,
        strokeWidth = 2.dp,
        fillColor = Color.Green.copy(alpha = 0.2f),
        extra = "Safe Zone"
    )
)

// Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
    zonePolygons.forEach { zone -&gt;
        Polygon(zone)
    }
}
</code></pre>
<h3 id="complex-shapes"><a class="header" href="#complex-shapes">Complex Shapes</a></h3>
<pre><code class="language-kotlin">@Composable
fun ComplexPolygonExample() {
    // Star-shaped polygon
    val starPolygon = remember {
        val center = GeoPointImpl.fromLatLong(37.7749, -122.4194)
        val points = mutableListOf&lt;GeoPoint&gt;()

        for (i in 0 until 10) {
            val angle = (i * 36.0) * Math.PI / 180.0
            val radius = if (i % 2 == 0) 0.01 else 0.005
            val lat = center.latitude + radius * cos(angle)
            val lng = center.longitude + radius * sin(angle)
            points.add(GeoPointImpl.fromLatLong(lat, lng))
        }
        points.add(points.first()) // Close the polygon

        PolygonState(
            points = points,
            strokeColor = Color.Magenta,
            fillColor = Color.Magenta.copy(alpha = 0.4f),
            extra = "Star shape"
        )
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
        Polygon(starPolygon)
    }
}
</code></pre>
<h2 id="event-handling-9"><a class="header" href="#event-handling-9">Event Handling</a></h2>
<p>Polygon events provide both the state and click location:</p>
<pre><code class="language-kotlin">data class PolygonEvent(
    val state: PolygonState,
    val clicked: GeoPoint?
)

typealias OnPolygonEventHandler = (PolygonEvent) -&gt; Unit
</code></pre>
<h2 id="best-practices-12"><a class="header" href="#best-practices-12">Best Practices</a></h2>
<ol>
<li><strong>Close Polygons</strong>: Ensure first and last points are the same</li>
<li><strong>Vertex Order</strong>: Use consistent ordering (clockwise/counter-clockwise)</li>
<li><strong>Performance</strong>: Avoid overly complex polygons with many vertices</li>
<li><strong>Visual Design</strong>: Use appropriate fill transparency for map visibility</li>
<li><strong>Validation</strong>: Ensure polygons form valid geometric shapes</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="groundimagestate"><a class="header" href="#groundimagestate">GroundImageState</a></h1>
<p><code>GroundImageState</code> manages the configuration and behavior of ground image overlays on the map. It provides reactive properties for geographic bounds, image resources, and opacity settings.</p>
<h2 id="constructor-4"><a class="header" href="#constructor-4">Constructor</a></h2>
<pre><code class="language-kotlin">GroundImageState(
    bounds: GeoRectBounds,
    image: Drawable,
    opacity: Float = 1.0f,
    id: String? = null,
    extra: Serializable? = null
)
</code></pre>
<h2 id="properties-4"><a class="header" href="#properties-4">Properties</a></h2>
<h3 id="core-properties-5"><a class="header" href="#core-properties-5">Core Properties</a></h3>
<ul>
<li><strong><code>id: String</code></strong>: Unique identifier (auto-generated if not provided)</li>
<li><strong><code>bounds: GeoRectBounds</code></strong>: Geographic rectangular bounds for image placement</li>
<li><strong><code>image: Drawable</code></strong>: The drawable image to display</li>
<li><strong><code>opacity: Float</code></strong>: Transparency level (0.0 = transparent, 1.0 = opaque)</li>
<li><strong><code>extra: Serializable?</code></strong>: Additional data attached to the ground image</li>
</ul>
<h2 id="methods-4"><a class="header" href="#methods-4">Methods</a></h2>
<pre><code class="language-kotlin">fun fingerPrint(): GroundImageFingerPrint // Change detection
fun asFlow(): Flow&lt;GroundImageFingerPrint&gt; // Reactive updates
</code></pre>
<h2 id="usage-examples-10"><a class="header" href="#usage-examples-10">Usage Examples</a></h2>
<h3 id="basic-ground-image"><a class="header" href="#basic-ground-image">Basic Ground Image</a></h3>
<pre><code class="language-kotlin">@Composable
fun BasicGroundImageExample() {
    val context = LocalContext.current
    val drawable = AppCompatResources.getDrawable(context, R.drawable.overlay_image)

    val groundImageState = drawable?.let {
        GroundImageState(
            bounds = GeoRectBounds(
                southwest = GeoPointImpl.fromLatLong(37.7649, -122.4294),
                northeast = GeoPointImpl.fromLatLong(37.7849, -122.4094)
            ),
            image = it,
            opacity = 0.7f,
            extra = "Base overlay"
        )
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
        groundImageState?.let { state -&gt;
            GroundImage(state)
        }
    }
}
</code></pre>
<h3 id="interactive-ground-image"><a class="header" href="#interactive-ground-image">Interactive Ground Image</a></h3>
<pre><code class="language-kotlin">@Composable
fun InteractiveGroundImageExample() {
    var groundImageState by remember { mutableStateOf&lt;GroundImageState?&gt;(null) }
    var opacity by remember { mutableStateOf(0.7f) }

    val context = LocalContext.current

    LaunchedEffect(opacity) {
        val drawable = AppCompatResources.getDrawable(context, R.drawable.map_overlay)
        drawable?.let {
            groundImageState = GroundImageState(
                bounds = GeoRectBounds(
                    southwest = GeoPointImpl.fromLatLong(37.7649, -122.4294),
                    northeast = GeoPointImpl.fromLatLong(37.7849, -122.4094)
                ),
                image = it,
                opacity = opacity,
                extra = "Interactive overlay"
            )
        }
    }

    Column {
        Slider(
            value = opacity,
            onValueChange = { opacity = it },
            valueRange = 0f..1f,
            modifier = Modifier.padding(16.dp)
        )
        Text("Opacity: ${(opacity * 100).toInt()}%")

        // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(
            state = mapViewState,
            onGroundImageClick = { event -&gt;
                println("Ground image clicked at: ${event.clicked}")
            }
        ) {
            groundImageState?.let { state -&gt;
                GroundImage(state)
            }
        }
    }
}
</code></pre>
<h3 id="multiple-overlays"><a class="header" href="#multiple-overlays">Multiple Overlays</a></h3>
<pre><code class="language-kotlin">@Composable
fun MultiLayerGroundImageExample() {
    val context = LocalContext.current

    val overlayStates = remember {
        listOf(
            Triple(R.drawable.base_layer, 0.3f, "Base satellite"),
            Triple(R.drawable.weather_layer, 0.6f, "Weather data"),
            Triple(R.drawable.traffic_layer, 0.8f, "Traffic info")
        ).mapNotNull { (resId, opacity, description) -&gt;
            AppCompatResources.getDrawable(context, resId)?.let { drawable -&gt;
                GroundImageState(
                    bounds = GeoRectBounds(
                        southwest = GeoPointImpl.fromLatLong(37.7649, -122.4294),
                        northeast = GeoPointImpl.fromLatLong(37.7849, -122.4094)
                    ),
                    image = drawable,
                    opacity = opacity,
                    extra = description
                )
            }
        }
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
        overlayStates.forEach { state -&gt;
            GroundImage(state)
        }
    }
}
</code></pre>
<h3 id="dynamic-bounds"><a class="header" href="#dynamic-bounds">Dynamic Bounds</a></h3>
<pre><code class="language-kotlin">@Composable
fun DynamicBoundsExample() {
    var southwest by remember {
        mutableStateOf(GeoPointImpl.fromLatLong(37.7649, -122.4294))
    }
    var northeast by remember {
        mutableStateOf(GeoPointImpl.fromLatLong(37.7849, -122.4094))
    }

    val context = LocalContext.current
    val drawable = AppCompatResources.getDrawable(context, R.drawable.floor_plan)

    val groundImageState = drawable?.let {
        GroundImageState(
            bounds = GeoRectBounds(southwest = southwest, northeast = northeast),
            image = it,
            opacity = 0.8f,
            extra = "Floor plan"
        )
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(
        state = mapViewState,
        onMarkerDrag = { markerState -&gt;
            when (markerState.extra) {
                "SW" -&gt; southwest = markerState.position
                "NE" -&gt; northeast = markerState.position
            }
        }
    ) {
        groundImageState?.let { state -&gt;
            GroundImage(state)
        }

        // Corner markers
        Marker(
            position = southwest,
            icon = DefaultIcon(fillColor = Color.Green, label = "SW"),
            draggable = true,
            extra = "SW"
        )

        Marker(
            position = northeast,
            icon = DefaultIcon(fillColor = Color.Red, label = "NE"),
            draggable = true,
            extra = "NE"
        )
    }
}
</code></pre>
<h3 id="animated-overlay"><a class="header" href="#animated-overlay">Animated Overlay</a></h3>
<pre><code class="language-kotlin">@Composable
fun AnimatedGroundImageExample() {
    var isAnimating by remember { mutableStateOf(false) }
    var opacity by remember { mutableStateOf(0.5f) }

    LaunchedEffect(isAnimating) {
        if (isAnimating) {
            while (isAnimating) {
                delay(100)
                opacity = (sin(System.currentTimeMillis() / 1000.0).toFloat() + 1f) / 2f
            }
        }
    }

    val context = LocalContext.current
    val drawable = AppCompatResources.getDrawable(context, R.drawable.animated_overlay)

    val groundImageState = drawable?.let {
        GroundImageState(
            bounds = GeoRectBounds(
                southwest = GeoPointImpl.fromLatLong(37.7649, -122.4294),
                northeast = GeoPointImpl.fromLatLong(37.7849, -122.4094)
            ),
            image = it,
            opacity = opacity,
            extra = "Animated overlay"
        )
    }

    Column {
        Button(onClick = { isAnimating = !isAnimating }) {
            Text(if (isAnimating) "Stop" else "Animate")
        }

        // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
            groundImageState?.let { state -&gt;
                GroundImage(state)
            }
        }
    }
}
</code></pre>
<h2 id="event-handling-10"><a class="header" href="#event-handling-10">Event Handling</a></h2>
<p>Ground image events provide both the state and click location:</p>
<pre><code class="language-kotlin">data class GroundImageEvent(
    val state: GroundImageState,
    val clicked: GeoPointImpl?
)

typealias OnGroundImageEventHandler = (GroundImageEvent) -&gt; Unit
</code></pre>
<h2 id="image-resource-management"><a class="header" href="#image-resource-management">Image Resource Management</a></h2>
<h3 id="loading-from-different-sources"><a class="header" href="#loading-from-different-sources">Loading from Different Sources</a></h3>
<pre><code class="language-kotlin">// From resources
val drawable = AppCompatResources.getDrawable(context, R.drawable.overlay)

// From assets
val inputStream = context.assets.open("overlays/map.png")
val drawable = Drawable.createFromStream(inputStream, null)

// From network (with image loading library)
// Use libraries like Coil, Glide, or Picasso for network images
</code></pre>
<h2 id="best-practices-13"><a class="header" href="#best-practices-13">Best Practices</a></h2>
<ol>
<li><strong>Image Size</strong>: Optimize image resolution for performance</li>
<li><strong>Bounds Accuracy</strong>: Ensure precise geographic alignment</li>
<li><strong>Opacity</strong>: Use appropriate transparency for visibility</li>
<li><strong>Resource Management</strong>: Cache and reuse drawable resources</li>
<li><strong>Layer Order</strong>: Consider drawing order for multiple overlays</li>
<li><strong>Performance</strong>: Limit the number of simultaneous ground images</li>
<li><strong>Error Handling</strong>: Handle cases where images fail to load</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="geopoint"><a class="header" href="#geopoint">GeoPoint</a></h1>
<p><code>GeoPoint</code> represents a geographic coordinate with latitude, longitude, and optional altitude. It is the fundamental building block for positioning markers, circles, and other map overlays.</p>
<h2 id="interface-and-implementation"><a class="header" href="#interface-and-implementation">Interface and Implementation</a></h2>
<h3 id="geopoint-interface"><a class="header" href="#geopoint-interface">GeoPoint Interface</a></h3>
<pre><code class="language-kotlin">interface GeoPoint {
    val latitude: Double
    val longitude: Double
    val altitude: Double?
}
</code></pre>
<h3 id="geopointimpl"><a class="header" href="#geopointimpl">GeoPointImpl</a></h3>
<p>The main implementation provides immutable geographic coordinates:</p>
<pre><code class="language-kotlin">data class GeoPointImpl(
    override val latitude: Double,
    override val longitude: Double,
    override val altitude: Double = 0.0
) : GeoPoint
</code></pre>
<h2 id="creation-methods"><a class="header" href="#creation-methods">Creation Methods</a></h2>
<h3 id="factory-methods"><a class="header" href="#factory-methods">Factory Methods</a></h3>
<pre><code class="language-kotlin">// Standard creation - latitude first (common pattern)
GeoPointImpl.fromLatLong(37.7749, -122.4194)

// Alternative - longitude first
GeoPointImpl.fromLongLat(-122.4194, 37.7749)

// From existing GeoPoint
GeoPointImpl.from(existingGeoPoint)

// Direct constructor
GeoPointImpl(latitude = 37.7749, longitude = -122.4194, altitude = 100.0)
</code></pre>
<h3 id="usage-examples-11"><a class="header" href="#usage-examples-11">Usage Examples</a></h3>
<pre><code class="language-kotlin">// Basic marker positioning
val sanFrancisco = GeoPointImpl.fromLatLong(37.7749, -122.4194)

// Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
    Marker(
        position = sanFrancisco,
        icon = DefaultIcon(label = "SF")
    )
}
</code></pre>
<pre><code class="language-kotlin">// With altitude for 3D positioning
val mountEverest = GeoPointImpl(
    latitude = 27.9881,
    longitude = 86.9250,
    altitude = 8848.0 // meters
)
</code></pre>
<h2 id="coordinate-system"><a class="header" href="#coordinate-system">Coordinate System</a></h2>
<h3 id="latitude"><a class="header" href="#latitude">Latitude</a></h3>
<ul>
<li><strong>Range</strong>: -90.0 to 90.0 degrees</li>
<li><strong>-90.0</strong>: South Pole</li>
<li><strong>0.0</strong>: Equator</li>
<li><strong>90.0</strong>: North Pole</li>
</ul>
<h3 id="longitude"><a class="header" href="#longitude">Longitude</a></h3>
<ul>
<li><strong>Range</strong>: -180.0 to 180.0 degrees</li>
<li><strong>-180.0</strong>: International Date Line (west side)</li>
<li><strong>0.0</strong>: Prime Meridian (Greenwich)</li>
<li><strong>180.0</strong>: International Date Line (east side)</li>
</ul>
<h3 id="altitude"><a class="header" href="#altitude">Altitude</a></h3>
<ul>
<li><strong>Optional</strong>: Can be <code>null</code> or <code>0.0</code> for 2D positioning</li>
<li><strong>Units</strong>: Meters above sea level</li>
<li><strong>Usage</strong>: 3D positioning, elevation data</li>
</ul>
<h2 id="validation-and-normalization"><a class="header" href="#validation-and-normalization">Validation and Normalization</a></h2>
<h3 id="validation"><a class="header" href="#validation">Validation</a></h3>
<pre><code class="language-kotlin">fun GeoPoint.isValid(): Boolean =
    latitude in -90.0..90.0 &amp;&amp; longitude in -180.0..180.0

// Usage
val point = GeoPointImpl.fromLatLong(37.7749, -122.4194)
if (point.isValid()) {
    // Use the point
}
</code></pre>
<h3 id="normalization"><a class="header" href="#normalization">Normalization</a></h3>
<pre><code class="language-kotlin">fun GeoPoint.normalize(): GeoPointImpl

// Usage
val invalidPoint = GeoPointImpl.fromLatLong(100.0, 200.0) // Invalid coordinates
val validPoint = invalidPoint.normalize() // Clamped to valid range
</code></pre>
<h2 id="distance-and-bearing-calculations"><a class="header" href="#distance-and-bearing-calculations">Distance and Bearing Calculations</a></h2>
<h3 id="distance-between-points"><a class="header" href="#distance-between-points">Distance Between Points</a></h3>
<pre><code class="language-kotlin">fun GeoPoint.distanceTo(other: GeoPoint): Double

// Usage
val sf = GeoPointImpl.fromLatLong(37.7749, -122.4194)
val nyc = GeoPointImpl.fromLatLong(40.7128, -74.0060)

val distanceMeters = sf.distanceTo(nyc)
val distanceKm = distanceMeters / 1000.0

println("Distance SF to NYC: ${distanceKm}km")
</code></pre>
<h3 id="bearing-direction"><a class="header" href="#bearing-direction">Bearing (Direction)</a></h3>
<pre><code class="language-kotlin">fun GeoPoint.headingTo(other: GeoPoint): Double

// Usage
val bearing = sf.headingTo(nyc) // Returns bearing in degrees (0-360)
println("Bearing from SF to NYC: ${bearing}°")
</code></pre>
<h3 id="offset-point"><a class="header" href="#offset-point">Offset Point</a></h3>
<pre><code class="language-kotlin">fun GeoPoint.offset(distance: Double, heading: Double): GeoPointImpl

// Usage
val sf = GeoPointImpl.fromLatLong(37.7749, -122.4194)
val pointNorth = sf.offset(1000.0, 0.0) // 1km north of SF
val pointEast = sf.offset(1000.0, 90.0)  // 1km east of SF
</code></pre>
<h2 id="interpolation"><a class="header" href="#interpolation">Interpolation</a></h2>
<h3 id="spherical-interpolation"><a class="header" href="#spherical-interpolation">Spherical Interpolation</a></h3>
<p>Considers Earth’s curvature (recommended for geographic calculations):</p>
<pre><code class="language-kotlin">fun GeoPoint.interpolateTo(other: GeoPoint, fraction: Double): GeoPointImpl

// Usage
val sf = GeoPointImpl.fromLatLong(37.7749, -122.4194)
val nyc = GeoPointImpl.fromLatLong(40.7128, -74.0060)

val halfway = sf.interpolateTo(nyc, 0.5) // Midpoint considering Earth's curvature
val quarterWay = sf.interpolateTo(nyc, 0.25)
</code></pre>
<h3 id="linear-interpolation"><a class="header" href="#linear-interpolation">Linear Interpolation</a></h3>
<p>Ignores Earth’s curvature (faster but less accurate for long distances):</p>
<pre><code class="language-kotlin">fun GeoPoint.linearInterpolateTo(other: GeoPoint, fraction: Double): GeoPointImpl

// Usage
val linearMidpoint = sf.linearInterpolateTo(nyc, 0.5)
</code></pre>
<h2 id="practical-examples"><a class="header" href="#practical-examples">Practical Examples</a></h2>
<h3 id="route-waypoints"><a class="header" href="#route-waypoints">Route Waypoints</a></h3>
<pre><code class="language-kotlin">@Composable
fun RouteWithWaypoints() {
    val start = GeoPointImpl.fromLatLong(37.7749, -122.4194)
    val end = GeoPointImpl.fromLatLong(37.7849, -122.4094)

    // Create waypoints along the route
    val waypoints = (0..10).map { i -&gt;
        start.interpolateTo(end, i / 10.0)
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    MapView(state = mapViewState) {
        // Draw route
        Polyline(
            points = waypoints,
            strokeColor = Color.Blue,
            strokeWidth = 3.dp
        )

        // Waypoint markers
        waypoints.forEachIndexed { index, point -&gt;
            Marker(
                position = point,
                icon = DefaultIcon(
                    label = "$index",
                    scale = 0.7f
                )
            )
        }
    }
}
</code></pre>
<h3 id="proximity-detection"><a class="header" href="#proximity-detection">Proximity Detection</a></h3>
<pre><code class="language-kotlin">@Composable
fun ProximityExample() {
    val userLocation = GeoPointImpl.fromLatLong(37.7749, -122.4194)
    val poi = GeoPointImpl.fromLatLong(37.7759, -122.4184)

    val distance = userLocation.distanceTo(poi)
    val isNearby = distance &lt; 100.0 // Within 100 meters

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    MapView(state = mapViewState) {
        Marker(
            position = userLocation,
            icon = DefaultIcon(
                fillColor = Color.Blue,
                label = "You"
            )
        )

        Marker(
            position = poi,
            icon = DefaultIcon(
                fillColor = if (isNearby) Color.Green else Color.Red,
                label = "POI"
            )
        )

        // Proximity circle
        Circle(
            center = poi,
            radius = 100.0,
            strokeColor = Color.Green.copy(alpha = 0.5f),
            fillColor = Color.Green.copy(alpha = 0.1f)
        )
    }
}
</code></pre>
<h3 id="dynamic-position-updates"><a class="header" href="#dynamic-position-updates">Dynamic Position Updates</a></h3>
<pre><code class="language-kotlin">@Composable
fun MovingMarkerExample() {
    val path = listOf(
        GeoPointImpl.fromLatLong(37.7749, -122.4194),
        GeoPointImpl.fromLatLong(37.7759, -122.4184),
        GeoPointImpl.fromLatLong(37.7769, -122.4174)
    )

    var currentPosition by remember { mutableStateOf(path.first()) }
    var pathIndex by remember { mutableStateOf(0) }

    LaunchedEffect(Unit) {
        while (true) {
            delay(2000)
            pathIndex = (pathIndex + 1) % path.size
            currentPosition = path[pathIndex]
        }
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    MapView(state = mapViewState) {
        // Moving marker
        Marker(
            position = currentPosition,
            icon = DefaultIcon(
                fillColor = Color.Red,
                label = "📍"
            )
        )

        // Path preview
        Polyline(
            points = path,
            strokeColor = Color.Gray,
            strokeWidth = 2.dp
        )
    }
}
</code></pre>
<h2 id="equality-and-hashing"><a class="header" href="#equality-and-hashing">Equality and Hashing</a></h2>
<p><code>GeoPointImpl</code> uses tolerance-based equality to handle floating-point precision issues:</p>
<pre><code class="language-kotlin">val point1 = GeoPointImpl.fromLatLong(37.7749, -122.4194)
val point2 = GeoPointImpl.fromLatLong(37.7749000001, -122.4194000001)

println(point1 == point2) // true - within tolerance
</code></pre>
<p>The tolerance is set to <code>1e-7</code> degrees, which is approximately 1 centimeter at the equator.</p>
<h2 id="url-formatting"><a class="header" href="#url-formatting">URL Formatting</a></h2>
<pre><code class="language-kotlin">fun toUrlValue(precision: Int = 6): String

// Usage
val point = GeoPointImpl.fromLatLong(37.7749, -122.4194)
val urlString = point.toUrlValue() // "37.774900,-122.419400"
val preciseString = point.toUrlValue(precision = 8) // More decimal places
</code></pre>
<h2 id="best-practices-14"><a class="header" href="#best-practices-14">Best Practices</a></h2>
<ol>
<li><strong>Use Factory Methods</strong>: Prefer <code>fromLatLong()</code> for clarity about parameter order</li>
<li><strong>Validate Input</strong>: Check coordinates are within valid ranges when accepting user input</li>
<li><strong>Consider Earth’s Curvature</strong>: Use spherical interpolation for geographic accuracy</li>
<li><strong>Performance</strong>: Use linear interpolation for frequent calculations where precision is less critical</li>
<li><strong>Altitude</strong>: Include altitude for 3D applications, use 0.0 for 2D mapping</li>
<li><strong>Immutability</strong>: GeoPointImpl is immutable - create new instances for different coordinates</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="georectbounds"><a class="header" href="#georectbounds">GeoRectBounds</a></h1>
<p><code>GeoRectBounds</code> represents a rectangular geographic area defined by southwest and northeast corner points. It is used for defining map regions, ground image bounds, and viewport calculations.</p>
<h2 id="constructor-5"><a class="header" href="#constructor-5">Constructor</a></h2>
<pre><code class="language-kotlin">class GeoRectBounds(
    southWest: GeoPointImpl? = null,
    northEast: GeoPointImpl? = null
)
</code></pre>
<h2 id="properties-5"><a class="header" href="#properties-5">Properties</a></h2>
<h3 id="corner-points"><a class="header" href="#corner-points">Corner Points</a></h3>
<ul>
<li><strong><code>southWest: GeoPointImpl?</code></strong>: Southwest corner (bottom-left) of the rectangle</li>
<li><strong><code>northEast: GeoPointImpl?</code></strong>: Northeast corner (top-right) of the rectangle</li>
<li><strong><code>isEmpty: Boolean</code></strong>: Returns <code>true</code> if the bounds are not defined</li>
</ul>
<h3 id="computed-properties"><a class="header" href="#computed-properties">Computed Properties</a></h3>
<ul>
<li><strong><code>center: GeoPointImpl?</code></strong>: Center point of the bounds</li>
<li><strong><code>toSpan(): GeoPointImpl?</code></strong>: Returns the span (width/height) as a GeoPoint</li>
</ul>
<h2 id="basic-usage-1"><a class="header" href="#basic-usage-1">Basic Usage</a></h2>
<h3 id="creating-bounds"><a class="header" href="#creating-bounds">Creating Bounds</a></h3>
<pre><code class="language-kotlin">// Define a rectangular area
val bounds = GeoRectBounds(
    southWest = GeoPointImpl.fromLatLong(37.7649, -122.4294),
    northeast = GeoPointImpl.fromLatLong(37.7849, -122.4094)
)

// Empty bounds (to be extended later)
val bounds = GeoRectBounds()
</code></pre>
<h3 id="using-with-groundimage"><a class="header" href="#using-with-groundimage">Using with GroundImage</a></h3>
<pre><code class="language-kotlin">@Composable
fun GroundImageExample() {
    val imageBounds = GeoRectBounds(
        southWest = GeoPointImpl.fromLatLong(37.7649, -122.4294),
        northEast = GeoPointImpl.fromLatLong(37.7849, -122.4094)
    )

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    MapView(state = mapViewState) {
        val context = LocalContext.current
        AppCompatResources.getDrawable(context, R.drawable.overlay_image)?.let { drawable -&gt;
            GroundImage(
                bounds = imageBounds,
                image = drawable,
                opacity = 0.7f
            )
        }
    }
}
</code></pre>
<h2 id="dynamic-bounds-construction"><a class="header" href="#dynamic-bounds-construction">Dynamic Bounds Construction</a></h2>
<h3 id="extending-bounds"><a class="header" href="#extending-bounds">Extending Bounds</a></h3>
<p>The bounds can be dynamically extended to include new points:</p>
<pre><code class="language-kotlin">fun extend(point: GeoPoint)

// Usage
val bounds = GeoRectBounds() // Start empty

val points = listOf(
    GeoPointImpl.fromLatLong(37.7749, -122.4194),
    GeoPointImpl.fromLatLong(37.7849, -122.4094),
    GeoPointImpl.fromLatLong(37.7649, -122.4294)
)

points.forEach { point -&gt;
    bounds.extend(point) // Bounds grow to include each point
}

println("Final bounds: $bounds")
</code></pre>
<h3 id="union-of-bounds"><a class="header" href="#union-of-bounds">Union of Bounds</a></h3>
<pre><code class="language-kotlin">fun union(other: GeoRectBounds): GeoRectBounds

// Usage
val bounds1 = GeoRectBounds(
    southWest = GeoPointImpl.fromLatLong(37.7649, -122.4294),
    northEast = GeoPointImpl.fromLatLong(37.7749, -122.4194)
)

val bounds2 = GeoRectBounds(
    southWest = GeoPointImpl.fromLatLong(37.7749, -122.4194),
    northEast = GeoPointImpl.fromLatLong(37.7849, -122.4094)
)

val combinedBounds = bounds1.union(bounds2) // Contains both areas
</code></pre>
<h2 id="point-and-bounds-testing"><a class="header" href="#point-and-bounds-testing">Point and Bounds Testing</a></h2>
<h3 id="contains-point"><a class="header" href="#contains-point">Contains Point</a></h3>
<pre><code class="language-kotlin">fun contains(point: GeoPoint): Boolean

// Usage
val bounds = GeoRectBounds(
    southWest = GeoPointImpl.fromLatLong(37.7649, -122.4294),
    northEast = GeoPointImpl.fromLatLong(37.7849, -122.4094)
)

val testPoint = GeoPointImpl.fromLatLong(37.7749, -122.4194)
val isInside = bounds.contains(testPoint)

println("Point is inside bounds: $isInside")
</code></pre>
<h3 id="bounds-intersection"><a class="header" href="#bounds-intersection">Bounds Intersection</a></h3>
<pre><code class="language-kotlin">fun intersects(other: GeoRectBounds): Boolean

// Usage
val bounds1 = GeoRectBounds(/* ... */)
val bounds2 = GeoRectBounds(/* ... */)

val doIntersect = bounds1.intersects(bounds2)
println("Bounds intersect: $doIntersect")
</code></pre>
<h2 id="practical-examples-1"><a class="header" href="#practical-examples-1">Practical Examples</a></h2>
<h3 id="viewport-bounds-calculation"><a class="header" href="#viewport-bounds-calculation">Viewport Bounds Calculation</a></h3>
<pre><code class="language-kotlin">@Composable
fun ViewportBoundsExample() {
    var viewportBounds by remember { mutableStateOf&lt;GeoRectBounds?&gt;(null) }

    // Simulate calculating viewport from visible markers
    val markers = remember {
        listOf(
            GeoPointImpl.fromLatLong(37.7749, -122.4194),
            GeoPointImpl.fromLatLong(37.7849, -122.4094),
            GeoPointImpl.fromLatLong(37.7649, -122.4294),
            GeoPointImpl.fromLatLong(37.7949, -122.3994)
        )
    }

    LaunchedEffect(markers) {
        val bounds = GeoRectBounds()
        markers.forEach { marker -&gt;
            bounds.extend(marker)
        }
        viewportBounds = bounds
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    MapView(state = mapViewState) {
        // Show all markers
        markers.forEach { position -&gt;
            Marker(
                position = position,
                icon = DefaultIcon(fillColor = Color.Blue)
            )
        }

        // Show viewport bounds as a polygon
        viewportBounds?.let { bounds -&gt;
            if (!bounds.isEmpty) {
                val sw = bounds.southWest!!
                val ne = bounds.northEast!!

                val boundsPolygon = listOf(
                    sw,
                    GeoPointImpl.fromLatLong(sw.latitude, ne.longitude),
                    ne,
                    GeoPointImpl.fromLatLong(ne.latitude, sw.longitude),
                    sw // Close the polygon
                )

                Polygon(
                    points = boundsPolygon,
                    strokeColor = Color.Red,
                    strokeWidth = 2.dp,
                    fillColor = Color.Red.copy(alpha = 0.1f)
                )
            }
        }
    }
}
</code></pre>
<h3 id="bounds-based-loading"><a class="header" href="#bounds-based-loading">Bounds-based Loading</a></h3>
<pre><code class="language-kotlin">@Composable
fun BoundsBasedLoadingExample() {
    var currentBounds by remember { mutableStateOf&lt;GeoRectBounds?&gt;(null) }
    var markersInBounds by remember { mutableStateOf&lt;List&lt;GeoPointImpl&gt;&gt;(emptyList()) }

    // Simulate all available markers
    val allMarkers = remember {
        List(100) { i -&gt;
            GeoPointImpl.fromLatLong(
                37.7 + (i % 10) * 0.01,
                -122.5 + (i / 10) * 0.01
            )
        }
    }

    // Filter markers based on current bounds
    LaunchedEffect(currentBounds) {
        markersInBounds = currentBounds?.let { bounds -&gt;
            if (bounds.isEmpty) {
                emptyList()
            } else {
                allMarkers.filter { marker -&gt;
                    bounds.contains(marker)
                }
            }
        } ?: emptyList()
    }

    Column {
        Text("Markers in bounds: ${markersInBounds.size}/${allMarkers.size}")

        Button(
            onClick = {
                // Simulate setting viewport bounds
                currentBounds = GeoRectBounds(
                    southWest = GeoPointImpl.fromLatLong(37.70, -122.50),
                    northEast = GeoPointImpl.fromLatLong(37.75, -122.45)
                )
            }
        ) {
            Text("Set Viewport")
        }

        // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
        MapView(state = mapViewState) {
            // Show only markers within bounds
            markersInBounds.forEach { position -&gt;
                Marker(
                    position = position,
                    icon = DefaultIcon(
                        fillColor = Color.Green,
                        scale = 0.8f
                    )
                )
            }

            // Show current bounds
            currentBounds?.let { bounds -&gt;
                if (!bounds.isEmpty) {
                    val sw = bounds.southWest!!
                    val ne = bounds.northEast!!

                    Polygon(
                        points = listOf(
                            sw,
                            GeoPointImpl.fromLatLong(sw.latitude, ne.longitude),
                            ne,
                            GeoPointImpl.fromLatLong(ne.latitude, sw.longitude),
                            sw
                        ),
                        strokeColor = Color.Blue,
                        strokeWidth = 3.dp,
                        fillColor = Color.Blue.copy(alpha = 0.1f)
                    )
                }
            }
        }
    }
}
</code></pre>
<h3 id="interactive-bounds-editor"><a class="header" href="#interactive-bounds-editor">Interactive Bounds Editor</a></h3>
<pre><code class="language-kotlin">@Composable
fun BoundsEditorExample() {
    var bounds by remember {
        mutableStateOf(
            GeoRectBounds(
                southWest = GeoPointImpl.fromLatLong(37.7649, -122.4294),
                northEast = GeoPointImpl.fromLatLong(37.7849, -122.4094)
            )
        )
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    MapView(
        state = mapViewState,
        onMarkerDrag = { markerState -&gt;
            val newPosition = markerState.position
            when (markerState.extra) {
                "SW" -&gt; {
                    bounds = GeoRectBounds(
                        southWest = newPosition as GeoPointImpl,
                        northEast = bounds.northEast
                    )
                }
                "NE" -&gt; {
                    bounds = GeoRectBounds(
                        southWest = bounds.southWest,
                        northEast = newPosition as GeoPointImpl
                    )
                }
            }
        }
    ) {
        // Bounds visualization
        if (!bounds.isEmpty) {
            val sw = bounds.southWest!!
            val ne = bounds.northEast!!

            // Bounds rectangle
            Polygon(
                points = listOf(
                    sw,
                    GeoPointImpl.fromLatLong(sw.latitude, ne.longitude),
                    ne,
                    GeoPointImpl.fromLatLong(ne.latitude, sw.longitude),
                    sw
                ),
                strokeColor = Color.Red,
                fillColor = Color.Red.copy(alpha = 0.2f)
            )

            // Corner markers
            Marker(
                position = sw,
                icon = DefaultIcon(
                    fillColor = Color.Green,
                    label = "SW"
                ),
                draggable = true,
                extra = "SW"
            )

            Marker(
                position = ne,
                icon = DefaultIcon(
                    fillColor = Color.Red,
                    label = "NE"
                ),
                draggable = true,
                extra = "NE"
            )
        }
    }
}
</code></pre>
<h2 id="special-handling"><a class="header" href="#special-handling">Special Handling</a></h2>
<h3 id="international-date-line"><a class="header" href="#international-date-line">International Date Line</a></h3>
<p><code>GeoRectBounds</code> handles rectangles that cross the International Date Line (longitude ±180°):</p>
<pre><code class="language-kotlin">// Bounds crossing the date line
val pacificBounds = GeoRectBounds(
    southWest = GeoPointImpl.fromLatLong(20.0, 170.0),  // West of date line
    northEast = GeoPointImpl.fromLatLong(40.0, -170.0)  // East of date line
)

val pointInPacific = GeoPointImpl.fromLatLong(30.0, 175.0)
val containsPoint = pacificBounds.contains(pointInPacific) // true
</code></pre>
<h3 id="empty-bounds-handling"><a class="header" href="#empty-bounds-handling">Empty Bounds Handling</a></h3>
<pre><code class="language-kotlin">val emptyBounds = GeoRectBounds()

println(emptyBounds.isEmpty) // true
println(emptyBounds.center) // null
println(emptyBounds.toSpan()) // null

// Extending empty bounds
emptyBounds.extend(GeoPointImpl.fromLatLong(37.7749, -122.4194))
println(emptyBounds.isEmpty) // false
</code></pre>
<h2 id="utility-methods"><a class="header" href="#utility-methods">Utility Methods</a></h2>
<h3 id="string-representation"><a class="header" href="#string-representation">String Representation</a></h3>
<pre><code class="language-kotlin">// For debugging
val bounds = GeoRectBounds(
    southWest = GeoPointImpl.fromLatLong(37.7649, -122.4294),
    northEast = GeoPointImpl.fromLatLong(37.7849, -122.4094)
)

println(bounds.toString())
// Output: ((37.7649, -122.4294), (37.7849, -122.4094))
</code></pre>
<h3 id="url-value"><a class="header" href="#url-value">URL Value</a></h3>
<pre><code class="language-kotlin">fun toUrlValue(precision: Int = 6): String

// Usage for API calls
val urlString = bounds.toUrlValue() // "37.764900,-122.429400,37.784900,-122.409400"
val preciseString = bounds.toUrlValue(precision = 8)
</code></pre>
<h3 id="equality-comparison"><a class="header" href="#equality-comparison">Equality Comparison</a></h3>
<pre><code class="language-kotlin">fun equalsTo(other: GeoRectBounds): Boolean

// Usage
val bounds1 = GeoRectBounds(/* ... */)
val bounds2 = GeoRectBounds(/* ... */)

val areEqual = bounds1.equalsTo(bounds2)
</code></pre>
<h2 id="best-practices-15"><a class="header" href="#best-practices-15">Best Practices</a></h2>
<ol>
<li><strong>Coordinate Order</strong>: Always use southwest (bottom-left) and northeast (top-right) for consistency</li>
<li><strong>Empty Bounds</strong>: Check <code>isEmpty</code> before using bounds in calculations</li>
<li><strong>Date Line Crossing</strong>: The class handles international date line crossing automatically</li>
<li><strong>Dynamic Construction</strong>: Use <code>extend()</code> to build bounds from a collection of points</li>
<li><strong>Performance</strong>: Cache bounds calculations for frequently accessed regions</li>
<li><strong>Validation</strong>: Ensure southwest is actually southwest of northeast</li>
<li><strong>Precision</strong>: Use appropriate precision for URL values based on your use case</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mapcameraposition"><a class="header" href="#mapcameraposition">MapCameraPosition</a></h1>
<p><code>MapCameraPosition</code> represents the camera’s viewing position, orientation, and visible area on the map. It defines where the camera is looking, how much of the map is visible, and the perspective from which the map is viewed.</p>
<h2 id="interface-and-implementation-1"><a class="header" href="#interface-and-implementation-1">Interface and Implementation</a></h2>
<h3 id="mapcameraposition-interface"><a class="header" href="#mapcameraposition-interface">MapCameraPosition Interface</a></h3>
<pre><code class="language-kotlin">interface MapCameraPosition {
    val position: GeoPoint
    val zoom: Double
    val bearing: Double
    val tilt: Double
    val paddings: MapPaddings?
    val visibleRegion: VisibleRegion?
}
</code></pre>
<h3 id="mapcamerapositionimpl"><a class="header" href="#mapcamerapositionimpl">MapCameraPositionImpl</a></h3>
<p>The main implementation provides immutable camera position data:</p>
<pre><code class="language-kotlin">data class MapCameraPositionImpl(
    override val position: GeoPointImpl,
    override val zoom: Double = 0.0,
    override val bearing: Double = 0.0,
    override val tilt: Double = 0.0,
    override val paddings: MapPaddings? = MapPaddingsImpl.Zeros,
    override val visibleRegion: VisibleRegion? = null
) : MapCameraPosition
</code></pre>
<h2 id="properties-6"><a class="header" href="#properties-6">Properties</a></h2>
<h3 id="camera-location"><a class="header" href="#camera-location">Camera Location</a></h3>
<ul>
<li><strong><code>position: GeoPoint</code></strong>: Geographic center point of the camera’s view</li>
<li><strong><code>zoom: Double</code></strong>: Zoom level (approximately follows Google Maps scale)</li>
<li><strong><code>bearing: Double</code></strong>: Compass direction in degrees (0 = North, 90 = East)</li>
<li><strong><code>tilt: Double</code></strong>: Camera tilt angle in degrees (0 = top-down, 90 = horizontal)</li>
</ul>
<h3 id="view-configuration"><a class="header" href="#view-configuration">View Configuration</a></h3>
<ul>
<li><strong><code>paddings: MapPaddings?</code></strong>: Viewport padding that affects the visible region</li>
<li><strong><code>visibleRegion: VisibleRegion?</code></strong>: The actual geographic bounds visible on screen</li>
</ul>
<h2 id="creation-methods-1"><a class="header" href="#creation-methods-1">Creation Methods</a></h2>
<h3 id="default-position"><a class="header" href="#default-position">Default Position</a></h3>
<pre><code class="language-kotlin">// Default camera position at origin
val defaultPosition = MapCameraPositionImpl.Default
</code></pre>
<h3 id="custom-position"><a class="header" href="#custom-position">Custom Position</a></h3>
<pre><code class="language-kotlin">// Basic camera position
val sanFrancisco = MapCameraPositionImpl(
    position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
    zoom = 15.0
)

// Camera with bearing and tilt
val aerialView = MapCameraPositionImpl(
    position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
    zoom = 18.0,
    bearing = 45.0,  // Northeast direction
    tilt = 60.0      // Angled view
)

// Camera with padding for UI elements
val paddedView = MapCameraPositionImpl(
    position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
    zoom = 14.0,
    paddings = MapPaddingsImpl(
        top = 100.0,
        left = 50.0,
        bottom = 200.0,
        right = 50.0
    )
)
</code></pre>
<h2 id="zoom-levels"><a class="header" href="#zoom-levels">Zoom Levels</a></h2>
<p>MapConductor zoom levels approximately follow Google Maps scale but may vary slightly between providers:</p>
<ul>
<li><strong>0-2</strong>: World view, continents visible</li>
<li><strong>3-5</strong>: Country level</li>
<li><strong>6-9</strong>: State/region level</li>
<li><strong>10-12</strong>: City level</li>
<li><strong>13-15</strong>: District/neighborhood level</li>
<li><strong>16-18</strong>: Street level</li>
<li><strong>19-21</strong>: Building level (high detail)</li>
</ul>
<pre><code class="language-kotlin">// Different zoom levels for different use cases
val worldView = MapCameraPositionImpl(
    position = GeoPointImpl.fromLatLong(0.0, 0.0),
    zoom = 2.0  // Show continents
)

val cityView = MapCameraPositionImpl(
    position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
    zoom = 12.0  // Show entire city
)

val streetView = MapCameraPositionImpl(
    position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
    zoom = 17.0  // Show individual streets
)
</code></pre>
<h2 id="bearing-and-tilt"><a class="header" href="#bearing-and-tilt">Bearing and Tilt</a></h2>
<h3 id="bearing-rotation"><a class="header" href="#bearing-rotation">Bearing (Rotation)</a></h3>
<p>Bearing rotates the map around the center point:</p>
<pre><code class="language-kotlin">// North-up (default)
val northUp = MapCameraPositionImpl(
    position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
    bearing = 0.0
)

// East-up
val eastUp = MapCameraPositionImpl(
    position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
    bearing = 90.0
)

// Following a route bearing
val routeBearing = MapCameraPositionImpl(
    position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
    bearing = 135.0,  // Southeast
    zoom = 18.0
)
</code></pre>
<h3 id="tilt-3d-perspective"><a class="header" href="#tilt-3d-perspective">Tilt (3D Perspective)</a></h3>
<p>Tilt provides 3D viewing angles:</p>
<pre><code class="language-kotlin">// Top-down view (default)
val topDown = MapCameraPositionImpl(
    position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
    tilt = 0.0
)

// Slight angle for depth
val angled = MapCameraPositionImpl(
    position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
    tilt = 30.0,
    zoom = 16.0
)

// Maximum tilt for street-level view
val streetLevel = MapCameraPositionImpl(
    position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
    tilt = 80.0,
    bearing = 45.0,
    zoom = 19.0
)
</code></pre>
<h2 id="map-paddings"><a class="header" href="#map-paddings">Map Paddings</a></h2>
<p>Map paddings adjust the effective viewport without changing the camera position:</p>
<pre><code class="language-kotlin">// Padding for bottom navigation bar
val navigationPadding = MapPaddingsImpl(
    bottom = 120.0  // Reserve space for navigation
)

// Padding for side panel
val sidePanelPadding = MapPaddingsImpl(
    left = 300.0   // Reserve space for side panel
)

// Complex UI layout padding
val complexPadding = MapPaddingsImpl(
    top = 80.0,     // Status bar + toolbar
    left = 60.0,    // Side menu button area
    bottom = 160.0, // Bottom sheet + navigation
    right = 40.0    // Action button area
)

val paddedCamera = MapCameraPositionImpl(
    position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
    zoom = 15.0,
    paddings = complexPadding
)
</code></pre>
<h2 id="visible-region"><a class="header" href="#visible-region">Visible Region</a></h2>
<p>The visible region describes the actual geographic area shown on screen after considering camera position, zoom level, bearing, tilt, and viewport padding.</p>
<h3 id="visibleregion-class"><a class="header" href="#visibleregion-class">VisibleRegion Class</a></h3>
<pre><code class="language-kotlin">data class VisibleRegion(
    val bounds: GeoRectBounds,        // Overall bounding rectangle
    val nearLeft: GeoPoint?,          // Bottom-left corner (near to camera)
    val nearRight: GeoPoint?,         // Bottom-right corner (near to camera)
    val farLeft: GeoPoint?,           // Top-left corner (far from camera)
    val farRight: GeoPoint?           // Top-right corner (far from camera)
)
</code></pre>
<h3 id="properties-7"><a class="header" href="#properties-7">Properties</a></h3>
<ul>
<li>
<p><strong><code>bounds: GeoRectBounds</code></strong>: The rectangular geographic bounds that encompass the entire visible area. This is the minimum bounding rectangle that contains all visible content.</p>
</li>
<li>
<p><strong><code>nearLeft: GeoPoint?</code></strong>: The geographic coordinate of the bottom-left corner of the visible region. “Near” refers to the side closest to the camera position.</p>
</li>
<li>
<p><strong><code>nearRight: GeoPoint?</code></strong>: The geographic coordinate of the bottom-right corner of the visible region.</p>
</li>
<li>
<p><strong><code>farLeft: GeoPoint?</code></strong>: The geographic coordinate of the top-left corner of the visible region. “Far” refers to the side furthest from the camera position.</p>
</li>
<li>
<p><strong><code>farRight: GeoPoint?</code></strong>: The geographic coordinate of the top-right corner of the visible region.</p>
</li>
</ul>
<h3 id="behavior-with-camera-parameters"><a class="header" href="#behavior-with-camera-parameters">Behavior with Camera Parameters</a></h3>
<p>The visible region is affected by all camera parameters:</p>
<ul>
<li><strong>Zoom Level</strong>: Higher zoom shows smaller geographic area but with more detail</li>
<li><strong>Bearing</strong>: Camera rotation changes which geographic directions correspond to screen edges</li>
<li><strong>Tilt</strong>: 3D perspective affects the shape of the visible region</li>
<li><strong>Padding</strong>: Reduces the effective viewport, changing the visible area without moving the camera center</li>
</ul>
<h3 id="corner-points-vs-bounds"><a class="header" href="#corner-points-vs-bounds">Corner Points vs Bounds</a></h3>
<p>While <code>bounds</code> provides a simple rectangular boundary, the corner points (<code>nearLeft</code>, <code>nearRight</code>, <code>farLeft</code>, <code>farRight</code>) provide the exact geographic coordinates of each screen corner. This is especially important when:</p>
<ul>
<li>Camera has bearing rotation (corners are not aligned with cardinal directions)</li>
<li>Camera has tilt (visible region may not be perfectly rectangular)</li>
<li>High precision boundary detection is needed</li>
</ul>
<h3 id="using-visible-region"><a class="header" href="#using-visible-region">Using Visible Region</a></h3>
<pre><code class="language-kotlin">@Composable
fun VisibleRegionExample() {
    var cameraPosition by remember { mutableStateOf&lt;MapCameraPosition?&gt;(null) }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    MapView(
        state = mapViewState,
        onCameraMove = { newPosition -&gt;
            cameraPosition = newPosition
        }
    ) {
        // Display visible region info
        cameraPosition?.visibleRegion?.let { region -&gt;
            // Show bounds as a polygon
            region.bounds?.let { bounds -&gt;
                if (!bounds.isEmpty) {
                    val sw = bounds.southWest!!
                    val ne = bounds.northEast!!

                    Polygon(
                        points = listOf(
                            sw,
                            GeoPointImpl.fromLatLong(sw.latitude, ne.longitude),
                            ne,
                            GeoPointImpl.fromLatLong(ne.latitude, sw.longitude),
                            sw
                        ),
                        strokeColor = Color.Blue,
                        strokeWidth = 2.dp,
                        fillColor = Color.Blue.copy(alpha = 0.1f)
                    )
                }
            }
        }
    }
}
</code></pre>
<h2 id="animation-and-transitions"><a class="header" href="#animation-and-transitions">Animation and Transitions</a></h2>
<h3 id="smooth-camera-movement"><a class="header" href="#smooth-camera-movement">Smooth Camera Movement</a></h3>
<pre><code class="language-kotlin">@Composable
fun AnimatedCameraExample() {
    val locations = listOf(
        GeoPointImpl.fromLatLong(37.7749, -122.4194), // San Francisco
        GeoPointImpl.fromLatLong(40.7128, -74.0060),  // New York
        GeoPointImpl.fromLatLong(51.5074, -0.1278)    // London
    )

    var currentIndex by remember { mutableStateOf(0) }

    // Animate to next location every 5 seconds
    LaunchedEffect(Unit) {
        while (true) {
            delay(5000)
            currentIndex = (currentIndex + 1) % locations.size
        }
    }

    val targetPosition = MapCameraPositionImpl(
        position = locations[currentIndex],
        zoom = 12.0,
        bearing = 0.0,
        tilt = 0.0
    )

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    MapView(
        state = mapViewState,
        cameraPosition = targetPosition
    ) {
        // Add markers for each location
        locations.forEachIndexed { index, location -&gt;
            Marker(
                position = location,
                icon = DefaultIcon(
                    fillColor = if (index == currentIndex) Color.Red else Color.Gray,
                    label = when (index) {
                        0 -&gt; "SF"
                        1 -&gt; "NYC"
                        2 -&gt; "LON"
                        else -&gt; "$index"
                    }
                )
            )
        }
    }
}
</code></pre>
<h3 id="interactive-camera-control"><a class="header" href="#interactive-camera-control">Interactive Camera Control</a></h3>
<pre><code class="language-kotlin">@Composable
fun CameraControlExample() {
    var cameraPosition by remember {
        mutableStateOf(
            MapCameraPositionImpl(
                position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
                zoom = 15.0
            )
        )
    }

    Column {
        // Camera controls
        Row {
            Button(
                onClick = {
                    cameraPosition = cameraPosition.copy(
                        zoom = (cameraPosition.zoom + 1).coerceAtMost(21.0)
                    )
                }
            ) {
                Text("Zoom In")
            }

            Button(
                onClick = {
                    cameraPosition = cameraPosition.copy(
                        zoom = (cameraPosition.zoom - 1).coerceAtLeast(0.0)
                    )
                }
            ) {
                Text("Zoom Out")
            }

            Button(
                onClick = {
                    cameraPosition = cameraPosition.copy(
                        bearing = (cameraPosition.bearing + 45) % 360
                    )
                }
            ) {
                Text("Rotate")
            }
        }

        // Tilt slider
        Slider(
            value = cameraPosition.tilt.toFloat(),
            onValueChange = { tilt -&gt;
                cameraPosition = cameraPosition.copy(tilt = tilt.toDouble())
            },
            valueRange = 0f..80f
        )

        // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
        MapView(
            state = mapViewState,
            cameraPosition = cameraPosition,
            onCameraMove = { newPosition -&gt;
                cameraPosition = newPosition
            }
        ) {
            Marker(
                position = cameraPosition.position,
                icon = DefaultIcon(fillColor = Color.Red)
            )
        }
    }
}
</code></pre>
<h2 id="best-practices-16"><a class="header" href="#best-practices-16">Best Practices</a></h2>
<ol>
<li><strong>Zoom Level Selection</strong>: Choose appropriate zoom levels for your use case</li>
<li><strong>Smooth Transitions</strong>: Use gradual camera movements for better user experience</li>
<li><strong>Padding Management</strong>: Account for UI elements when setting camera position</li>
<li><strong>Performance</strong>: Avoid frequent camera position changes that trigger expensive redraws</li>
<li><strong>User Context</strong>: Consider what the user needs to see when setting initial camera position</li>
<li><strong>Accessibility</strong>: Provide controls for users who cannot use gesture-based camera movement</li>
</ol>
<h2 id="common-use-cases"><a class="header" href="#common-use-cases">Common Use Cases</a></h2>
<h3 id="focus-on-user-location"><a class="header" href="#focus-on-user-location">Focus on User Location</a></h3>
<pre><code class="language-kotlin">val userLocationCamera = MapCameraPositionImpl(
    position = userCurrentLocation,
    zoom = 16.0,  // Street level detail
    bearing = 0.0,
    tilt = 0.0
)
</code></pre>
<h3 id="show-multiple-points"><a class="header" href="#show-multiple-points">Show Multiple Points</a></h3>
<pre><code class="language-kotlin">// Calculate bounds containing all points, then set appropriate zoom
val allPoints = listOf(/* your points */)
val bounds = GeoRectBounds()
allPoints.forEach { bounds.extend(it) }

val centerCamera = MapCameraPositionImpl(
    position = bounds.center ?: GeoPointImpl.fromLatLong(0.0, 0.0),
    zoom = calculateZoomForBounds(bounds),  // Custom calculation
    bearing = 0.0,
    tilt = 0.0
)
</code></pre>
<h3 id="navigation-mode"><a class="header" href="#navigation-mode">Navigation Mode</a></h3>
<pre><code class="language-kotlin">val navigationCamera = MapCameraPositionImpl(
    position = currentRoutePosition,
    zoom = 18.0,
    bearing = currentHeading,  // Direction of travel
    tilt = 60.0               // Angled for street view
)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spherical-utilities"><a class="header" href="#spherical-utilities">Spherical Utilities</a></h1>
<p>The spherical utilities provide accurate geographic calculations using the spherical Earth model. These functions are essential for distance measurements, path calculations, and geographic computations.</p>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>The <code>Spherical</code> object contains utility functions for calculating distances, headings, and positions on Earth’s surface. It uses the spherical Earth model with Earth’s radius based on the WGS84 ellipsoid.</p>
<pre><code class="language-kotlin">import com.mapconductor.core.spherical.Spherical
</code></pre>
<h2 id="core-constants"><a class="header" href="#core-constants">Core Constants</a></h2>
<ul>
<li><strong>Earth Radius</strong>: 6,378,137 meters (WGS84 ellipsoid semi-major axis)</li>
<li><strong>Coordinate System</strong>: WGS84 geographic coordinates (latitude/longitude)</li>
</ul>
<h2 id="distance-calculations"><a class="header" href="#distance-calculations">Distance Calculations</a></h2>
<h3 id="distance-between-points-1"><a class="header" href="#distance-between-points-1">Distance Between Points</a></h3>
<pre><code class="language-kotlin">fun computeDistanceBetween(from: GeoPoint, to: GeoPoint): Double
</code></pre>
<p>Calculate the shortest distance between two points using the haversine formula:</p>
<pre><code class="language-kotlin">val sanFrancisco = GeoPointImpl.fromLatLong(37.7749, -122.4194)
val newYork = GeoPointImpl.fromLatLong(40.7128, -74.0060)

val distanceMeters = Spherical.computeDistanceBetween(sanFrancisco, newYork)
val distanceKm = distanceMeters / 1000.0
val distanceMiles = distanceMeters / 1609.344

println("Distance: ${distanceKm.toInt()} km (${distanceMiles.toInt()} miles)")
</code></pre>
<h3 id="path-length"><a class="header" href="#path-length">Path Length</a></h3>
<pre><code class="language-kotlin">fun computeLength(path: List&lt;GeoPoint&gt;): Double
</code></pre>
<p>Calculate the total length of a path consisting of multiple points:</p>
<pre><code class="language-kotlin">val routePoints = listOf(
    GeoPointImpl.fromLatLong(37.7749, -122.4194), // San Francisco
    GeoPointImpl.fromLatLong(37.7849, -122.4094), // North Beach
    GeoPointImpl.fromLatLong(37.7949, -122.3994), // Russian Hill
    GeoPointImpl.fromLatLong(37.8049, -122.3894)  // Fisherman's Wharf
)

val totalDistance = Spherical.computeLength(routePoints)
println("Route length: ${(totalDistance / 1000).toInt()} km")
</code></pre>
<h2 id="direction-and-heading"><a class="header" href="#direction-and-heading">Direction and Heading</a></h2>
<h3 id="bearing-calculation"><a class="header" href="#bearing-calculation">Bearing Calculation</a></h3>
<pre><code class="language-kotlin">fun computeHeading(from: GeoPoint, to: GeoPoint): Double
</code></pre>
<p>Calculate the initial bearing (direction) from one point to another:</p>
<pre><code class="language-kotlin">val start = GeoPointImpl.fromLatLong(37.7749, -122.4194)
val destination = GeoPointImpl.fromLatLong(40.7128, -74.0060)

val bearing = Spherical.computeHeading(start, destination)
println("Head ${bearing.toInt()}° from San Francisco to reach New York")

// Convert to compass direction
val compassDirection = when {
    bearing &gt;= -22.5 &amp;&amp; bearing &lt; 22.5 -&gt; "North"
    bearing &gt;= 22.5 &amp;&amp; bearing &lt; 67.5 -&gt; "Northeast"
    bearing &gt;= 67.5 &amp;&amp; bearing &lt; 112.5 -&gt; "East"
    bearing &gt;= 112.5 &amp;&amp; bearing &lt; 157.5 -&gt; "Southeast"
    bearing &gt;= 157.5 || bearing &lt; -157.5 -&gt; "South"
    bearing &gt;= -157.5 &amp;&amp; bearing &lt; -112.5 -&gt; "Southwest"
    bearing &gt;= -112.5 &amp;&amp; bearing &lt; -67.5 -&gt; "West"
    else -&gt; "Northwest"
}
</code></pre>
<h2 id="position-calculation"><a class="header" href="#position-calculation">Position Calculation</a></h2>
<h3 id="offset-from-point"><a class="header" href="#offset-from-point">Offset from Point</a></h3>
<pre><code class="language-kotlin">fun computeOffset(origin: GeoPoint, distance: Double, heading: Double): GeoPointImpl
</code></pre>
<p>Calculate a new position given distance and direction from an origin:</p>
<pre><code class="language-kotlin">val origin = GeoPointImpl.fromLatLong(37.7749, -122.4194)

// Points around the origin
val north1km = Spherical.computeOffset(origin, 1000.0, 0.0)   // 1km north
val east1km = Spherical.computeOffset(origin, 1000.0, 90.0)   // 1km east
val south1km = Spherical.computeOffset(origin, 1000.0, 180.0) // 1km south
val west1km = Spherical.computeOffset(origin, 1000.0, 270.0)  // 1km west

// Create a square around the origin
val squarePoints = listOf(north1km, east1km, south1km, west1km, north1km)
</code></pre>
<h3 id="reverse-calculation"><a class="header" href="#reverse-calculation">Reverse Calculation</a></h3>
<pre><code class="language-kotlin">fun computeOffsetOrigin(to: GeoPoint, distance: Double, heading: Double): GeoPointImpl?
</code></pre>
<p>Calculate the origin point given destination, distance, and original heading:</p>
<pre><code class="language-kotlin">val destination = GeoPointImpl.fromLatLong(37.7849, -122.4094)
val distance = 1000.0  // 1km
val originalHeading = 45.0  // Northeast

val origin = Spherical.computeOffsetOrigin(destination, distance, originalHeading)
origin?.let { point -&gt;
    println("Started from: ${point.latitude}, ${point.longitude}")
}
</code></pre>
<h2 id="interpolation-1"><a class="header" href="#interpolation-1">Interpolation</a></h2>
<h3 id="great-circle-interpolation"><a class="header" href="#great-circle-interpolation">Great Circle Interpolation</a></h3>
<pre><code class="language-kotlin">fun interpolate(from: GeoPoint, to: GeoPoint, fraction: Double): GeoPointImpl
</code></pre>
<p>Interpolate along the great circle path between two points:</p>
<pre><code class="language-kotlin">val start = GeoPointImpl.fromLatLong(37.7749, -122.4194)
val end = GeoPointImpl.fromLatLong(40.7128, -74.0060)

// Create waypoints along the great circle route
val waypoints = (0..10).map { i -&gt;
    val fraction = i / 10.0
    Spherical.interpolate(start, end, fraction)
}

// Use in a route animation
@Composable
fun AnimatedRoute() {
    var currentWaypoint by remember { mutableStateOf(0) }

    LaunchedEffect(Unit) {
        while (currentWaypoint &lt; waypoints.size - 1) {
            delay(1000)
            currentWaypoint++
        }
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    MapView(state = mapViewState) {
        // Show route
        Polyline(
            points = waypoints,
            strokeColor = Color.Blue,
            strokeWidth = 3.dp
        )

        // Moving marker
        if (currentWaypoint &lt; waypoints.size) {
            Marker(
                position = waypoints[currentWaypoint],
                icon = DefaultIcon(fillColor = Color.Red)
            )
        }
    }
}
</code></pre>
<h3 id="linear-interpolation-1"><a class="header" href="#linear-interpolation-1">Linear Interpolation</a></h3>
<pre><code class="language-kotlin">fun linearInterpolate(from: GeoPoint, to: GeoPoint, fraction: Double): GeoPointImpl
</code></pre>
<p>Fast linear interpolation without considering Earth’s curvature:</p>
<pre><code class="language-kotlin">val start = GeoPointImpl.fromLatLong(37.7749, -122.4194)
val end = GeoPointImpl.fromLatLong(37.7849, -122.4094)  // Short distance

// For small distances, linear interpolation is faster and sufficiently accurate
val midpoint = Spherical.linearInterpolate(start, end, 0.5)
</code></pre>
<h2 id="area-calculations"><a class="header" href="#area-calculations">Area Calculations</a></h2>
<h3 id="polygon-area"><a class="header" href="#polygon-area">Polygon Area</a></h3>
<pre><code class="language-kotlin">fun computeArea(path: List&lt;GeoPoint&gt;): Double
fun computeSignedArea(path: List&lt;GeoPoint&gt;): Double
</code></pre>
<p>Calculate the area of a closed polygon:</p>
<pre><code class="language-kotlin">val polygonPoints = listOf(
    GeoPointImpl.fromLatLong(37.7749, -122.4194),
    GeoPointImpl.fromLatLong(37.7849, -122.4094),
    GeoPointImpl.fromLatLong(37.7849, -122.4294),
    GeoPointImpl.fromLatLong(37.7749, -122.4294),
    GeoPointImpl.fromLatLong(37.7749, -122.4194)  // Close the polygon
)

val area = Spherical.computeArea(polygonPoints)
val areaKm2 = area / 1_000_000  // Convert to square kilometers

println("Polygon area: ${areaKm2.toInt()} km²")

// Signed area tells you orientation
val signedArea = Spherical.computeSignedArea(polygonPoints)
val orientation = if (signedArea &gt; 0) "Counter-clockwise" else "Clockwise"
println("Polygon orientation: $orientation")
</code></pre>
<h2 id="practical-examples-2"><a class="header" href="#practical-examples-2">Practical Examples</a></h2>
<h3 id="proximity-detection-1"><a class="header" href="#proximity-detection-1">Proximity Detection</a></h3>
<pre><code class="language-kotlin">@Composable
fun ProximityAlert() {
    val targetLocation = GeoPointImpl.fromLatLong(37.7749, -122.4194)
    val alertRadius = 500.0  // 500 meters

    var userLocation by remember { mutableStateOf&lt;GeoPoint?&gt;(null) }
    var isNearTarget by remember { mutableStateOf(false) }

    // Update proximity when user location changes
    LaunchedEffect(userLocation) {
        userLocation?.let { location -&gt;
            val distance = Spherical.computeDistanceBetween(location, targetLocation)
            isNearTarget = distance &lt;= alertRadius
        }
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    MapView(state = mapViewState) {
        // Target location
        Marker(
            position = targetLocation,
            icon = DefaultIcon(
                fillColor = if (isNearTarget) Color.Green else Color.Red,
                label = "Target"
            )
        )

        // Alert radius
        Circle(
            center = targetLocation,
            radius = alertRadius,
            strokeColor = Color.Blue,
            fillColor = Color.Blue.copy(alpha = 0.2f)
        )

        // User location if available
        userLocation?.let { location -&gt;
            Marker(
                position = location,
                icon = DefaultIcon(fillColor = Color.Blue, label = "You")
            )
        }
    }

    if (isNearTarget) {
        Text(
            text = "You are near the target!",
            color = Color.Green,
            fontWeight = FontWeight.Bold
        )
    }
}
</code></pre>
<h3 id="route-progress-tracking"><a class="header" href="#route-progress-tracking">Route Progress Tracking</a></h3>
<pre><code class="language-kotlin">@Composable
fun RouteProgress() {
    val route = listOf(
        GeoPointImpl.fromLatLong(37.7749, -122.4194),
        GeoPointImpl.fromLatLong(37.7849, -122.4094),
        GeoPointImpl.fromLatLong(37.7949, -122.3994)
    )

    var currentPosition by remember { mutableStateOf(route.first()) }
    val totalDistance = Spherical.computeLength(route)

    // Calculate progress along route
    fun calculateProgress(position: GeoPoint): Double {
        var distanceToPosition = 0.0
        var minDistanceToRoute = Double.MAX_VALUE
        var bestSegmentProgress = 0.0

        // Find closest point on route
        for (i in 0 until route.size - 1) {
            val segmentStart = route[i]
            val segmentEnd = route[i + 1]
            val segmentLength = Spherical.computeDistanceBetween(segmentStart, segmentEnd)

            // Find closest point on this segment
            var closestFraction = 0.0
            var minSegmentDistance = Double.MAX_VALUE

            for (fraction in 0..100) {
                val testFraction = fraction / 100.0
                val testPoint = Spherical.interpolate(segmentStart, segmentEnd, testFraction)
                val distance = Spherical.computeDistanceBetween(position, testPoint)

                if (distance &lt; minSegmentDistance) {
                    minSegmentDistance = distance
                    closestFraction = testFraction
                }
            }

            if (minSegmentDistance &lt; minDistanceToRoute) {
                minDistanceToRoute = minSegmentDistance
                bestSegmentProgress = distanceToPosition + (segmentLength * closestFraction)
            }

            distanceToPosition += segmentLength
        }

        return bestSegmentProgress / totalDistance
    }

    val progress = calculateProgress(currentPosition)

    Column {
        Text("Route Progress: ${(progress * 100).toInt()}%")
        LinearProgressIndicator(progress = progress.toFloat())

        // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
        MapView(state = mapViewState) {
            // Show route
            Polyline(
                points = route,
                strokeColor = Color.Blue,
                strokeWidth = 4.dp
            )

            // Current position
            Marker(
                position = currentPosition,
                icon = DefaultIcon(fillColor = Color.Red, label = "Current")
            )
        }
    }
}
</code></pre>
<h3 id="geofencing"><a class="header" href="#geofencing">Geofencing</a></h3>
<pre><code class="language-kotlin">@Composable
fun GeofenceExample() {
    val geofenceCenter = GeoPointImpl.fromLatLong(37.7749, -122.4194)
    val geofenceRadius = 1000.0  // 1km

    var userLocation by remember { mutableStateOf&lt;GeoPoint?&gt;(null) }
    var insideGeofence by remember { mutableStateOf(false) }

    // Check geofence status
    LaunchedEffect(userLocation) {
        userLocation?.let { location -&gt;
            val distance = Spherical.computeDistanceBetween(location, geofenceCenter)
            insideGeofence = distance &lt;= geofenceRadius
        }
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    MapView(state = mapViewState) {
        // Geofence boundary
        Circle(
            center = geofenceCenter,
            radius = geofenceRadius,
            strokeColor = if (insideGeofence) Color.Green else Color.Red,
            strokeWidth = 3.dp,
            fillColor = Color.Blue.copy(alpha = 0.1f)
        )

        userLocation?.let { location -&gt;
            Marker(
                position = location,
                icon = DefaultIcon(
                    fillColor = if (insideGeofence) Color.Green else Color.Red,
                    label = if (insideGeofence) "Inside" else "Outside"
                )
            )
        }
    }
}
</code></pre>
<h2 id="performance-considerations-2"><a class="header" href="#performance-considerations-2">Performance Considerations</a></h2>
<ol>
<li><strong>Choose Appropriate Method</strong>: Use <code>linearInterpolate</code> for short distances and frequent calculations</li>
<li><strong>Cache Results</strong>: Store computed distances and bearings when possible</li>
<li><strong>Batch Calculations</strong>: Process multiple points together to reduce function call overhead</li>
<li><strong>Precision vs Performance</strong>: Consider if full spherical accuracy is needed for your use case</li>
</ol>
<h2 id="best-practices-17"><a class="header" href="#best-practices-17">Best Practices</a></h2>
<ol>
<li><strong>Coordinate Validation</strong>: Ensure input coordinates are valid before calculations</li>
<li><strong>Error Handling</strong>: Check for null results from <code>computeOffsetOrigin</code></li>
<li><strong>Unit Consistency</strong>: All distances are in meters, all angles in degrees</li>
<li><strong>Earth Model</strong>: Remember this uses spherical Earth model, not the more accurate ellipsoidal model</li>
<li><strong>Precision</strong>: Results are accurate for most mapping applications but may have small errors for high-precision surveying</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mapviewholder"><a class="header" href="#mapviewholder">MapViewHolder</a></h1>
<p><code>MapViewHolder</code> provides access to the native map SDK instances for advanced use cases where MapConductor’s unified API doesn’t cover specific provider functionality. While MapConductor provides a common interface, it doesn’t completely wrap all native features, and MapViewHolder bridges this gap.</p>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p>MapConductor aims to provide a unified API across map providers, but complete feature parity is not always possible. MapViewHolder allows developers to access the underlying native map instances when they need provider-specific functionality.</p>
<pre><code class="language-kotlin">interface MapViewHolder&lt;ActualMapViewType, ActualMapType&gt; {
    val mapView: ActualMapViewType
    val map: ActualMapType
}
</code></pre>
<h2 id="accessing-mapviewholder"><a class="header" href="#accessing-mapviewholder">Accessing MapViewHolder</a></h2>
<p>Each map provider’s <code>MapViewState</code> implementation provides access to its specific <code>MapViewHolder</code>:</p>
<pre><code class="language-kotlin">// Google Maps
val googleMapState = GoogleMapViewStateImpl()
val googleHolder: GoogleMapViewHolder? = googleMapState.getMapViewHolder()

// Mapbox
val mapboxState = MapboxViewStateImpl()
val mapboxHolder: MapboxMapViewHolder? = mapboxState.getMapViewHolder()

// HERE Maps
val hereState = HereViewStateImpl()
val hereHolder: HereViewHolder? = hereState.getMapViewHolder()

// ArcGIS
val arcgisState = ArcGISMapViewStateImpl()
val arcgisHolder: ArcGISMapViewHolder? = arcgisState.getMapViewHolder()
</code></pre>
<h2 id="provider-specific-implementations"><a class="header" href="#provider-specific-implementations">Provider-Specific Implementations</a></h2>
<h3 id="google-maps"><a class="header" href="#google-maps">Google Maps</a></h3>
<pre><code class="language-kotlin">typealias GoogleMapViewHolder = MapViewHolder&lt;MapView, GoogleMap&gt;

// Access native Google Maps APIs
googleHolder?.let { holder -&gt;
    val nativeMapView: MapView = holder.mapView
    val googleMap: GoogleMap = holder.map

    // Use Google Maps specific features
    googleMap.setMapStyle(MapStyleOptions.loadRawResourceStyle(context, R.raw.style_json))
    googleMap.setOnPoiClickListener { poi -&gt;
        // Handle Points of Interest clicks
    }

    nativeMapView.onResume()
    nativeMapView.onPause()
}
</code></pre>
<h3 id="mapbox"><a class="header" href="#mapbox">Mapbox</a></h3>
<pre><code class="language-kotlin">typealias MapboxMapViewHolder = MapViewHolder&lt;MapView, MapboxMap&gt;

// Access native Mapbox APIs
mapboxHolder?.let { holder -&gt;
    val mapboxMapView: MapView = holder.mapView
    val mapboxMap: MapboxMap = holder.map

    // Use Mapbox specific features
    mapboxMap.getStyle { style -&gt;
        style.addSource(GeoJsonSource("custom-source", geoJsonData))
        style.addLayer(FillLayer("custom-layer", "custom-source"))
    }

    // Access Mapbox plugins
    val locationComponent = mapboxMap.locationComponent
    locationComponent.activateLocationComponent(context)
}
</code></pre>
<h3 id="here-maps"><a class="header" href="#here-maps">HERE Maps</a></h3>
<pre><code class="language-kotlin">typealias HereViewHolder = MapViewHolder&lt;MapView, MapScene&gt;

// Access native HERE SDK APIs
hereHolder?.let { holder -&gt;
    val hereMapView: MapView = holder.mapView
    val mapScene: MapScene = holder.map

    // Use HERE specific features
    val searchEngine = SearchEngine()
    val textQuery = TextQuery("coffee shops", geoCoordinates)

    searchEngine.search(textQuery) { searchError, searchResults -&gt;
        // Handle HERE search results
    }

    // HERE routing
    val routingEngine = RoutingEngine()
    // Configure and use routing
}
</code></pre>
<h3 id="arcgis"><a class="header" href="#arcgis">ArcGIS</a></h3>
<pre><code class="language-kotlin">typealias ArcGISMapViewHolder = MapViewHolder&lt;WrapSceneView, SceneView&gt;

// Access native ArcGIS APIs
arcgisHolder?.let { holder -&gt;
    val wrapSceneView: WrapSceneView = holder.mapView
    val sceneView: SceneView = holder.map

    // Use ArcGIS specific features
    val portal = Portal("https://www.arcgis.com/")
    val portalItem = PortalItem(portal, "your-webmap-id")
    val webMap = ArcGISMap(portalItem)

    sceneView.map = webMap

    // ArcGIS analysis tools
    val serviceArea = ServiceAreaTask("https://route-api.arcgis.com/...")
    // Configure and use analysis
}
</code></pre>
<h2 id="common-use-cases-1"><a class="header" href="#common-use-cases-1">Common Use Cases</a></h2>
<h3 id="custom-styling"><a class="header" href="#custom-styling">Custom Styling</a></h3>
<pre><code class="language-kotlin">@Composable
fun CustomStyledMap() {
    val mapViewState = rememberGoogleMapViewState()

    LaunchedEffect(mapViewState) {
        // Wait for map initialization
        delay(1000)

        mapViewState.getMapViewHolder()?.let { holder -&gt;
            val googleMap = holder.map

            // Apply custom map style
            val styleJson = loadStyleFromAssets(context, "custom_style.json")
            googleMap.setMapStyle(MapStyleOptions(styleJson))

            // Configure map UI
            googleMap.uiSettings.isMyLocationButtonEnabled = false
            googleMap.uiSettings.isCompassEnabled = true
        }
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    GoogleMapsView(state = mapViewState) {
        // Your MapConductor components
    }
}
</code></pre>
<h3 id="advanced-analytics"><a class="header" href="#advanced-analytics">Advanced Analytics</a></h3>
<pre><code class="language-kotlin">@Composable
fun AnalyticsIntegration() {
    val mapViewState = remember { MapboxViewStateImpl() }

    LaunchedEffect(mapViewState) {
        mapViewState.getMapViewHolder()?.let { holder -&gt;
            val mapboxMap = holder.map

            // Track custom map events
            mapboxMap.addOnMapClickListener { point -&gt;
                Analytics.track("map_click", mapOf(
                    "lat" to point.latitude,
                    "lng" to point.longitude,
                    "zoom" to mapboxMap.cameraPosition.zoom
                ))
                true
            }

            // Track style changes
            mapboxMap.addOnStyleLoadedListener {
                Analytics.track("style_loaded", mapOf(
                    "style_id" to mapboxMap.style?.styleURI
                ))
            }
        }
    }

    MapboxMapView(state = mapViewState) {
        // Your MapConductor components
    }
}
</code></pre>
<h3 id="performance-optimization"><a class="header" href="#performance-optimization">Performance Optimization</a></h3>
<pre><code class="language-kotlin">@Composable
fun PerformanceOptimizedMap() {
    val mapViewState = remember { HereViewStateImpl() }

    LaunchedEffect(mapViewState) {
        mapViewState.getMapViewHolder()?.let { holder -&gt;
            val mapScene = holder.map

            // HERE-specific performance settings
            mapScene.setLayerVisibility(MapScene.Layers.TRAFFIC_FLOW, VisibilityState.VISIBLE)

            // Optimize for specific use case
            val mapSettings = mapScene.mapSettings
            mapSettings.isTiltGesturesEnabled = false
            mapSettings.isRotateGesturesEnabled = false

            // Custom level of detail settings
            mapScene.setLevelOfDetail(LevelOfDetail.HIGH)
        }
    }

    HereMapView(state = mapViewState) {
        // Your MapConductor components
    }
}
</code></pre>
<h3 id="integration-with-third-party-services"><a class="header" href="#integration-with-third-party-services">Integration with Third-Party Services</a></h3>
<pre><code class="language-kotlin">@Composable
fun ThirdPartyIntegration() {
    val mapViewState = rememberArcGISMapViewState()

    LaunchedEffect(mapViewState) {
        mapViewState.getMapViewHolder()?.let { holder -&gt;
            val sceneView = holder.map

            // Integrate with ArcGIS Online services
            val featureTable = ServiceFeatureTable("https://services.arcgis.com/...")
            val featureLayer = FeatureLayer(featureTable)

            sceneView.map.basemap.baseLayers.add(featureLayer)

            // Query features
            val queryParams = QueryParameters().apply {
                whereClause = "STATE_NAME = 'California'"
            }

            featureTable.queryFeaturesAsync(queryParams).addDoneListener {
                val results = it.result
                // Process feature query results
            }
        }
    }

    ArcGISMapView(state = mapViewState) {
        // Your MapConductor components
    }
}
</code></pre>
<h2 id="lifecycle-management-1"><a class="header" href="#lifecycle-management-1">Lifecycle Management</a></h2>
<h3 id="map-lifecycle-events"><a class="header" href="#map-lifecycle-events">Map Lifecycle Events</a></h3>
<pre><code class="language-kotlin">@Composable
fun LifecycleAwareMap() {
    val mapViewState = rememberGoogleMapViewState()
    val lifecycleOwner = LocalLifecycleOwner.current

    DisposableEffect(lifecycleOwner) {
        val observer = LifecycleEventObserver { _, event -&gt;
            mapViewState.getMapViewHolder()?.let { holder -&gt;
                val mapView = holder.mapView

                when (event) {
                    Lifecycle.Event.ON_RESUME -&gt; mapView.onResume()
                    Lifecycle.Event.ON_PAUSE -&gt; mapView.onPause()
                    Lifecycle.Event.ON_START -&gt; mapView.onStart()
                    Lifecycle.Event.ON_STOP -&gt; mapView.onStop()
                    Lifecycle.Event.ON_DESTROY -&gt; mapView.onDestroy()
                    else -&gt; { }
                }
            }
        }

        lifecycleOwner.lifecycle.addObserver(observer)
        onDispose {
            lifecycleOwner.lifecycle.removeObserver(observer)
        }
    }

    GoogleMapsView(state = mapViewState) {
        // Your MapConductor components
    }
}
</code></pre>
<h2 id="error-handling-and-safety"><a class="header" href="#error-handling-and-safety">Error Handling and Safety</a></h2>
<h3 id="null-safety"><a class="header" href="#null-safety">Null Safety</a></h3>
<pre><code class="language-kotlin">fun accessNativeMap(mapViewState: GoogleMapViewStateImpl) {
    val holder = mapViewState.getMapViewHolder()

    if (holder != null) {
        // Safe to access native APIs
        val googleMap = holder.map
        val mapView = holder.mapView

        // Use native features
        googleMap.setOnMarkerClickListener { marker -&gt;
            // Handle marker click
            true
        }
    } else {
        // Map not yet initialized or unavailable
        Log.w("MapAccess", "MapViewHolder not available")
    }
}
</code></pre>
<h3 id="initialization-timing"><a class="header" href="#initialization-timing">Initialization Timing</a></h3>
<pre><code class="language-kotlin">@Composable
fun SafeNativeAccess() {
    val mapViewState = remember { MapboxViewStateImpl() }
    var isMapReady by remember { mutableStateOf(false) }

    LaunchedEffect(mapViewState) {
        // Poll until map is ready
        while (!isMapReady) {
            delay(100)
            isMapReady = mapViewState.getMapViewHolder() != null
        }

        // Now safe to use native APIs
        mapViewState.getMapViewHolder()?.let { holder -&gt;
            val mapboxMap = holder.map
            // Configure native features
        }
    }

    MapboxMapView(state = mapViewState) {
        // Your MapConductor components
    }
}
</code></pre>
<h2 id="best-practices-18"><a class="header" href="#best-practices-18">Best Practices</a></h2>
<ol>
<li><strong>Initialization Check</strong>: Always check if <code>getMapViewHolder()</code> returns non-null before accessing native APIs</li>
<li><strong>Lifecycle Awareness</strong>: Properly handle map lifecycle events when using native APIs</li>
<li><strong>Error Handling</strong>: Wrap native API calls in try-catch blocks as provider APIs may throw exceptions</li>
<li><strong>Documentation</strong>: Refer to each provider’s official documentation for native API usage</li>
<li><strong>Testing</strong>: Test thoroughly across all target map providers when using native APIs</li>
<li><strong>Fallback</strong>: Provide fallback behavior when native features are unavailable</li>
<li><strong>Version Compatibility</strong>: Ensure native API usage is compatible with the SDK versions you’re targeting</li>
</ol>
<h2 id="limitations-and-considerations"><a class="header" href="#limitations-and-considerations">Limitations and Considerations</a></h2>
<ol>
<li><strong>Platform Dependency</strong>: Native API usage ties your code to specific map providers</li>
<li><strong>Maintenance Overhead</strong>: Provider API changes may require updates to native API usage</li>
<li><strong>Testing Complexity</strong>: More complex testing required to cover provider-specific code paths</li>
<li><strong>Feature Parity</strong>: Not all providers support equivalent native features</li>
<li><strong>MapConductor Integration</strong>: Native changes may not integrate with MapConductor’s state management</li>
</ol>
<p>MapViewHolder is a powerful escape hatch for advanced use cases, but should be used judiciously to maintain the benefits of MapConductor’s unified API approach.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zoom-levels-1"><a class="header" href="#zoom-levels-1">Zoom Levels</a></h1>
<p>MapConductor uses zoom levels to control the scale and detail of the map display. The zoom level system approximately follows Google Maps conventions but may vary slightly between map providers due to their underlying implementation differences.</p>
<h2 id="understanding-zoom-levels"><a class="header" href="#understanding-zoom-levels">Understanding Zoom Levels</a></h2>
<p>Zoom levels in MapConductor are represented as <code>Double</code> values, typically ranging from 0 to 21, where:</p>
<ul>
<li><strong>Higher numbers</strong> = More zoomed in (more detail, smaller area)</li>
<li><strong>Lower numbers</strong> = More zoomed out (less detail, larger area)</li>
<li><strong>Fractional values</strong> = Smooth interpolation between integer levels</li>
</ul>
<pre><code class="language-kotlin">// Examples of different zoom levels
val worldView = 2.0        // See continents
val countryView = 6.0      // See entire countries
val cityView = 10.0        // See cities
val streetView = 15.0      // See streets
val buildingView = 18.0    // See individual buildings
</code></pre>
<h2 id="zoom-level-reference"><a class="header" href="#zoom-level-reference">Zoom Level Reference</a></h2>
<h3 id="global-scale-0-5"><a class="header" href="#global-scale-0-5">Global Scale (0-5)</a></h3>
<pre><code class="language-kotlin">// World and continent level
val worldLevel = MapCameraPositionImpl(
    position = GeoPointImpl.fromLatLong(0.0, 0.0),
    zoom = 2.0  // Shows continents and oceans
)

val continentLevel = MapCameraPositionImpl(
    position = GeoPointImpl.fromLatLong(39.8283, -98.5795), // USA center
    zoom = 4.0  // Shows entire continent
)
</code></pre>
<p><strong>Use Cases:</strong></p>
<ul>
<li>Global data visualization</li>
<li>Continental overview</li>
<li>Flight tracking applications</li>
<li>World weather maps</li>
</ul>
<h3 id="regional-scale-6-9"><a class="header" href="#regional-scale-6-9">Regional Scale (6-9)</a></h3>
<pre><code class="language-kotlin">// Country and state level
val countryLevel = MapCameraPositionImpl(
    position = GeoPointImpl.fromLatLong(39.8283, -98.5795),
    zoom = 6.0  // Shows entire country
)

val stateLevel = MapCameraPositionImpl(
    position = GeoPointImpl.fromLatLong(36.7783, -119.4179), // California center
    zoom = 8.0  // Shows state or large region
)
</code></pre>
<p><strong>Use Cases:</strong></p>
<ul>
<li>National statistics</li>
<li>State-level data</li>
<li>Regional weather</li>
<li>Transportation networks</li>
</ul>
<h3 id="metropolitan-scale-10-12"><a class="header" href="#metropolitan-scale-10-12">Metropolitan Scale (10-12)</a></h3>
<pre><code class="language-kotlin">// City and metropolitan area level
val metropolitanLevel = MapCameraPositionImpl(
    position = GeoPointImpl.fromLatLong(37.7749, -122.4194), // San Francisco
    zoom = 10.0  // Shows metropolitan area
)

val cityLevel = MapCameraPositionImpl(
    position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
    zoom = 12.0  // Shows city center and suburbs
)
</code></pre>
<p><strong>Use Cases:</strong></p>
<ul>
<li>City planning</li>
<li>Public transportation</li>
<li>Delivery zones</li>
<li>District boundaries</li>
</ul>
<h3 id="neighborhood-scale-13-15"><a class="header" href="#neighborhood-scale-13-15">Neighborhood Scale (13-15)</a></h3>
<pre><code class="language-kotlin">// District and neighborhood level
val districtLevel = MapCameraPositionImpl(
    position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
    zoom = 13.0  // Shows districts
)

val neighborhoodLevel = MapCameraPositionImpl(
    position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
    zoom = 15.0  // Shows neighborhoods and major streets
)
</code></pre>
<p><strong>Use Cases:</strong></p>
<ul>
<li>Local business directories</li>
<li>School districts</li>
<li>Neighborhood services</li>
<li>Real estate search</li>
</ul>
<h3 id="street-scale-16-18"><a class="header" href="#street-scale-16-18">Street Scale (16-18)</a></h3>
<pre><code class="language-kotlin">// Street and block level
val streetLevel = MapCameraPositionImpl(
    position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
    zoom = 16.0  // Shows street layout
)

val detailedStreetLevel = MapCameraPositionImpl(
    position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
    zoom = 18.0  // Shows individual streets and small buildings
)
</code></pre>
<p><strong>Use Cases:</strong></p>
<ul>
<li>Navigation applications</li>
<li>Address lookup</li>
<li>Street-level services</li>
<li>Walking directions</li>
</ul>
<h3 id="building-scale-19-21"><a class="header" href="#building-scale-19-21">Building Scale (19-21)</a></h3>
<pre><code class="language-kotlin">// Building and detail level
val buildingLevel = MapCameraPositionImpl(
    position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
    zoom = 19.0  // Shows individual buildings
)

val maximumDetail = MapCameraPositionImpl(
    position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
    zoom = 21.0  // Maximum zoom level
)
</code></pre>
<p><strong>Use Cases:</strong></p>
<ul>
<li>Building inspection</li>
<li>Asset management</li>
<li>Indoor mapping</li>
<li>Detailed surveying</li>
</ul>
<h2 id="provider-variations"><a class="header" href="#provider-variations">Provider Variations</a></h2>
<p>While MapConductor normalizes zoom levels across providers, there can be subtle differences:</p>
<h3 id="google-maps-1"><a class="header" href="#google-maps-1">Google Maps</a></h3>
<ul>
<li>Closely follows the reference scale</li>
<li>Smooth fractional zoom support</li>
<li>Range: 0-21</li>
</ul>
<h3 id="mapbox-1"><a class="header" href="#mapbox-1">Mapbox</a></h3>
<ul>
<li>Similar to Google Maps</li>
<li>Excellent fractional zoom interpolation</li>
<li>Range: 0-22 (may vary by style)</li>
</ul>
<h3 id="here-maps-1"><a class="header" href="#here-maps-1">HERE Maps</a></h3>
<ul>
<li>Comparable scale with minor variations</li>
<li>Good fractional zoom support</li>
<li>Range: 0-20</li>
</ul>
<h3 id="arcgis-1"><a class="header" href="#arcgis-1">ArcGIS</a></h3>
<ul>
<li>May have different detail levels at equivalent zoom</li>
<li>Scene view (3D) may behave differently</li>
<li>Range varies by basemap</li>
</ul>
<h2 id="dynamic-zoom-selection"><a class="header" href="#dynamic-zoom-selection">Dynamic Zoom Selection</a></h2>
<h3 id="content-based-zoom"><a class="header" href="#content-based-zoom">Content-Based Zoom</a></h3>
<pre><code class="language-kotlin">@Composable
fun ContentBasedZoom() {
    val markers = remember {
        listOf(
            GeoPointImpl.fromLatLong(37.7749, -122.4194),
            GeoPointImpl.fromLatLong(37.7849, -122.4094),
            GeoPointImpl.fromLatLong(37.7949, -122.3994)
        )
    }

    // Calculate bounds containing all markers
    val bounds = GeoRectBounds()
    markers.forEach { bounds.extend(it) }

    // Select appropriate zoom for content
    val appropriateZoom = when {
        bounds.isEmpty -&gt; 15.0  // Default for single point
        else -&gt; {
            val span = bounds.toSpan()
            when {
                span?.latitude ?: 0.0 &gt; 10.0 -&gt; 4.0   // Large area
                span?.latitude ?: 0.0 &gt; 1.0 -&gt; 8.0    // Medium area
                span?.latitude ?: 0.0 &gt; 0.1 -&gt; 12.0   // Small area
                span?.latitude ?: 0.0 &gt; 0.01 -&gt; 16.0  // Very small area
                else -&gt; 18.0                          // Minimal area
            }
        }
    }

    val cameraPosition = MapCameraPositionImpl(
        position = bounds.center ?: markers.first(),
        zoom = appropriateZoom
    )

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    MapView(
        state = mapViewState,
        cameraPosition = cameraPosition
    ) {
        markers.forEach { position -&gt;
            Marker(
                position = position,
                icon = DefaultIcon(fillColor = Color.Blue)
            )
        }
    }
}
</code></pre>
<h3 id="user-controlled-zoom"><a class="header" href="#user-controlled-zoom">User-Controlled Zoom</a></h3>
<pre><code class="language-kotlin">@Composable
fun ZoomControls() {
    var currentZoom by remember { mutableStateOf(15.0) }
    val center = GeoPointImpl.fromLatLong(37.7749, -122.4194)

    Column {
        // Zoom level display
        Text("Zoom Level: ${String.format("%.1f", currentZoom)}")

        // Zoom controls
        Row {
            Button(
                onClick = { currentZoom = (currentZoom + 1).coerceAtMost(21.0) }
            ) {
                Text("+")
            }

            Button(
                onClick = { currentZoom = (currentZoom - 1).coerceAtLeast(0.0) }
            ) {
                Text("-")
            }
        }

        // Preset zoom buttons
        Row {
            Button(onClick = { currentZoom = 12.0 }) { Text("City") }
            Button(onClick = { currentZoom = 15.0 }) { Text("Street") }
            Button(onClick = { currentZoom = 18.0 }) { Text("Building") }
        }

        // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
        MapView(
            state = mapViewState,
            cameraPosition = MapCameraPositionImpl(
                position = center,
                zoom = currentZoom
            )
        ) {
            Marker(
                position = center,
                icon = DefaultIcon(fillColor = Color.Red)
            )
        }
    }
}
</code></pre>
<h2 id="adaptive-zoom-strategies"><a class="header" href="#adaptive-zoom-strategies">Adaptive Zoom Strategies</a></h2>
<h3 id="performance-based-zoom"><a class="header" href="#performance-based-zoom">Performance-Based Zoom</a></h3>
<pre><code class="language-kotlin">@Composable
fun PerformanceAdaptiveZoom() {
    val markerCount = 1000
    var displayedMarkers by remember { mutableStateOf&lt;List&lt;GeoPoint&gt;&gt;(emptyList()) }

    val cameraPosition = MapCameraPositionImpl(
        position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
        zoom = 12.0
    )

    LaunchedEffect(cameraPosition) {
        // Adapt marker display based on zoom level
        displayedMarkers = when {
            cameraPosition.zoom &lt; 8.0 -&gt; {
                // Very low zoom: show only major markers
                allMarkers.filter { it.importance &gt; 0.8 }
            }
            cameraPosition.zoom &lt; 12.0 -&gt; {
                // Medium zoom: show important markers
                allMarkers.filter { it.importance &gt; 0.5 }
            }
            cameraPosition.zoom &lt; 16.0 -&gt; {
                // High zoom: show most markers
                allMarkers.filter { it.importance &gt; 0.2 }
            }
            else -&gt; {
                // Maximum zoom: show all markers
                allMarkers
            }
        }
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    MapView(
        state = mapViewState,
        cameraPosition = cameraPosition
    ) {
        displayedMarkers.forEach { marker -&gt;
            Marker(
                position = marker,
                icon = DefaultIcon(
                    scale = when {
                        cameraPosition.zoom &lt; 10.0 -&gt; 1.2f
                        cameraPosition.zoom &lt; 15.0 -&gt; 1.0f
                        else -&gt; 0.8f
                    }
                )
            )
        }
    }
}
</code></pre>
<h3 id="context-aware-zoom"><a class="header" href="#context-aware-zoom">Context-Aware Zoom</a></h3>
<pre><code class="language-kotlin">@Composable
fun ContextAwareZoom() {
    val userLocation = GeoPointImpl.fromLatLong(37.7749, -122.4194)
    val searchResults = remember { /* your search results */ }

    // Select zoom based on context
    val contextualZoom = when {
        searchResults.isEmpty() -&gt; 15.0  // User location focus
        searchResults.size == 1 -&gt; 16.0  // Single result
        searchResults.size &lt; 5 -&gt; 14.0   // Few results
        else -&gt; {
            // Calculate appropriate zoom for all results
            val bounds = GeoRectBounds()
            searchResults.forEach { bounds.extend(it.location) }
            calculateZoomForBounds(bounds)
        }
    }

    val cameraPosition = MapCameraPositionImpl(
        position = if (searchResults.isEmpty()) userLocation else bounds.center!!,
        zoom = contextualZoom
    )

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    MapView(
        state = mapViewState,
        cameraPosition = cameraPosition
    ) {
        // User location
        Marker(
            position = userLocation,
            icon = DefaultIcon(fillColor = Color.Blue, label = "You")
        )

        // Search results
        searchResults.forEach { result -&gt;
            Marker(
                position = result.location,
                icon = DefaultIcon(fillColor = Color.Red)
            )
        }
    }
}
</code></pre>
<h2 id="best-practices-19"><a class="header" href="#best-practices-19">Best Practices</a></h2>
<h3 id="zoom-level-selection"><a class="header" href="#zoom-level-selection">Zoom Level Selection</a></h3>
<ol>
<li><strong>Content-Driven</strong>: Choose zoom based on what you want to show</li>
<li><strong>User Context</strong>: Consider user’s current task and location</li>
<li><strong>Performance</strong>: Higher zoom levels require more detail rendering</li>
<li><strong>Provider Limitations</strong>: Test across all target map providers</li>
</ol>
<h3 id="smooth-transitions"><a class="header" href="#smooth-transitions">Smooth Transitions</a></h3>
<pre><code class="language-kotlin">// Smooth zoom animation
fun animateToZoom(targetZoom: Double) {
    val animator = ValueAnimator.ofFloat(currentZoom.toFloat(), targetZoom.toFloat())
    animator.duration = 1000
    animator.addUpdateListener { animation -&gt;
        val newZoom = animation.animatedValue as Float
        updateCameraPosition(currentPosition.copy(zoom = newZoom.toDouble()))
    }
    animator.start()
}
</code></pre>
<h3 id="responsive-design"><a class="header" href="#responsive-design">Responsive Design</a></h3>
<pre><code class="language-kotlin">@Composable
fun ResponsiveZoom() {
    val configuration = LocalConfiguration.current
    val isTablet = configuration.screenWidthDp &gt;= 600

    // Adjust zoom for screen size
    val baseZoom = if (isTablet) 14.0 else 16.0

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    MapView(
        state = mapViewState,
        cameraPosition = MapCameraPositionImpl(
            position = center,
            zoom = baseZoom
        )
    ) {
        // Content
    }
}
</code></pre>
<h2 id="common-pitfalls"><a class="header" href="#common-pitfalls">Common Pitfalls</a></h2>
<ol>
<li><strong>Provider Inconsistency</strong>: Test zoom levels across all target providers</li>
<li><strong>Performance Impact</strong>: Higher zoom levels increase rendering cost</li>
<li><strong>Fractional Zoom</strong>: Not all providers handle fractional zoom identically</li>
<li><strong>Minimum/Maximum</strong>: Respect provider-specific zoom limits</li>
<li><strong>Gesture Conflicts</strong>: Consider user zoom gestures vs programmatic zoom</li>
</ol>
<h2 id="testing-zoom-levels"><a class="header" href="#testing-zoom-levels">Testing Zoom Levels</a></h2>
<pre><code class="language-kotlin">@Composable
fun ZoomLevelTester() {
    val testZoomLevels = listOf(0.0, 5.0, 10.0, 15.0, 20.0)
    var currentTestIndex by remember { mutableStateOf(0) }

    Column {
        Text("Testing Zoom Level: ${testZoomLevels[currentTestIndex]}")

        Button(
            onClick = {
                currentTestIndex = (currentTestIndex + 1) % testZoomLevels.size
            }
        ) {
            Text("Next Zoom Level")
        }

        // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
        MapView(
            state = mapViewState,
            cameraPosition = MapCameraPositionImpl(
                position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
                zoom = testZoomLevels[currentTestIndex]
            )
        ) {
            Marker(
                position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
                icon = DefaultIcon(fillColor = Color.Red)
            )
        }
    }
}
</code></pre>
<p>Understanding and properly utilizing zoom levels is crucial for creating effective mapping applications that provide the right level of detail for your users’ needs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="marker-icons"><a class="header" href="#marker-icons">Marker Icons</a></h1>
<p>MapConductor provides several marker icon types to customize the appearance of markers on the map. All marker icons implement the <code>MarkerIcon</code> interface and can be used with any map provider.</p>
<h2 id="markericon-interface"><a class="header" href="#markericon-interface">MarkerIcon Interface</a></h2>
<p>The base interface for all marker icons:</p>
<pre><code class="language-kotlin">interface MarkerIcon {
    // Common properties for all marker icon implementations
}
</code></pre>
<h2 id="icon-types-1"><a class="header" href="#icon-types-1">Icon Types</a></h2>
<h3 id="defaulticon-colordefaulticon"><a class="header" href="#defaulticon-colordefaulticon">DefaultIcon (ColorDefaultIcon)</a></h3>
<p>The standard colored marker icon with customizable appearance and text labels.</p>
<blockquote>
<p><strong>Note</strong>: <code>DefaultIcon</code> is an alias for <code>ColorDefaultIcon</code>.</p>
</blockquote>
<pre><code class="language-kotlin">DefaultIcon(
    scale: Float = 1.0f,
    label: String? = null,
    fillColor: Color = Color.Red,
    strokeColor: Color = Color.Black,
    strokeWidth: Dp = 1.dp,
    labelTextColor: Color = Color.White,
    labelStrokeColor: Color? = null,
    debug: Boolean = false
)
</code></pre>
<h4 id="parameters-6"><a class="header" href="#parameters-6">Parameters</a></h4>
<ul>
<li><strong><code>scale</code></strong>: Size multiplier for the icon (1.0 = normal size, 0.5 = half size, 2.0 = double size)</li>
<li><strong><code>label</code></strong>: Text displayed on the marker (optional)</li>
<li><strong><code>fillColor</code></strong>: Background color of the marker</li>
<li><strong><code>strokeColor</code></strong>: Border color of the marker</li>
<li><strong><code>strokeWidth</code></strong>: Width of the border</li>
<li><strong><code>labelTextColor</code></strong>: Color of the label text</li>
<li><strong><code>labelStrokeColor</code></strong>: Optional outline color for label text</li>
<li><strong><code>debug</code></strong>: Shows debug information when enabled</li>
</ul>
<h4 id="usage-examples-12"><a class="header" href="#usage-examples-12">Usage Examples</a></h4>
<pre><code class="language-kotlin">// Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
    // Basic red marker
    Marker(
        position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
        icon = DefaultIcon()
    )

    // Custom colored marker with label
    Marker(
        position = GeoPointImpl.fromLatLong(37.7849, -122.4094),
        icon = DefaultIcon(
            scale = 1.2f,
            label = "SF",
            fillColor = Color.Blue,
            strokeColor = Color.White,
            strokeWidth = 2.dp
        )
    )

    // Small marker with custom styling
    Marker(
        position = GeoPointImpl.fromLatLong(37.7649, -122.4294),
        icon = DefaultIcon(
            scale = 0.8f,
            fillColor = Color.Green,
            labelTextColor = Color.Black,
            label = "POI"
        )
    )
}
</code></pre>
<h3 id="drawabledefaulticon-1"><a class="header" href="#drawabledefaulticon-1">DrawableDefaultIcon</a></h3>
<p>Uses a drawable resource as the background for the marker, with optional styling overlays.</p>
<pre><code class="language-kotlin">DrawableDefaultIcon(
    backgroundDrawable: Drawable,
    scale: Float = 1.0f,
    strokeColor: Color? = null,
    strokeWidth: Dp = 1.dp
)
</code></pre>
<h4 id="parameters-7"><a class="header" href="#parameters-7">Parameters</a></h4>
<ul>
<li><strong><code>backgroundDrawable</code></strong>: The drawable resource used as the marker background</li>
<li><strong><code>scale</code></strong>: Size multiplier for the icon</li>
<li><strong><code>strokeColor</code></strong>: Optional border color overlay</li>
<li><strong><code>strokeWidth</code></strong>: Width of the border overlay</li>
</ul>
<h4 id="usage-examples-13"><a class="header" href="#usage-examples-13">Usage Examples</a></h4>
<pre><code class="language-kotlin">@Composable
fun DrawableIconExamples() {
    val context = LocalContext.current

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    MapView(state = mapViewState) {
        // Custom drawable marker
        AppCompatResources.getDrawable(context, R.drawable.custom_marker)?.let { drawable -&gt;
            Marker(
                position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
                icon = DrawableDefaultIcon(
                    backgroundDrawable = drawable,
                    scale = 1.0f
                )
            )
        }

        // Drawable with custom border
        AppCompatResources.getDrawable(context, R.drawable.pin_icon)?.let { drawable -&gt;
            Marker(
                position = GeoPointImpl.fromLatLong(37.7849, -122.4094),
                icon = DrawableDefaultIcon(
                    backgroundDrawable = drawable,
                    scale = 1.5f,
                    strokeColor = Color.Yellow,
                    strokeWidth = 3.dp
                )
            )
        }
    }
}
</code></pre>
<h3 id="imagedefaulticon"><a class="header" href="#imagedefaulticon">ImageDefaultIcon</a></h3>
<p>Uses a custom image drawable with precise anchor positioning control.</p>
<pre><code class="language-kotlin">ImageDefaultIcon(
    drawable: Drawable,
    anchor: Offset = Offset(0.5f, 0.5f),
    debug: Boolean = false
)
</code></pre>
<h4 id="parameters-8"><a class="header" href="#parameters-8">Parameters</a></h4>
<ul>
<li><strong><code>drawable</code></strong>: The image drawable to display</li>
<li><strong><code>anchor</code></strong>: Anchor point relative to the image (0.0-1.0 range)
<ul>
<li><code>Offset(0.5f, 0.5f)</code>: Center anchor (default)</li>
<li><code>Offset(0.5f, 1.0f)</code>: Bottom center anchor</li>
<li><code>Offset(0.0f, 0.0f)</code>: Top left anchor</li>
<li><code>Offset(1.0f, 1.0f)</code>: Bottom right anchor</li>
</ul>
</li>
<li><strong><code>debug</code></strong>: Shows debug anchor visualization</li>
</ul>
<h4 id="usage-examples-14"><a class="header" href="#usage-examples-14">Usage Examples</a></h4>
<pre><code class="language-kotlin">@Composable
fun ImageIconExamples() {
    val context = LocalContext.current

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    MapView(state = mapViewState) {
        // Weather station icon with bottom center anchor
        AppCompatResources.getDrawable(context, R.drawable.weather_station)?.let { icon -&gt;
            Marker(
                position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
                icon = ImageDefaultIcon(
                    drawable = icon,
                    anchor = Offset(0.5f, 1.0f), // Bottom center
                    debug = false
                )
            )
        }

        // Direction arrow with center anchor
        AppCompatResources.getDrawable(context, R.drawable.direction_arrow)?.let { icon -&gt;
            Marker(
                position = GeoPointImpl.fromLatLong(37.7849, -122.4094),
                icon = ImageDefaultIcon(
                    drawable = icon,
                    anchor = Offset(0.5f, 0.5f), // Center
                    debug = true // Shows anchor point
                )
            )
        }
    }
}
</code></pre>
<h2 id="advanced-usage-1"><a class="header" href="#advanced-usage-1">Advanced Usage</a></h2>
<h3 id="dynamic-icon-selection"><a class="header" href="#dynamic-icon-selection">Dynamic Icon Selection</a></h3>
<pre><code class="language-kotlin">@Composable
fun DynamicIconExample() {
    val iconType by remember { mutableStateOf("default") }
    val context = LocalContext.current

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    MapView(state = mapViewState) {
        val icon = when (iconType) {
            "default" -&gt; DefaultIcon(
                fillColor = Color.Blue,
                label = "D"
            )
            "drawable" -&gt; AppCompatResources.getDrawable(context, R.drawable.custom_pin)?.let {
                DrawableDefaultIcon(backgroundDrawable = it)
            }
            "image" -&gt; AppCompatResources.getDrawable(context, R.drawable.location_icon)?.let {
                ImageDefaultIcon(
                    drawable = it,
                    anchor = Offset(0.5f, 1.0f)
                )
            }
            else -&gt; DefaultIcon()
        }

        Marker(
            position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
            icon = icon
        )
    }
}
</code></pre>
<h3 id="icon-factory-pattern"><a class="header" href="#icon-factory-pattern">Icon Factory Pattern</a></h3>
<pre><code class="language-kotlin">object MarkerIconFactory {
    fun createLocationIcon(color: Color, label: String? = null): MarkerIcon {
        return DefaultIcon(
            fillColor = color,
            strokeColor = Color.White,
            strokeWidth = 2.dp,
            label = label,
            scale = 1.0f
        )
    }

    fun createCustomIcon(context: Context, drawableRes: Int, scale: Float = 1.0f): MarkerIcon? {
        return AppCompatResources.getDrawable(context, drawableRes)?.let {
            DrawableDefaultIcon(
                backgroundDrawable = it,
                scale = scale
            )
        }
    }

    fun createDirectionalIcon(context: Context, direction: Float): MarkerIcon? {
        return AppCompatResources.getDrawable(context, R.drawable.arrow)?.let { drawable -&gt;
            // Apply rotation to drawable if needed
            val rotatedDrawable = drawable.mutate()
            rotatedDrawable.setColorFilter(null)

            ImageDefaultIcon(
                drawable = rotatedDrawable,
                anchor = Offset(0.5f, 0.5f)
            )
        }
    }
}
</code></pre>
<h2 id="best-practices-20"><a class="header" href="#best-practices-20">Best Practices</a></h2>
<h3 id="performance-considerations-3"><a class="header" href="#performance-considerations-3">Performance Considerations</a></h3>
<ol>
<li><strong>Reuse Icon Instances</strong>: Create icons once and reuse them for multiple markers</li>
<li><strong>Optimize Drawable Resources</strong>: Use appropriately sized drawable resources</li>
<li><strong>Limit Custom Drawables</strong>: Too many unique drawables can impact memory usage</li>
</ol>
<pre><code class="language-kotlin">// Good: Reuse icon instances
val blueIcon = DefaultIcon(fillColor = Color.Blue)
val redIcon = DefaultIcon(fillColor = Color.Red)

markers.forEach { markerData -&gt;
    val icon = if (markerData.isSelected) blueIcon else redIcon
    Marker(position = markerData.position, icon = icon)
}
</code></pre>
<h3 id="visual-consistency"><a class="header" href="#visual-consistency">Visual Consistency</a></h3>
<ol>
<li><strong>Consistent Scaling</strong>: Use consistent scale values across your application</li>
<li><strong>Color Schemes</strong>: Maintain a consistent color palette for marker types</li>
<li><strong>Anchor Points</strong>: Use appropriate anchors for icon types (bottom center for pins, center for circles)</li>
</ol>
<h3 id="accessibility"><a class="header" href="#accessibility">Accessibility</a></h3>
<ol>
<li><strong>Meaningful Labels</strong>: Provide descriptive labels when using <code>DefaultIcon</code></li>
<li><strong>Color Contrast</strong>: Ensure good contrast between fill and stroke colors</li>
<li><strong>Alternative Indicators</strong>: Don’t rely solely on color to convey information</li>
</ol>
<h2 id="common-use-cases-2"><a class="header" href="#common-use-cases-2">Common Use Cases</a></h2>
<h3 id="status-indicators"><a class="header" href="#status-indicators">Status Indicators</a></h3>
<pre><code class="language-kotlin">enum class MarkerStatus { ACTIVE, INACTIVE, WARNING, ERROR }

fun createStatusIcon(status: MarkerStatus): MarkerIcon = DefaultIcon(
    fillColor = when (status) {
        MarkerStatus.ACTIVE -&gt; Color.Green
        MarkerStatus.INACTIVE -&gt; Color.Gray
        MarkerStatus.WARNING -&gt; Color.Yellow
        MarkerStatus.ERROR -&gt; Color.Red
    },
    strokeColor = Color.White,
    strokeWidth = 2.dp,
    scale = 1.0f
)
</code></pre>
<h3 id="category-markers"><a class="header" href="#category-markers">Category Markers</a></h3>
<pre><code class="language-kotlin">sealed class PoiCategory(val icon: MarkerIcon) {
    object Restaurant : PoiCategory(DefaultIcon(fillColor = Color(0xFF4CAF50), label = "🍽️"))
    object Hotel : PoiCategory(DefaultIcon(fillColor = Color(0xFF2196F3), label = "🏨"))
    object GasStation : PoiCategory(DefaultIcon(fillColor = Color(0xFFFF9800), label = "⛽"))
    object Hospital : PoiCategory(DefaultIcon(fillColor = Color(0xFFF44336), label = "🏥"))
}
</code></pre>
<h2 id="troubleshooting-5"><a class="header" href="#troubleshooting-5">Troubleshooting</a></h2>
<h3 id="common-issues-5"><a class="header" href="#common-issues-5">Common Issues</a></h3>
<ol>
<li><strong>Icons Not Displaying</strong>: Verify drawable resources exist and are accessible</li>
<li><strong>Incorrect Positioning</strong>: Check anchor points for custom icons</li>
<li><strong>Performance Issues</strong>: Reduce number of unique icon instances</li>
<li><strong>Scale Problems</strong>: Ensure scale values are positive and reasonable (0.1 - 3.0)</li>
</ol>
<h3 id="debug-mode-1"><a class="header" href="#debug-mode-1">Debug Mode</a></h3>
<p>Enable debug mode to visualize anchor points and icon bounds:</p>
<pre><code class="language-kotlin">Marker(
    position = position,
    icon = ImageDefaultIcon(
        drawable = customDrawable,
        anchor = Offset(0.5f, 1.0f),
        debug = true // Shows anchor point and bounds
    )
)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="marker-animation"><a class="header" href="#marker-animation">Marker Animation</a></h1>
<p>MarkerAnimation provides smooth transitions and visual effects for markers on the map. Animations can be applied to marker appearance, position changes, and lifecycle events.</p>
<h2 id="markeranimation-interface"><a class="header" href="#markeranimation-interface">MarkerAnimation Interface</a></h2>
<pre><code class="language-kotlin">interface MarkerAnimation {
    val duration: Long
    val interpolator: TimeInterpolator?

    // Animation lifecycle methods
    fun onStart()
    fun onUpdate(progress: Float)
    fun onEnd()
}
</code></pre>
<h2 id="animation-types"><a class="header" href="#animation-types">Animation Types</a></h2>
<h3 id="position-animations"><a class="header" href="#position-animations">Position Animations</a></h3>
<p>Smoothly animate marker position changes when updating coordinates.</p>
<pre><code class="language-kotlin">class PositionAnimation(
    val fromPosition: GeoPoint,
    val toPosition: GeoPoint,
    override val duration: Long = 1000,
    override val interpolator: TimeInterpolator? = AccelerateDecelerateInterpolator()
) : MarkerAnimation
</code></pre>
<h4 id="usage-example-1"><a class="header" href="#usage-example-1">Usage Example</a></h4>
<pre><code class="language-kotlin">@Composable
fun AnimatedMarkerExample() {
    var markerPosition by remember {
        mutableStateOf(GeoPointImpl.fromLatLong(37.7749, -122.4194))
    }
    val markerState = remember { MarkerState(position = markerPosition) }

    // Animate marker to new position
    LaunchedEffect(markerPosition) {
        val animation = PositionAnimation(
            fromPosition = markerState.position,
            toPosition = markerPosition,
            duration = 1500
        )
        markerState.setAnimation(animation)
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    MapView(
        state = mapViewState,
        onMapClick = { clickedPosition -&gt;
            markerPosition = clickedPosition // Triggers animation
        },
        onMarkerAnimateStart = { markerState -&gt;
            println("Animation started for marker: ${markerState.id}")
        },
        onMarkerAnimateEnd = { markerState -&gt;
            println("Animation ended for marker: ${markerState.id}")
        }
    ) {
        Marker(markerState)
    }
}
</code></pre>
<h3 id="scale-animations"><a class="header" href="#scale-animations">Scale Animations</a></h3>
<p>Animate marker size changes for emphasis or state transitions.</p>
<pre><code class="language-kotlin">class ScaleAnimation(
    val fromScale: Float,
    val toScale: Float,
    override val duration: Long = 500,
    override val interpolator: TimeInterpolator? = OvershootInterpolator()
) : MarkerAnimation
</code></pre>
<h4 id="usage-example-2"><a class="header" href="#usage-example-2">Usage Example</a></h4>
<pre><code class="language-kotlin">@Composable
fun ScaleAnimationExample() {
    var isExpanded by remember { mutableStateOf(false) }
    val markerState = remember {
        MarkerState(
            position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
            icon = DefaultIcon(fillColor = Color.Blue, scale = 1.0f)
        )
    }

    // Animate scale changes
    LaunchedEffect(isExpanded) {
        val animation = ScaleAnimation(
            fromScale = if (isExpanded) 1.0f else 1.5f,
            toScale = if (isExpanded) 1.5f else 1.0f,
            duration = 300,
            interpolator = BounceInterpolator()
        )
        markerState.setAnimation(animation)
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    MapView(
        state = mapViewState,
        onMarkerClick = {
            isExpanded = !isExpanded
        }
    ) {
        Marker(markerState)
    }
}
</code></pre>
<h3 id="fade-animations"><a class="header" href="#fade-animations">Fade Animations</a></h3>
<p>Control marker opacity for appearance and disappearance effects.</p>
<pre><code class="language-kotlin">class FadeAnimation(
    val fromAlpha: Float,
    val toAlpha: Float,
    override val duration: Long = 800,
    override val interpolator: TimeInterpolator? = AccelerateDecelerateInterpolator()
) : MarkerAnimation
</code></pre>
<h4 id="usage-example-3"><a class="header" href="#usage-example-3">Usage Example</a></h4>
<pre><code class="language-kotlin">@Composable
fun FadeAnimationExample() {
    var markersVisible by remember { mutableStateOf(true) }
    val markerStates = remember {
        listOf(
            MarkerState(
                position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
                icon = DefaultIcon(fillColor = Color.Red)
            ),
            MarkerState(
                position = GeoPointImpl.fromLatLong(37.7849, -122.4094),
                icon = DefaultIcon(fillColor = Color.Blue)
            )
        )
    }

    // Animate opacity changes
    LaunchedEffect(markersVisible) {
        markerStates.forEach { markerState -&gt;
            val animation = FadeAnimation(
                fromAlpha = if (markersVisible) 0.0f else 1.0f,
                toAlpha = if (markersVisible) 1.0f else 0.0f,
                duration = 600
            )
            markerState.setAnimation(animation)
        }
    }

    Column {
        Button(onClick = { markersVisible = !markersVisible }) {
            Text(if (markersVisible) "Hide Markers" else "Show Markers")
        }

        // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
        MapView(state = mapViewState) {
            markerStates.forEach { markerState -&gt;
                Marker(markerState)
            }
        }
    }
}
</code></pre>
<h3 id="bounce-animation"><a class="header" href="#bounce-animation">Bounce Animation</a></h3>
<p>Creates a bouncing effect when markers appear or are interacted with.</p>
<pre><code class="language-kotlin">class BounceAnimation(
    val bounceHeight: Float = 50f,
    override val duration: Long = 1000,
    override val interpolator: TimeInterpolator? = BounceInterpolator()
) : MarkerAnimation
</code></pre>
<h4 id="usage-example-4"><a class="header" href="#usage-example-4">Usage Example</a></h4>
<pre><code class="language-kotlin">@Composable
fun BounceAnimationExample() {
    var triggerBounce by remember { mutableStateOf(false) }
    val markerState = remember {
        MarkerState(
            position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
            icon = DefaultIcon(fillColor = Color.Green, label = "Bounce!")
        )
    }

    // Trigger bounce animation
    LaunchedEffect(triggerBounce) {
        if (triggerBounce) {
            val animation = BounceAnimation(
                bounceHeight = 30f,
                duration = 800
            )
            markerState.setAnimation(animation)
            triggerBounce = false
        }
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    MapView(
        state = mapViewState,
        onMarkerClick = {
            triggerBounce = true
        }
    ) {
        Marker(markerState)
    }
}
</code></pre>
<h2 id="complex-animations"><a class="header" href="#complex-animations">Complex Animations</a></h2>
<h3 id="sequential-animations"><a class="header" href="#sequential-animations">Sequential Animations</a></h3>
<p>Chain multiple animations together for complex effects.</p>
<pre><code class="language-kotlin">class SequentialAnimation(
    private val animations: List&lt;MarkerAnimation&gt;
) : MarkerAnimation {
    private var currentIndex = 0
    private var currentAnimation: MarkerAnimation? = null

    override val duration: Long = animations.sumOf { it.duration }
    override val interpolator: TimeInterpolator? = null

    fun playNext() {
        if (currentIndex &lt; animations.size) {
            currentAnimation = animations[currentIndex++]
            currentAnimation?.onStart()
        }
    }
}
</code></pre>
<h4 id="usage-example-5"><a class="header" href="#usage-example-5">Usage Example</a></h4>
<pre><code class="language-kotlin">@Composable
fun SequentialAnimationExample() {
    val markerState = remember {
        MarkerState(
            position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
            icon = DefaultIcon(fillColor = Color.Purple)
        )
    }

    LaunchedEffect(Unit) {
        val sequentialAnimation = SequentialAnimation(
            animations = listOf(
                ScaleAnimation(fromScale = 0.5f, toScale = 1.5f, duration = 500),
                FadeAnimation(fromAlpha = 1.0f, toAlpha = 0.3f, duration = 300),
                FadeAnimation(fromAlpha = 0.3f, toAlpha = 1.0f, duration = 300),
                ScaleAnimation(fromScale = 1.5f, toScale = 1.0f, duration = 400)
            )
        )
        markerState.setAnimation(sequentialAnimation)
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    MapView(state = mapViewState) {
        Marker(markerState)
    }
}
</code></pre>
<h3 id="path-animation"><a class="header" href="#path-animation">Path Animation</a></h3>
<p>Animate marker along a predefined path.</p>
<pre><code class="language-kotlin">class PathAnimation(
    val waypoints: List&lt;GeoPoint&gt;,
    override val duration: Long = 3000,
    override val interpolator: TimeInterpolator? = LinearInterpolator()
) : MarkerAnimation {

    fun getPositionAtProgress(progress: Float): GeoPoint {
        // Calculate position along path based on progress (0.0 to 1.0)
        val totalDistance = calculateTotalDistance()
        val targetDistance = totalDistance * progress

        // Find segment and interpolate position
        return interpolateAlongPath(targetDistance)
    }
}
</code></pre>
<h4 id="usage-example-6"><a class="header" href="#usage-example-6">Usage Example</a></h4>
<pre><code class="language-kotlin">@Composable
fun PathAnimationExample() {
    val waypoints = remember {
        listOf(
            GeoPointImpl.fromLatLong(37.7749, -122.4194), // Start
            GeoPointImpl.fromLatLong(37.7849, -122.4094), // Waypoint 1
            GeoPointImpl.fromLatLong(37.7949, -122.3994), // Waypoint 2
            GeoPointImpl.fromLatLong(37.8049, -122.3894)  // End
        )
    }

    val markerState = remember {
        MarkerState(
            position = waypoints.first(),
            icon = DefaultIcon(fillColor = Color.Orange, label = "🚗")
        )
    }

    // Start path animation
    LaunchedEffect(Unit) {
        val pathAnimation = PathAnimation(
            waypoints = waypoints,
            duration = 5000 // 5 seconds to complete path
        )
        markerState.setAnimation(pathAnimation)
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    MapView(state = mapViewState) {
        // Show path
        Polyline(
            points = waypoints,
            strokeColor = Color.Blue,
            strokeWidth = 3.dp
        )

        // Animated marker
        Marker(markerState)

        // Waypoint markers
        waypoints.forEachIndexed { index, point -&gt;
            Marker(
                position = point,
                icon = DefaultIcon(
                    fillColor = Color.Gray,
                    scale = 0.6f,
                    label = "$index"
                )
            )
        }
    }
}
</code></pre>
<h2 id="animation-event-handling"><a class="header" href="#animation-event-handling">Animation Event Handling</a></h2>
<h3 id="animation-callbacks"><a class="header" href="#animation-callbacks">Animation Callbacks</a></h3>
<p>Handle animation lifecycle events in your map component:</p>
<pre><code class="language-kotlin">// Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(
    state = mapViewState,
    onMarkerAnimateStart = { markerState -&gt;
        println("Animation started for marker: ${markerState.id}")
        // Update UI state, start loading indicators, etc.
    },
    onMarkerAnimateEnd = { markerState -&gt;
        println("Animation completed for marker: ${markerState.id}")
        // Clean up resources, update final state, etc.
    }
) {
    // Markers with animations
}
</code></pre>
<h3 id="custom-animation-progress"><a class="header" href="#custom-animation-progress">Custom Animation Progress</a></h3>
<p>Monitor animation progress for custom behaviors:</p>
<pre><code class="language-kotlin">class ProgressTrackingAnimation(
    private val baseAnimation: MarkerAnimation,
    private val onProgress: (Float) -&gt; Unit
) : MarkerAnimation by baseAnimation {

    override fun onUpdate(progress: Float) {
        baseAnimation.onUpdate(progress)
        onProgress(progress)
    }
}

// Usage
val trackingAnimation = ProgressTrackingAnimation(
    baseAnimation = PositionAnimation(from, to, 2000)
) { progress -&gt;
    // Custom progress handling
    println("Animation is ${(progress * 100).toInt()}% complete")
}
</code></pre>
<h2 id="performance-considerations-4"><a class="header" href="#performance-considerations-4">Performance Considerations</a></h2>
<h3 id="animation-optimization"><a class="header" href="#animation-optimization">Animation Optimization</a></h3>
<ol>
<li><strong>Limit Concurrent Animations</strong>: Too many simultaneous animations can impact performance</li>
<li><strong>Use Appropriate Duration</strong>: Very long animations may feel sluggish</li>
<li><strong>Choose Efficient Interpolators</strong>: Some interpolators are more computationally expensive</li>
</ol>
<pre><code class="language-kotlin">// Good: Reasonable animation count and duration
val animations = markerStates.take(10).map { markerState -&gt;
    PositionAnimation(
        fromPosition = markerState.position,
        toPosition = newPosition,
        duration = 800 // Reasonable duration
    )
}

// Avoid: Too many long animations
val badAnimations = markerStates.take(100).map { markerState -&gt;
    PositionAnimation(
        fromPosition = markerState.position,
        toPosition = newPosition,
        duration = 5000 // Too long
    )
}
</code></pre>
<h3 id="memory-management-2"><a class="header" href="#memory-management-2">Memory Management</a></h3>
<pre><code class="language-kotlin">// Clear animations when no longer needed
LaunchedEffect(shouldClearAnimations) {
    if (shouldClearAnimations) {
        markerStates.forEach { it.setAnimation(null) }
    }
}
</code></pre>
<h2 id="best-practices-21"><a class="header" href="#best-practices-21">Best Practices</a></h2>
<h3 id="animation-guidelines"><a class="header" href="#animation-guidelines">Animation Guidelines</a></h3>
<ol>
<li><strong>Provide Feedback</strong>: Use animations to provide visual feedback for user interactions</li>
<li><strong>Maintain Context</strong>: Animations should help users understand spatial relationships</li>
<li><strong>Be Consistent</strong>: Use similar animation styles throughout your application</li>
<li><strong>Consider Accessibility</strong>: Provide options to reduce or disable animations</li>
</ol>
<h3 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h3>
<pre><code class="language-kotlin">// Entrance animation for new markers
fun createEntranceAnimation(): MarkerAnimation = SequentialAnimation(
    listOf(
        ScaleAnimation(fromScale = 0.0f, toScale = 1.2f, duration = 200),
        ScaleAnimation(fromScale = 1.2f, toScale = 1.0f, duration = 100)
    )
)

// Attention-grabbing animation
fun createAttentionAnimation(): MarkerAnimation = SequentialAnimation(
    listOf(
        ScaleAnimation(fromScale = 1.0f, toScale = 1.3f, duration = 150),
        ScaleAnimation(fromScale = 1.3f, toScale = 1.0f, duration = 150),
        ScaleAnimation(fromScale = 1.0f, toScale = 1.3f, duration = 150),
        ScaleAnimation(fromScale = 1.3f, toScale = 1.0f, duration = 150)
    )
)

// Smooth exit animation
fun createExitAnimation(): MarkerAnimation = SequentialAnimation(
    listOf(
        FadeAnimation(fromAlpha = 1.0f, toAlpha = 0.0f, duration = 300),
        ScaleAnimation(fromScale = 1.0f, toScale = 0.0f, duration = 200)
    )
)
</code></pre>
<h2 id="troubleshooting-6"><a class="header" href="#troubleshooting-6">Troubleshooting</a></h2>
<h3 id="common-issues-6"><a class="header" href="#common-issues-6">Common Issues</a></h3>
<ol>
<li><strong>Animations Not Starting</strong>: Verify <code>MarkerState.setAnimation()</code> is called</li>
<li><strong>Jerky Movement</strong>: Check interpolator choice and frame rate</li>
<li><strong>Memory Leaks</strong>: Clear animations when markers are removed</li>
<li><strong>Performance Issues</strong>: Limit concurrent animations and use shorter durations</li>
</ol>
<h3 id="debug-animation"><a class="header" href="#debug-animation">Debug Animation</a></h3>
<pre><code class="language-kotlin">// Enable animation debugging
val debugAnimation = object : MarkerAnimation {
    override val duration = 1000L
    override val interpolator = AccelerateDecelerateInterpolator()

    override fun onStart() {
        Log.d("Animation", "Animation started")
    }

    override fun onUpdate(progress: Float) {
        Log.d("Animation", "Progress: $progress")
    }

    override fun onEnd() {
        Log.d("Animation", "Animation completed")
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="icons-module-experimental"><a class="header" href="#icons-module-experimental">Icons Module (Experimental)</a></h1>
<p>The <code>mapconductor-icons</code> module provides custom-drawn marker icons with programmatic styling. This experimental module offers vector-style icons that can be customized with colors, sizes, and other properties at runtime.</p>
<blockquote>
<p><strong>⚠️ Experimental Module</strong>: This module is experimental and may change significantly in future versions. Use in production with caution.</p>
</blockquote>
<h2 id="overview-4"><a class="header" href="#overview-4">Overview</a></h2>
<p>The icons module creates high-quality marker icons using Canvas drawing operations, providing:</p>
<ul>
<li><strong>Scalable Vector Graphics</strong>: Icons scale smoothly at any size</li>
<li><strong>Runtime Customization</strong>: Change colors, sizes, and properties dynamically</li>
<li><strong>Optimized Caching</strong>: Automatic bitmap caching for performance</li>
<li><strong>Consistent Appearance</strong>: Same visual style across all map providers</li>
</ul>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>Add the icons module to your <code>build.gradle</code>:</p>
<pre><code class="language-kotlin">dependencies {
    implementation "com.mapconductor:mapconductor-icons"

    // Required: Bom module
    implementation "com.mapconductor:mapconductor-bom:$version"
    // Required: Core module
    implementation "com.mapconductor:core"

    // Choose your map provider
    implementation "com.mapconductor:for-googlemaps"
}
</code></pre>
<h2 id="available-icons"><a class="header" href="#available-icons">Available Icons</a></h2>
<h3 id="circleicon"><a class="header" href="#circleicon">CircleIcon</a></h3>
<p>A simple circular marker icon with customizable fill and stroke:</p>
<pre><code class="language-kotlin">import com.mapconductor.icons.CircleIcon

// Basic circle icon
val basicCircle = CircleIcon()

// Customized circle icon
val customCircle = CircleIcon(
    fillColor = Color.Blue,
    strokeColor = Color.White,
    strokeWidth = 2.dp,
    scale = 1.2f,
    iconSize = 32.dp
)
</code></pre>
<h4 id="circleicon-properties"><a class="header" href="#circleicon-properties">CircleIcon Properties</a></h4>
<ul>
<li><strong><code>fillColor: Color</code></strong>: Interior color of the circle (default: <code>Color.Red</code>)</li>
<li><strong><code>strokeColor: Color</code></strong>: Border color (default: <code>Color.White</code>)</li>
<li><strong><code>strokeWidth: Dp</code></strong>: Border thickness (default: from Settings)</li>
<li><strong><code>scale: Float</code></strong>: Size multiplier (default: <code>1.0f</code>)</li>
<li><strong><code>iconSize: Dp</code></strong>: Base size of the icon (default: from Settings)</li>
<li><strong><code>debug: Boolean</code></strong>: Show debug outline (default: <code>false</code>)</li>
</ul>
<h3 id="flagicon"><a class="header" href="#flagicon">FlagIcon</a></h3>
<p>A flag-style marker icon with pole and customizable flag:</p>
<pre><code class="language-kotlin">import com.mapconductor.icons.FlagIcon

// Basic flag icon
val basicFlag = FlagIcon()

// Customized flag icon
val customFlag = FlagIcon(
    fillColor = Color.Green,
    strokeColor = Color.Black,
    strokeWidth = 1.5.dp,
    scale = 1.0f,
    iconSize = 40.dp
)
</code></pre>
<h4 id="flagicon-properties"><a class="header" href="#flagicon-properties">FlagIcon Properties</a></h4>
<ul>
<li><strong><code>fillColor: Color</code></strong>: Color of the flag and pole (default: <code>Color.Red</code>)</li>
<li><strong><code>strokeColor: Color</code></strong>: Outline color (default: <code>Color.White</code>)</li>
<li><strong><code>strokeWidth: Dp</code></strong>: Outline thickness (default: from Settings)</li>
<li><strong><code>scale: Float</code></strong>: Size multiplier (default: <code>1.0f</code>)</li>
<li><strong><code>iconSize: Dp</code></strong>: Base size of the icon (default: from Settings)</li>
<li><strong><code>debug: Boolean</code></strong>: Show debug outline (default: <code>false</code>)</li>
</ul>
<h2 id="basic-usage-2"><a class="header" href="#basic-usage-2">Basic Usage</a></h2>
<h3 id="simple-icon-usage"><a class="header" href="#simple-icon-usage">Simple Icon Usage</a></h3>
<pre><code class="language-kotlin">@Composable
fun BasicIconExample() {
    val circleIcon = CircleIcon(
        fillColor = Color.Blue,
        strokeColor = Color.White
    )

    val flagIcon = FlagIcon(
        fillColor = Color.Red,
        strokeColor = Color.Black
    )

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    MapView(state = mapViewState) {
        Marker(
            position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
            icon = circleIcon
        )

        Marker(
            position = GeoPointImpl.fromLatLong(37.7849, -122.4094),
            icon = flagIcon
        )
    }
}
</code></pre>
<h3 id="dynamic-icon-customization"><a class="header" href="#dynamic-icon-customization">Dynamic Icon Customization</a></h3>
<pre><code class="language-kotlin">@Composable
fun DynamicIconExample() {
    var iconColor by remember { mutableStateOf(Color.Red) }
    var iconSize by remember { mutableStateOf(32.dp) }

    val dynamicIcon = CircleIcon(
        fillColor = iconColor,
        strokeColor = Color.White,
        iconSize = iconSize
    )

    Column {
        // Color picker
        Row {
            Button(onClick = { iconColor = Color.Red }) { Text("Red") }
            Button(onClick = { iconColor = Color.Blue }) { Text("Blue") }
            Button(onClick = { iconColor = Color.Green }) { Text("Green") }
        }

        // Size slider
        Slider(
            value = iconSize.value,
            onValueChange = { iconSize = it.dp },
            valueRange = 16f..64f
        )
        Text("Size: ${iconSize.value.toInt()}dp")

        // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
        MapView(state = mapViewState) {
            Marker(
                position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
                icon = dynamicIcon
            )
        }
    }
}
</code></pre>
<h2 id="advanced-usage-2"><a class="header" href="#advanced-usage-2">Advanced Usage</a></h2>
<h3 id="category-based-icons"><a class="header" href="#category-based-icons">Category-Based Icons</a></h3>
<pre><code class="language-kotlin">@Composable
fun CategoryIconExample() {
    data class POI(
        val name: String,
        val category: String,
        val position: GeoPoint
    ) : java.io.Serializable

    val pois = listOf(
        POI("Restaurant", "food", GeoPointImpl.fromLatLong(37.7749, -122.4194)),
        POI("Hotel", "lodging", GeoPointImpl.fromLatLong(37.7849, -122.4094)),
        POI("Gas Station", "fuel", GeoPointImpl.fromLatLong(37.7649, -122.4294))
    )

    fun getIconForCategory(category: String) = when (category) {
        "food" -&gt; CircleIcon(fillColor = Color.Red, strokeColor = Color.White)
        "lodging" -&gt; FlagIcon(fillColor = Color.Blue, strokeColor = Color.White)
        "fuel" -&gt; CircleIcon(fillColor = Color.Yellow, strokeColor = Color.Black)
        else -&gt; CircleIcon(fillColor = Color.Gray, strokeColor = Color.White)
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    MapView(state = mapViewState) {
        pois.forEach { poi -&gt;
            Marker(
                position = poi.position,
                icon = getIconForCategory(poi.category),
                extra = poi.name
            )
        }
    }
}
</code></pre>
<h3 id="icon-theming"><a class="header" href="#icon-theming">Icon Theming</a></h3>
<pre><code class="language-kotlin">object IconTheme {
    data class Theme(
        val primaryColor: Color,
        val secondaryColor: Color,
        val strokeColor: Color,
        val strokeWidth: Dp
    ) : java.io.Serializable

    val light = Theme(
        primaryColor = Color(0xFF2196F3),
        secondaryColor = Color(0xFFFFFFFF),
        strokeColor = Color(0xFF000000),
        strokeWidth = 1.dp
    )

    val dark = Theme(
        primaryColor = Color(0xFF1976D2),
        secondaryColor = Color(0xFF424242),
        strokeColor = Color(0xFFFFFFFF),
        strokeWidth = 1.dp
    )
}

@Composable
fun ThemedIconExample() {
    val isDarkTheme = isSystemInDarkTheme()
    val theme = if (isDarkTheme) IconTheme.dark else IconTheme.light

    val themedCircle = CircleIcon(
        fillColor = theme.primaryColor,
        strokeColor = theme.strokeColor,
        strokeWidth = theme.strokeWidth
    )

    val themedFlag = FlagIcon(
        fillColor = theme.primaryColor,
        strokeColor = theme.strokeColor,
        strokeWidth = theme.strokeWidth
    )

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    MapView(state = mapViewState) {
        Marker(
            position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
            icon = themedCircle
        )

        Marker(
            position = GeoPointImpl.fromLatLong(37.7849, -122.4094),
            icon = themedFlag
        )
    }
}
</code></pre>
<h3 id="icon-animation"><a class="header" href="#icon-animation">Icon Animation</a></h3>
<pre><code class="language-kotlin">@Composable
fun AnimatedIconExample() {
    var scale by remember { mutableStateOf(1.0f) }
    var color by remember { mutableStateOf(Color.Red) }

    // Animate scale
    LaunchedEffect(Unit) {
        while (true) {
            animate(
                initialValue = 1.0f,
                targetValue = 1.5f,
                animationSpec = tween(1000)
            ) { value, _ -&gt; scale = value }

            animate(
                initialValue = 1.5f,
                targetValue = 1.0f,
                animationSpec = tween(1000)
            ) { value, _ -&gt; scale = value }
        }
    }

    // Animate color
    LaunchedEffect(Unit) {
        val colors = listOf(Color.Red, Color.Blue, Color.Green, Color.Yellow)
        var index = 0
        while (true) {
            delay(2000)
            index = (index + 1) % colors.size
            color = colors[index]
        }
    }

    val animatedIcon = CircleIcon(
        fillColor = color,
        strokeColor = Color.White,
        scale = scale
    )

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    MapView(state = mapViewState) {
        Marker(
            position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
            icon = animatedIcon
        )
    }
}
</code></pre>
<h2 id="icon-properties-and-behavior"><a class="header" href="#icon-properties-and-behavior">Icon Properties and Behavior</a></h2>
<h3 id="anchor-points"><a class="header" href="#anchor-points">Anchor Points</a></h3>
<p>Icons have specific anchor points that determine how they’re positioned relative to the geographic coordinate:</p>
<ul>
<li><strong>CircleIcon</strong>: Anchored at left-center (0.0, 0.5)</li>
<li><strong>FlagIcon</strong>: Anchored near the base of the pole (0.176, 0.91)</li>
</ul>
<h3 id="info-window-anchors"><a class="header" href="#info-window-anchors">Info Window Anchors</a></h3>
<p>Info windows (if supported by the provider) anchor to different points:</p>
<ul>
<li><strong>CircleIcon</strong>: Center of the circle (0.5, 0.5)</li>
<li><strong>FlagIcon</strong>: Top of the flag (0.5, 0.0)</li>
</ul>
<h3 id="performance-considerations-5"><a class="header" href="#performance-considerations-5">Performance Considerations</a></h3>
<h4 id="bitmap-caching"><a class="header" href="#bitmap-caching">Bitmap Caching</a></h4>
<p>Icons automatically cache their rendered bitmaps based on property hash:</p>
<pre><code class="language-kotlin">// These will share the same cached bitmap
val icon1 = CircleIcon(fillColor = Color.Red, strokeColor = Color.White)
val icon2 = CircleIcon(fillColor = Color.Red, strokeColor = Color.White)

// This will create a new cached bitmap
val icon3 = CircleIcon(fillColor = Color.Blue, strokeColor = Color.White)
</code></pre>
<h4 id="memory-management-3"><a class="header" href="#memory-management-3">Memory Management</a></h4>
<ul>
<li>Cached bitmaps are automatically managed</li>
<li>Icons with identical properties share bitmap instances</li>
<li>Large icons use more memory - use appropriate sizes</li>
</ul>
<h2 id="debugging-icons"><a class="header" href="#debugging-icons">Debugging Icons</a></h2>
<p>Enable debug mode to visualize icon boundaries and anchor points:</p>
<pre><code class="language-kotlin">@Composable
fun DebugIconExample() {
    val debugIcon = CircleIcon(
        fillColor = Color.Red,
        strokeColor = Color.White,
        debug = true  // Show debug outline and crosshairs
    )

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    MapView(state = mapViewState) {
        Marker(
            position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
            icon = debugIcon
        )
    }
}
</code></pre>
<p>Debug mode shows:</p>
<ul>
<li>Icon bounding rectangle (black outline)</li>
<li>Center crosshairs (black lines)</li>
<li>Actual drawn content</li>
</ul>
<h2 id="custom-icon-development"><a class="header" href="#custom-icon-development">Custom Icon Development</a></h2>
<h3 id="extending-abstractmarkericon"><a class="header" href="#extending-abstractmarkericon">Extending AbstractMarkerIcon</a></h3>
<p>To create custom icons, extend <code>AbstractMarkerIcon</code>:</p>
<pre><code class="language-kotlin">class CustomIcon(
    private val fillColor: Color = Color.Blue,
    override val scale: Float = 1.0f,
    override val iconSize: Dp = 32.dp,
    override val debug: Boolean = false
) : AbstractMarkerIcon() {

    override val anchor: Offset = Offset(0.5f, 0.5f)
    override val infoAnchor: Offset = Offset(0.5f, 0.0f)

    override fun toBitmapIcon(): BitmapIcon {
        val id = "custom_icon_${hashCode()}".hashCode()
        BitmapIconCache.get(id)?.let { return it }

        val canvasSize = ResourceProvider.dpToPx(iconSize.value * scale)
        val bitmap = createBitmap(canvasSize.toInt(), canvasSize.toInt())
        val canvas = Canvas(bitmap)

        // Custom drawing code here
        val paint = Paint().apply {
            color = fillColor.toArgb()
            style = Paint.Style.FILL
            isAntiAlias = true
        }

        canvas.drawRect(0f, 0f, canvasSize.toFloat(), canvasSize.toFloat(), paint)

        val result = BitmapIcon(
            bitmap = bitmap,
            anchor = anchor,
            size = Size(canvasSize.toFloat(), canvasSize.toFloat())
        )
        BitmapIconCache.put(id, result)
        return result
    }
}
</code></pre>
<h2 id="best-practices-22"><a class="header" href="#best-practices-22">Best Practices</a></h2>
<ol>
<li><strong>Consistent Sizing</strong>: Use consistent icon sizes for similar marker types</li>
<li><strong>Color Accessibility</strong>: Ensure sufficient contrast between fill and stroke colors</li>
<li><strong>Performance</strong>: Reuse identical icon instances to benefit from caching</li>
<li><strong>Scale Appropriately</strong>: Consider map zoom levels when choosing icon sizes</li>
<li><strong>Test Across Providers</strong>: Verify icon appearance on all target map providers</li>
</ol>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<ol>
<li><strong>Limited Icon Set</strong>: Currently only CircleIcon and FlagIcon are available</li>
<li><strong>Static Shapes</strong>: Icons are drawn programmatically, not from vector files</li>
<li><strong>Provider Differences</strong>: Minor rendering differences may occur between map providers</li>
<li><strong>Memory Usage</strong>: Large icons or many unique icon variations consume more memory</li>
</ol>
<h2 id="migration-and-compatibility"><a class="header" href="#migration-and-compatibility">Migration and Compatibility</a></h2>
<p>This module is experimental and APIs may change. When migrating:</p>
<ol>
<li>Test thoroughly with your specific use cases</li>
<li>Monitor memory usage with large numbers of unique icons</li>
<li>Have fallback options for critical functionality</li>
<li>Report issues to help improve the module</li>
</ol>
<p>The icons module provides a foundation for custom marker styling while maintaining the unified MapConductor API across providers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="marker-strategy-experimental"><a class="header" href="#marker-strategy-experimental">Marker Strategy (Experimental)</a></h1>
<p>The <code>mapconductor-marker-strategy</code> module provides advanced marker rendering strategies for optimizing performance and user experience with large datasets. This experimental module offers multiple rendering approaches tailored to different use cases and performance requirements.</p>
<blockquote>
<p><strong>⚠️ Experimental Module</strong>: This module is experimental and APIs may change. Use in production with caution.</p>
</blockquote>
<h2 id="overview-5"><a class="header" href="#overview-5">Overview</a></h2>
<p>The marker strategy module provides sophisticated rendering strategies that go beyond basic marker display:</p>
<ul>
<li><strong>Viewport-Based Rendering</strong>: Only render markers visible in the current viewport</li>
<li><strong>Dynamic Add/Remove</strong>: Efficiently manage markers as the viewport changes</li>
<li><strong>Spatial Optimization</strong>: Advanced spatial indexing for large datasets</li>
<li><strong>Remote Data Integration</strong>: Support for server-side marker data</li>
<li><strong>Clustering Support</strong>: Group nearby markers for better performance</li>
</ul>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<p>Add the marker strategy module to your <code>build.gradle</code>:</p>
<pre><code class="language-kotlin">dependencies {
    implementation "com.mapconductor:marker-strategy:$version"

    // Required: Core module
    implementation "com.mapconductor:mapconductor-bom:$version"
    // Required: Core module
    implementation "com.mapconductor:core:$version"

    // Choose your map provider
    implementation "com.mapconductor:for-googlemaps:$version"
}
</code></pre>
<h2 id="core-strategies"><a class="header" href="#core-strategies">Core Strategies</a></h2>
<h3 id="defaultmarkerrenderingstrategy"><a class="header" href="#defaultmarkerrenderingstrategy">DefaultMarkerRenderingStrategy</a></h3>
<p>Optimal for Google Maps and ArcGIS providers that handle add/remove operations efficiently:</p>
<pre><code class="language-kotlin">import com.mapconductor.marker.strategy.DefaultMarkerRenderingStrategy

val defaultStrategy = DefaultMarkerRenderingStrategy&lt;GoogleMapActualMarker&gt;(
    expandMargin = 0.2,  // 20% viewport expansion
    semaphore = Semaphore(1),
    geocell = HexGeocellImpl.defaultGeocell()
)
</code></pre>
<h4 id="key-features"><a class="header" href="#key-features">Key Features</a></h4>
<ul>
<li><strong>Dynamic Add/Remove</strong>: Adds markers entering viewport, removes markers leaving viewport</li>
<li><strong>Viewport Expansion</strong>: Preloads markers slightly outside visible area</li>
<li><strong>Memory Efficient</strong>: Only keeps visible markers in memory</li>
<li><strong>Smooth Scrolling</strong>: Reduces pop-in/pop-out during map movement</li>
</ul>
<h3 id="simplemarkerrenderingstrategy"><a class="header" href="#simplemarkerrenderingstrategy">SimpleMarkerRenderingStrategy</a></h3>
<p>Lightweight strategy for smaller datasets or providers with different performance characteristics:</p>
<pre><code class="language-kotlin">import com.mapconductor.marker.strategy.SimpleMarkerRenderingStrategy

val simpleStrategy = SimpleMarkerRenderingStrategy&lt;MapboxActualMarker&gt;(
    expandMargin = 0.15,
    geocell = HexGeocellImpl.defaultGeocell()
)
</code></pre>
<h4 id="key-features-1"><a class="header" href="#key-features-1">Key Features</a></h4>
<ul>
<li><strong>Simplified Logic</strong>: Less complex viewport management</li>
<li><strong>Lower Overhead</strong>: Minimal computational overhead</li>
<li><strong>Good for Mapbox</strong>: Optimized for providers that prefer simpler marker management</li>
</ul>
<h3 id="spatialmarkerrenderingstrategy"><a class="header" href="#spatialmarkerrenderingstrategy">SpatialMarkerRenderingStrategy</a></h3>
<p>Advanced strategy with spatial clustering and optimization:</p>
<pre><code class="language-kotlin">import com.mapconductor.marker.strategy.SpatialMarkerRenderingStrategy

val spatialStrategy = SpatialMarkerRenderingStrategy&lt;HereActualMarker&gt;(
    clusteringEnabled = true,
    clusterRadius = 100.0,      // 100-meter clustering radius
    maxMarkersPerCluster = 10,  // Maximum markers in a cluster
    geocell = HexGeocellImpl.defaultGeocell()
)
</code></pre>
<h4 id="key-features-2"><a class="header" href="#key-features-2">Key Features</a></h4>
<ul>
<li><strong>Spatial Clustering</strong>: Groups nearby markers into clusters</li>
<li><strong>Density Management</strong>: Reduces visual clutter in dense areas</li>
<li><strong>Performance Scaling</strong>: Handles very large datasets efficiently</li>
<li><strong>Customizable Clustering</strong>: Configurable clustering parameters</li>
</ul>
<h2 id="basic-usage-3"><a class="header" href="#basic-usage-3">Basic Usage</a></h2>
<h3 id="setting-up-default-strategy"><a class="header" href="#setting-up-default-strategy">Setting Up Default Strategy</a></h3>
<pre><code class="language-kotlin">@Composable
fun DefaultStrategyExample() {
    val mapViewState = rememberGoogleMapViewState()

    val markerStrategy = remember {
        DefaultMarkerRenderingStrategy&lt;GoogleMapActualMarker&gt;(
            expandMargin = 0.2
        )
    }

    // Configure strategy with map controller
    LaunchedEffect(mapViewState) {
        // Strategy setup depends on map provider implementation
        // This is typically handled by the map provider's marker controller
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    GoogleMapsView(state = mapViewState) {
        // Markers are managed by the strategy
        // Add markers programmatically through the strategy
    }
}
</code></pre>
<h3 id="adding-markers-to-strategy"><a class="header" href="#adding-markers-to-strategy">Adding Markers to Strategy</a></h3>
<pre><code class="language-kotlin">@Composable
fun StrategyMarkerManagement() {
    val markerStrategy = remember {
        DefaultMarkerRenderingStrategy&lt;GoogleMapActualMarker&gt;()
    }

    LaunchedEffect(Unit) {
        // Add markers to the strategy's manager
        val markers = loadMarkerData() // Your marker data

        markers.forEach { markerData -&gt;
            val entity = MarkerEntity(
                state = MarkerState(
                    id = markerData.id,
                    position = markerData.position,
                    icon = DefaultIcon(fillColor = markerData.color)
                )
            )

            // Register with strategy's marker manager
            markerStrategy.markerManager.registerEntity(entity)
        }
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    GoogleMapsView(state = mapViewState) {
        // Strategy handles marker rendering automatically
    }
}
</code></pre>
<h2 id="advanced-usage-3"><a class="header" href="#advanced-usage-3">Advanced Usage</a></h2>
<h3 id="dynamic-marker-loading"><a class="header" href="#dynamic-marker-loading">Dynamic Marker Loading</a></h3>
<pre><code class="language-kotlin">@Composable
fun DynamicLoadingExample() {
    val mapViewState = rememberGoogleMapViewState()
    var currentBounds by remember { mutableStateOf&lt;GeoRectBounds?&gt;(null) }
    var loadedMarkers by remember { mutableStateOf&lt;Set&lt;String&gt;&gt;(emptySet()) }

    val strategy = remember {
        DefaultMarkerRenderingStrategy&lt;GoogleMapActualMarker&gt;(
            expandMargin = 0.3  // Larger margin for preloading
        )
    }

    // Load markers dynamically based on viewport
    LaunchedEffect(currentBounds) {
        currentBounds?.let { bounds -&gt;
            val newMarkers = fetchMarkersForBounds(bounds) // Your API call

            newMarkers.forEach { markerData -&gt;
                if (markerData.id !in loadedMarkers) {
                    val entity = MarkerEntity(
                        state = MarkerState(
                            id = markerData.id,
                            position = markerData.position,
                            icon = DefaultIcon()
                        )
                    )

                    strategy.markerManager.registerEntity(entity)
                    loadedMarkers = loadedMarkers + markerData.id
                }
            }
        }
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    GoogleMapsView(
        state = mapViewState,
        onCameraMove = { cameraPosition -&gt;
            currentBounds = cameraPosition.visibleRegion?.bounds
        }
    ) {
        // Strategy manages dynamic marker loading
    }
}
</code></pre>
<h3 id="clustering-strategy"><a class="header" href="#clustering-strategy">Clustering Strategy</a></h3>
<pre><code class="language-kotlin">@Composable
fun ClusteringStrategyExample() {
    val clusterStrategy = remember {
        SpatialMarkerRenderingStrategy&lt;GoogleMapActualMarker&gt;(
            clusteringEnabled = true,
            clusterRadius = 50.0,       // 50-meter clustering
            maxMarkersPerCluster = 5,   // Small clusters
            geocell = HexGeocellImpl(
                baseHexSideLength = 100.0,  // Fine-grained spatial index
                zoom = 18.0
            )
        )
    }

    // Add dense marker dataset
    LaunchedEffect(Unit) {
        val denseMarkers = generateDenseMarkerSet(
            center = GeoPointImpl.fromLatLong(37.7749, -122.4194),
            count = 500,
            radius = 200.0  // 200-meter radius
        )

        denseMarkers.forEach { markerData -&gt;
            val entity = MarkerEntity(
                state = MarkerState(
                    id = markerData.id,
                    position = markerData.position,
                    icon = DefaultIcon(
                        fillColor = markerData.category.color,
                        scale = 0.8f
                    )
                )
            )

            clusterStrategy.markerManager.registerEntity(entity)
        }
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    GoogleMapsView(state = mapViewState) {
        // Clustering strategy automatically groups nearby markers
    }
}
</code></pre>
<h3 id="remote-spatial-strategy"><a class="header" href="#remote-spatial-strategy">Remote Spatial Strategy</a></h3>
<pre><code class="language-kotlin">@Composable
fun RemoteSpatialExample() {
    val remoteStrategy = remember {
        RemoteSpatialMarkerRenderingStrategy&lt;GoogleMapActualMarker&gt;(
            apiEndpoint = "https://api.example.com/markers",
            cacheTimeout = 300000, // 5 minutes
            maxConcurrentRequests = 3
        )
    }

    // Remote strategy loads markers from server based on viewport
    LaunchedEffect(mapViewState) {
        // Strategy automatically manages server requests
        // No manual marker loading required
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    GoogleMapsView(state = mapViewState) {
        // Remote strategy handles all marker loading from server
    }
}
</code></pre>
<h2 id="strategy-comparison"><a class="header" href="#strategy-comparison">Strategy Comparison</a></h2>
<h3 id="performance-characteristics-1"><a class="header" href="#performance-characteristics-1">Performance Characteristics</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Strategy</th><th>Best For</th><th>Memory Usage</th><th>Network</th><th>Complexity</th></tr></thead><tbody>
<tr><td>DefaultMarkerRenderingStrategy</td><td>Google Maps, ArcGIS</td><td>Medium</td><td>None</td><td>Medium</td></tr>
<tr><td>SimpleMarkerRenderingStrategy</td><td>Mapbox, HERE</td><td>Low</td><td>None</td><td>Low</td></tr>
<tr><td>SpatialMarkerRenderingStrategy</td><td>Large datasets</td><td>High</td><td>None</td><td>High</td></tr>
<tr><td>RemoteSpatialMarkerRenderingStrategy</td><td>Server-side data</td><td>Low</td><td>High</td><td>High</td></tr>
</tbody></table>
</div>
<h3 id="use-case-guidelines"><a class="header" href="#use-case-guidelines">Use Case Guidelines</a></h3>
<h4 id="choose-defaultmarkerrenderingstrategy-when"><a class="header" href="#choose-defaultmarkerrenderingstrategy-when">Choose DefaultMarkerRenderingStrategy when:</a></h4>
<ul>
<li>Using Google Maps or ArcGIS</li>
<li>Have moderate marker counts (1,000-50,000)</li>
<li>Want smooth viewport-based rendering</li>
<li>Markers are loaded locally</li>
</ul>
<h4 id="choose-simplemarkerrenderingstrategy-when"><a class="header" href="#choose-simplemarkerrenderingstrategy-when">Choose SimpleMarkerRenderingStrategy when:</a></h4>
<ul>
<li>Using Mapbox or HERE Maps</li>
<li>Have smaller marker counts (&lt;10,000)</li>
<li>Want minimal overhead</li>
<li>Simple rendering requirements</li>
</ul>
<h4 id="choose-spatialmarkerrenderingstrategy-when"><a class="header" href="#choose-spatialmarkerrenderingstrategy-when">Choose SpatialMarkerRenderingStrategy when:</a></h4>
<ul>
<li>Have very large marker datasets (50,000+)</li>
<li>Need clustering functionality</li>
<li>Want advanced spatial optimization</li>
<li>Can afford higher memory usage</li>
</ul>
<h4 id="choose-remotespatialmarkerrenderingstrategy-when"><a class="header" href="#choose-remotespatialmarkerrenderingstrategy-when">Choose RemoteSpatialMarkerRenderingStrategy when:</a></h4>
<ul>
<li>Markers are stored server-side</li>
<li>Want on-demand loading</li>
<li>Have network connectivity</li>
<li>Need to minimize app memory usage</li>
</ul>
<h2 id="custom-strategy-development"><a class="header" href="#custom-strategy-development">Custom Strategy Development</a></h2>
<h3 id="extending-abstractviewportstrategy"><a class="header" href="#extending-abstractviewportstrategy">Extending AbstractViewportStrategy</a></h3>
<pre><code class="language-kotlin">class CustomMarkerRenderingStrategy&lt;ActualMarker&gt;(
    semaphore: Semaphore = Semaphore(1),
    geocell: HexGeocell = HexGeocellImpl.defaultGeocell()
) : AbstractViewportStrategy&lt;ActualMarker&gt;(semaphore, geocell) {

    override suspend fun onCameraChanged(
        cameraPosition: MapCameraPositionImpl,
        renderer: MarkerOverlayRenderer&lt;ActualMarker&gt;
    ) {
        semaphore.withPermit {
            // Custom rendering logic
            val visibleBounds = cameraPosition.visibleRegion?.bounds ?: return

            // Your custom marker management here
            val markersToShow = determineVisibleMarkers(visibleBounds)
            val markersToHide = determineHiddenMarkers(visibleBounds)

            // Use renderer to update display
            if (markersToHide.isNotEmpty()) {
                renderer.onRemove(markersToHide)
            }

            if (markersToShow.isNotEmpty()) {
                val addParams = markersToShow.map { entity -&gt;
                    object : MarkerOverlayRenderer.AddParams {
                        override val state: MarkerState = entity.state
                        override val bitmapIcon: BitmapIcon = entity.state.icon?.toBitmapIcon() ?: defaultIcon
                    }
                }
                renderer.onAdd(addParams)
            }

            renderer.onPostProcess()
        }
    }

    private fun determineVisibleMarkers(bounds: GeoRectBounds): List&lt;MarkerEntity&lt;ActualMarker&gt;&gt; {
        // Your custom logic to determine which markers should be visible
        return markerManager.findMarkersInBounds(bounds)
    }

    private fun determineHiddenMarkers(bounds: GeoRectBounds): List&lt;MarkerEntity&lt;ActualMarker&gt;&gt; {
        // Your custom logic to determine which markers should be hidden
        return markerManager.allEntities().filter { entity -&gt;
            entity.isRendered &amp;&amp; !bounds.contains(entity.state.position)
        }
    }
}
</code></pre>
<h2 id="performance-optimization-1"><a class="header" href="#performance-optimization-1">Performance Optimization</a></h2>
<h3 id="strategy-configuration"><a class="header" href="#strategy-configuration">Strategy Configuration</a></h3>
<pre><code class="language-kotlin">// High-performance configuration
val performanceStrategy = DefaultMarkerRenderingStrategy&lt;ActualMarker&gt;(
    expandMargin = 0.1,  // Smaller margin for less preloading
    semaphore = Semaphore(2),  // Allow some parallelism
    geocell = HexGeocellImpl(
        baseHexSideLength = 1000.0,  // Larger cells for better performance
        zoom = 15.0  // Lower resolution for speed
    )
)

// Memory-optimized configuration
val memoryStrategy = SimpleMarkerRenderingStrategy&lt;ActualMarker&gt;(
    expandMargin = 0.05,  // Minimal expansion
    geocell = HexGeocellImpl(
        baseHexSideLength = 2000.0,  // Very large cells
        zoom = 12.0  // Lower resolution
    )
)
</code></pre>
<h3 id="monitoring-performance"><a class="header" href="#monitoring-performance">Monitoring Performance</a></h3>
<pre><code class="language-kotlin">@Composable
fun StrategyPerformanceMonitoring() {
    val strategy = remember { DefaultMarkerRenderingStrategy&lt;GoogleMapActualMarker&gt;() }
    var performanceStats by remember { mutableStateOf&lt;String&gt;("") }

    LaunchedEffect(Unit) {
        while (true) {
            delay(5000)

            val stats = strategy.markerManager.getMemoryStats()
            performanceStats = buildString {
                appendLine("Entities: ${stats.entityCount}")
                appendLine("Memory: ${stats.estimatedMemoryKB} KB")
                appendLine("Spatial Index: ${stats.hasSpatialIndex}")
            }
        }
    }

    Column {
        Text(performanceStats)

        // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
        GoogleMapsView(state = mapViewState) {
            // Strategy-managed markers
        }
    }
}
</code></pre>
<h2 id="best-practices-23"><a class="header" href="#best-practices-23">Best Practices</a></h2>
<ol>
<li><strong>Strategy Selection</strong>: Choose strategy based on your specific use case and map provider</li>
<li><strong>Viewport Margins</strong>: Balance preloading (larger margin) vs performance (smaller margin)</li>
<li><strong>Spatial Configuration</strong>: Tune geocell parameters for your data density</li>
<li><strong>Memory Monitoring</strong>: Monitor memory usage in production, especially with large datasets</li>
<li><strong>Testing</strong>: Test with realistic data volumes and usage patterns</li>
<li><strong>Fallback</strong>: Have simpler strategy as fallback for performance issues</li>
</ol>
<h2 id="common-pitfalls-1"><a class="header" href="#common-pitfalls-1">Common Pitfalls</a></h2>
<ol>
<li><strong>Over-Engineering</strong>: Don’t use complex strategies for simple marker scenarios</li>
<li><strong>Memory Leaks</strong>: Ensure proper cleanup of strategy resources</li>
<li><strong>Provider Mismatch</strong>: Using wrong strategy for your map provider can hurt performance</li>
<li><strong>Excessive Preloading</strong>: Large expand margins can cause memory pressure</li>
<li><strong>Thread Safety</strong>: Strategies handle concurrency, but be careful with external modifications</li>
</ol>
<h2 id="migration-guide"><a class="header" href="#migration-guide">Migration Guide</a></h2>
<h3 id="from-basic-marker-management"><a class="header" href="#from-basic-marker-management">From Basic Marker Management</a></h3>
<pre><code class="language-kotlin">// Before: Basic marker management
@Composable
fun BasicMarkers() {
    MapView(state = mapViewState) {
        markers.forEach { markerData -&gt;
            Marker(
                position = markerData.position,
                icon = DefaultIcon()
            )
        }
    }
}

// After: Strategy-based management
@Composable
fun StrategyMarkers() {
    val strategy = remember { DefaultMarkerRenderingStrategy&lt;ActualMarker&gt;() }

    LaunchedEffect(markers) {
        markers.forEach { markerData -&gt;
            val entity = MarkerEntity(
                state = MarkerState(
                    id = markerData.id,
                    position = markerData.position,
                    icon = DefaultIcon()
                )
            )
            strategy.markerManager.registerEntity(entity)
        }
    }

    MapView(state = mapViewState) {
        // Strategy handles all marker rendering
    }
}
</code></pre>
<p>The marker strategy module provides sophisticated marker management capabilities for applications requiring high performance with large datasets or complex rendering requirements.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="marker-native-strategy-experimental"><a class="header" href="#marker-native-strategy-experimental">Marker Native Strategy (Experimental)</a></h1>
<p>The <code>mapconductor-marker-native-strategy</code> module provides high-performance marker management using native C++ spatial indexing. This experimental module dramatically improves performance for applications with large numbers of markers (10,000+).</p>
<blockquote>
<p><strong>⚠️ Experimental Module</strong>: This module is highly experimental and requires native library support. Use in production with extreme caution.</p>
</blockquote>
<h2 id="overview-6"><a class="header" href="#overview-6">Overview</a></h2>
<p>The marker native strategy replaces Java-based spatial indexing with optimized C++ implementations, providing:</p>
<ul>
<li><strong>90% Memory Reduction</strong>: Compared to standard marker management</li>
<li><strong>Native Spatial Queries</strong>: C++ spatial indexing for maximum performance</li>
<li><strong>Efficient Viewport Culling</strong>: Only renders markers within the viewport</li>
<li><strong>Parallel Processing</strong>: Multi-threaded marker operations</li>
<li><strong>Minimal Java Overhead</strong>: Native code as single source of truth</li>
</ul>
<h2 id="performance-characteristics-2"><a class="header" href="#performance-characteristics-2">Performance Characteristics</a></h2>
<h3 id="memory-usage"><a class="header" href="#memory-usage">Memory Usage</a></h3>
<ul>
<li><strong>Standard MarkerManager</strong>: ~1MB per 1,000 markers</li>
<li><strong>NativeMarkerManager</strong>: ~100KB per 1,000 markers</li>
<li><strong>Optimized Storage</strong>: No duplicate entity storage</li>
</ul>
<h3 id="query-performance"><a class="header" href="#query-performance">Query Performance</a></h3>
<ul>
<li><strong>Standard Spatial Query</strong>: O(log n) with Java overhead</li>
<li><strong>Native Spatial Query</strong>: O(log n) with C++ optimization</li>
<li><strong>Large Dataset</strong>: 10x-100x performance improvement for 100,000+ markers</li>
</ul>
<h2 id="installation-2"><a class="header" href="#installation-2">Installation</a></h2>
<p>Add the native strategy module to your <code>build.gradle</code>:</p>
<pre><code class="language-kotlin">dependencies {
    implementation "com.mapconductor:marker-native-strategy"

    // Required: Core module
    implementation "com.mapconductor:mapconductor-bom:$version"
    // Required: Core module
    implementation "com.mapconductor:core"

    // Choose your map provider
    implementation "com.mapconductor:for-googlemaps"
}
</code></pre>
<h3 id="native-library-setup"><a class="header" href="#native-library-setup">Native Library Setup</a></h3>
<p>The module requires native C++ libraries. Ensure your app supports the required ABIs:</p>
<pre><code class="language-kotlin">android {
    defaultConfig {
        ndk {
            abiFilters 'arm64-v8a', 'armeabi-v7a', 'x86', 'x86_64'
        }
    }
}
</code></pre>
<h2 id="core-components"><a class="header" href="#core-components">Core Components</a></h2>
<h3 id="nativemarkermanager"><a class="header" href="#nativemarkermanager">NativeMarkerManager</a></h3>
<p>High-performance marker manager using native spatial indexing:</p>
<pre><code class="language-kotlin">import com.mapconductor.marker.nativestrategy.NativeMarkerManager
import com.mapconductor.core.geocell.HexGeocellImpl

// Create native marker manager
val nativeManager = NativeMarkerManager&lt;ActualMarker&gt;(
    hexGeocell = HexGeocellImpl.defaultGeocell()
)

// Use like standard MarkerManager
nativeManager.registerEntity(markerEntity)
val nearestMarker = nativeManager.findNearest(position)
val markersInBounds = nativeManager.findMarkersInBounds(bounds)
</code></pre>
<h3 id="native-rendering-strategies"><a class="header" href="#native-rendering-strategies">Native Rendering Strategies</a></h3>
<h4 id="simplenativeparallelstrategy"><a class="header" href="#simplenativeparallelstrategy">SimpleNativeParallelStrategy</a></h4>
<p>Parallel marker rendering with native indexing:</p>
<pre><code class="language-kotlin">import com.mapconductor.marker.nativestrategy.SimpleNativeParallelStrategy

val strategy = SimpleNativeParallelStrategy&lt;ActualMarker&gt;(
    expandMargin = 0.2,        // 20% viewport expansion
    maxConcurrency = 4,        // Parallel threads
    geocell = HexGeocellImpl.defaultGeocell()
)
</code></pre>
<h4 id="nativespatialmarkerrenderingstrategy"><a class="header" href="#nativespatialmarkerrenderingstrategy">NativeSpatialMarkerRenderingStrategy</a></h4>
<p>Advanced spatial rendering with clustering:</p>
<pre><code class="language-kotlin">import com.mapconductor.marker.nativestrategy.NativeSpatialMarkerRenderingStrategy

val spatialStrategy = NativeSpatialMarkerRenderingStrategy&lt;ActualMarker&gt;(
    clusteringEnabled = true,
    clusterThreshold = 100,    // Cluster when &gt; 100 markers in area
    geocell = HexGeocellImpl.defaultGeocell()
)
</code></pre>
<h2 id="basic-usage-4"><a class="header" href="#basic-usage-4">Basic Usage</a></h2>
<h3 id="simple-native-manager"><a class="header" href="#simple-native-manager">Simple Native Manager</a></h3>
<pre><code class="language-kotlin">@Composable
fun BasicNativeExample() {
    // Create native marker manager
    val nativeManager = remember {
        NativeMarkerManager&lt;GoogleMapActualMarker&gt;(
            hexGeocell = HexGeocellImpl.defaultGeocell()
        )
    }

    // Add markers to native manager
    LaunchedEffect(Unit) {
        val markers = generateLargeMarkerDataset() // 10,000+ markers
        markers.forEach { markerData -&gt;
            val entity = MarkerEntity(
                state = MarkerState(
                    id = markerData.id,
                    position = markerData.position,
                    icon = DefaultIcon()
                )
            )
            nativeManager.registerEntity(entity)
        }
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    MapView(state = mapViewState) {
        // Markers are managed by native strategy
        // No need to manually add Marker composables
    }

    DisposableEffect(Unit) {
        onDispose {
            nativeManager.destroy() // Important: cleanup native resources
        }
    }
}
</code></pre>
<h3 id="performance-monitoring"><a class="header" href="#performance-monitoring">Performance Monitoring</a></h3>
<pre><code class="language-kotlin">@Composable
fun NativePerformanceExample() {
    val nativeManager = remember {
        NativeMarkerManager&lt;GoogleMapActualMarker&gt;(
            hexGeocell = HexGeocellImpl.defaultGeocell()
        )
    }

    var stats by remember { mutableStateOf&lt;NativeMarkerManagerStats?&gt;(null) }

    // Monitor performance
    LaunchedEffect(Unit) {
        while (true) {
            delay(5000) // Update every 5 seconds
            stats = nativeManager.getNativeMemoryStats()
        }
    }

    Column {
        stats?.let { s -&gt;
            Text("Markers: ${s.entityCount}")
            Text("Native Index: ${s.nativeIndexCount}")
            Text("Memory: ${s.estimatedMemoryKB} KB")
            Text("Pure Native: ${s.usesPureNativeIndex}")
        }

        // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
        MapView(state = mapViewState) {
            // Native-managed markers
        }
    }
}
</code></pre>
<h2 id="advanced-usage-4"><a class="header" href="#advanced-usage-4">Advanced Usage</a></h2>
<h3 id="parallel-rendering-strategy"><a class="header" href="#parallel-rendering-strategy">Parallel Rendering Strategy</a></h3>
<pre><code class="language-kotlin">@Composable
fun ParallelRenderingExample() {
    val parallelStrategy = remember {
        SimpleNativeParallelStrategy&lt;GoogleMapActualMarker&gt;(
            expandMargin = 0.3,        // Larger viewport expansion
            maxConcurrency = 6,        // More parallel threads
            geocell = HexGeocellImpl(
                baseHexSideLength = 1000.0,  // Optimized cell size
                zoom = 15.0
            )
        )
    }

    // Configure marker controller with parallel strategy
    LaunchedEffect(mapViewState) {
        mapViewState.getMapViewHolder()?.let { holder -&gt;
            // Setup parallel strategy with map controller
            // Implementation depends on map provider
        }
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    MapView(state = mapViewState) {
        // Parallel-rendered markers
    }
}
</code></pre>
<h3 id="dynamic-marker-loading-1"><a class="header" href="#dynamic-marker-loading-1">Dynamic Marker Loading</a></h3>
<pre><code class="language-kotlin">@Composable
fun DynamicNativeLoadingExample() {
    val nativeManager = remember {
        NativeMarkerManager&lt;GoogleMapActualMarker&gt;(
            hexGeocell = HexGeocellImpl.defaultGeocell()
        )
    }

    var currentBounds by remember { mutableStateOf&lt;GeoRectBounds?&gt;(null) }
    var visibleMarkers by remember { mutableStateOf&lt;List&lt;MarkerEntity&lt;GoogleMapActualMarker&gt;&gt;&gt;(emptyList()) }

    // Load markers dynamically based on viewport
    LaunchedEffect(currentBounds) {
        currentBounds?.let { bounds -&gt;
            // Native spatial query is extremely fast
            visibleMarkers = nativeManager.findMarkersInBounds(bounds)
        }
    }

    Column {
        Text("Visible Markers: ${visibleMarkers.size}")

        // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
        MapView(
            state = mapViewState,
            onCameraMove = { cameraPosition -&gt;
                currentBounds = cameraPosition.visibleRegion?.bounds
            }
        ) {
            // Only visible markers are processed
        }
    }
}
</code></pre>
<h3 id="clustering-with-native-strategy"><a class="header" href="#clustering-with-native-strategy">Clustering with Native Strategy</a></h3>
<pre><code class="language-kotlin">@Composable
fun NativeClusteringExample() {
    val clusteringStrategy = remember {
        NativeSpatialMarkerRenderingStrategy&lt;GoogleMapActualMarker&gt;(
            clusteringEnabled = true,
            clusterThreshold = 50,     // Cluster when &gt; 50 markers nearby
            clusterRadius = 100.0,     // 100-meter clustering radius
            geocell = HexGeocellImpl.defaultGeocell()
        )
    }

    val nativeManager = remember {
        NativeMarkerManager&lt;GoogleMapActualMarker&gt;(
            hexGeocell = HexGeocellImpl.defaultGeocell()
        )
    }

    // Add large dataset for clustering
    LaunchedEffect(Unit) {
        val denseMarkers = generateDenseMarkerCluster(
            center = GeoPointImpl.fromLatLong(37.7749, -122.4194),
            count = 1000,
            radius = 500.0 // 500 meters
        )

        denseMarkers.forEach { markerData -&gt;
            val entity = MarkerEntity(
                state = MarkerState(
                    id = markerData.id,
                    position = markerData.position,
                    icon = DefaultIcon(fillColor = Color.Blue, scale = 0.8f)
                )
            )
            nativeManager.registerEntity(entity)
        }
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    MapView(state = mapViewState) {
        // Native clustering automatically groups nearby markers
    }
}
</code></pre>
<h2 id="native-index-operations"><a class="header" href="#native-index-operations">Native Index Operations</a></h2>
<h3 id="direct-spatial-queries"><a class="header" href="#direct-spatial-queries">Direct Spatial Queries</a></h3>
<pre><code class="language-kotlin">fun performNativeQueries(nativeManager: NativeMarkerManager&lt;ActualMarker&gt;) {
    val center = GeoPointImpl.fromLatLong(37.7749, -122.4194)
    val bounds = GeoRectBounds(
        southWest = GeoPointImpl.fromLatLong(37.7700, -122.4250),
        northEast = GeoPointImpl.fromLatLong(37.7800, -122.4150)
    )

    // Native spatial queries are extremely fast
    val nearestMarker = nativeManager.findNearest(center)
    val boundedMarkers = nativeManager.findMarkersInBounds(bounds)
    val totalMarkers = nativeManager.allEntities().size

    // Memory and performance stats
    val stats = nativeManager.getNativeMemoryStats()
    println("Query performance: ${stats.nativeIndexCount} indexed markers")
    println("Memory usage: ${stats.estimatedMemoryKB} KB")
}
</code></pre>
<h3 id="batch-operations"><a class="header" href="#batch-operations">Batch Operations</a></h3>
<pre><code class="language-kotlin">suspend fun batchNativeOperations(nativeManager: NativeMarkerManager&lt;ActualMarker&gt;) {
    val markersBatch = generateMarkerBatch(10000) // 10,000 markers

    // Efficient batch registration
    withContext(Dispatchers.Default) {
        markersBatch.forEach { markerData -&gt;
            val entity = MarkerEntity(
                state = MarkerState(
                    id = markerData.id,
                    position = markerData.position,
                    icon = DefaultIcon()
                )
            )
            nativeManager.registerEntity(entity)
        }
    }

    // Verify registration
    val totalMarkers = nativeManager.allEntities().size
    println("Registered $totalMarkers markers in native index")
}
</code></pre>
<h2 id="memory-management-4"><a class="header" href="#memory-management-4">Memory Management</a></h2>
<h3 id="resource-cleanup"><a class="header" href="#resource-cleanup">Resource Cleanup</a></h3>
<pre><code class="language-kotlin">@Composable
fun ResourceManagementExample() {
    val nativeManager = remember {
        NativeMarkerManager&lt;GoogleMapActualMarker&gt;(
            hexGeocell = HexGeocellImpl.defaultGeocell()
        )
    }

    // Proper cleanup is crucial for native resources
    DisposableEffect(nativeManager) {
        onDispose {
            // Cleanup native resources
            nativeManager.destroy()
        }
    }

    // Monitor memory usage
    var memoryStats by remember { mutableStateOf&lt;NativeMarkerManagerStats?&gt;(null) }

    LaunchedEffect(Unit) {
        while (true) {
            delay(10000) // Check every 10 seconds
            memoryStats = nativeManager.getNativeMemoryStats()

            // Log memory usage for monitoring
            memoryStats?.let { stats -&gt;
                if (stats.estimatedMemoryKB &gt; 10000) { // &gt; 10MB
                    println("High memory usage detected: ${stats.estimatedMemoryKB} KB")
                }
            }
        }
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
    MapView(state = mapViewState) {
        // Native-managed markers
    }
}
</code></pre>
<h2 id="performance-optimization-2"><a class="header" href="#performance-optimization-2">Performance Optimization</a></h2>
<h3 id="configuration-tuning"><a class="header" href="#configuration-tuning">Configuration Tuning</a></h3>
<pre><code class="language-kotlin">// Optimal configuration for large datasets
val optimizedGeocell = HexGeocellImpl(
    baseHexSideLength = 500.0,  // Smaller cells for dense data
    zoom = 18.0                 // Higher resolution
)

val optimizedManager = NativeMarkerManager&lt;ActualMarker&gt;(
    hexGeocell = optimizedGeocell
)

// Optimal parallel strategy
val optimizedStrategy = SimpleNativeParallelStrategy&lt;ActualMarker&gt;(
    expandMargin = 0.1,         // Smaller expansion for performance
    maxConcurrency = Runtime.getRuntime().availableProcessors(),
    geocell = optimizedGeocell
)
</code></pre>
<h3 id="benchmark-testing"><a class="header" href="#benchmark-testing">Benchmark Testing</a></h3>
<pre><code class="language-kotlin">suspend fun benchmarkNativePerformance() {
    val standardManager = MarkerManager&lt;ActualMarker&gt;(HexGeocellImpl.defaultGeocell())
    val nativeManager = NativeMarkerManager&lt;ActualMarker&gt;(HexGeocellImpl.defaultGeocell())

    val testMarkers = generateTestDataset(50000) // 50,000 markers

    // Benchmark registration
    val standardTime = measureTimeMillis {
        testMarkers.forEach { standardManager.registerEntity(it) }
    }

    val nativeTime = measureTimeMillis {
        testMarkers.forEach { nativeManager.registerEntity(it) }
    }

    // Benchmark spatial queries
    val testBounds = GeoRectBounds(
        southWest = GeoPointImpl.fromLatLong(37.7700, -122.4250),
        northEast = GeoPointImpl.fromLatLong(37.7800, -122.4150)
    )

    val standardQueryTime = measureTimeMillis {
        repeat(1000) { standardManager.findMarkersInBounds(testBounds) }
    }

    val nativeQueryTime = measureTimeMillis {
        repeat(1000) { nativeManager.findMarkersInBounds(testBounds) }
    }

    println("Registration - Standard: ${standardTime}ms, Native: ${nativeTime}ms")
    println("Queries - Standard: ${standardQueryTime}ms, Native: ${nativeQueryTime}ms")
}
</code></pre>
<h2 id="best-practices-24"><a class="header" href="#best-practices-24">Best Practices</a></h2>
<ol>
<li><strong>Resource Management</strong>: Always call <code>destroy()</code> on NativeMarkerManager when done</li>
<li><strong>Batch Operations</strong>: Use batch registration for large datasets</li>
<li><strong>Memory Monitoring</strong>: Monitor native memory usage in production</li>
<li><strong>Testing</strong>: Thoroughly test with your specific data patterns</li>
<li><strong>Fallback Strategy</strong>: Have non-native fallback for unsupported devices</li>
</ol>
<h2 id="limitations-and-considerations-1"><a class="header" href="#limitations-and-considerations-1">Limitations and Considerations</a></h2>
<ol>
<li><strong>Platform Support</strong>: Requires native library support for target ABIs</li>
<li><strong>Memory Management</strong>: Native memory is not garbage collected</li>
<li><strong>Debugging</strong>: Native crashes are harder to debug than Java crashes</li>
<li><strong>Binary Size</strong>: Increases APK size due to native libraries</li>
<li><strong>Compatibility</strong>: May not work on all devices/emulators</li>
</ol>
<h2 id="troubleshooting-7"><a class="header" href="#troubleshooting-7">Troubleshooting</a></h2>
<h3 id="native-library-loading-issues"><a class="header" href="#native-library-loading-issues">Native Library Loading Issues</a></h3>
<pre><code class="language-kotlin">// Check native library availability
try {
    val nativeManager = NativeMarkerManager&lt;ActualMarker&gt;(
        hexGeocell = HexGeocellImpl.defaultGeocell()
    )
    // Native library loaded successfully
} catch (e: UnsatisfiedLinkError) {
    // Fallback to standard marker manager
    val standardManager = MarkerManager&lt;ActualMarker&gt;(
        hexGeocell = HexGeocellImpl.defaultGeocell()
    )
}
</code></pre>
<h3 id="memory-leak-prevention"><a class="header" href="#memory-leak-prevention">Memory Leak Prevention</a></h3>
<pre><code class="language-kotlin">class MarkerActivity : ComponentActivity() {
    private var nativeManager: NativeMarkerManager&lt;ActualMarker&gt;? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        nativeManager = NativeMarkerManager(HexGeocellImpl.defaultGeocell())
    }

    override fun onDestroy() {
        super.onDestroy()

        // Critical: cleanup native resources
        nativeManager?.destroy()
        nativeManager = null
    }
}
</code></pre>
<p>The marker native strategy module provides significant performance improvements for marker-heavy applications, but requires careful resource management and thorough testing due to its experimental nature.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-usage-examples"><a class="header" href="#basic-usage-examples">Basic Usage Examples</a></h1>
<p>This section provides practical examples of using MapConductor components in common scenarios.</p>
<h2 id="getting-started-1"><a class="header" href="#getting-started-1">Getting Started</a></h2>
<h3 id="simple-map-with-marker"><a class="header" href="#simple-map-with-marker">Simple Map with Marker</a></h3>
<pre><code class="language-kotlin">@Composable
fun SimpleMapExample() {
    val mapViewState = rememberGoogleMapViewState()

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
        Marker(
            position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
            icon = DefaultIcon(label = "SF"),
            extra = "San Francisco"
        )
    }
}
</code></pre>
<h3 id="multi-provider-map"><a class="header" href="#multi-provider-map">Multi-Provider Map</a></h3>
<pre><code class="language-kotlin">@Composable
fun MultiProviderExample() {
    var provider by remember { mutableStateOf("google") }

    val mapViewState = remember(provider) {
        when (provider) {
            "google" -&gt; rememberGoogleMapViewState()
            "mapbox" -&gt; rememberMapboxMapViewState()
            "here" -&gt; rememberHereMapViewState()
            "arcgis" -&gt; rememberArcGISMapViewState()
            else -&gt; rememberGoogleMapViewState()
        }
    }

    Column {
        Row {
            Button(onClick = { provider = "google" }) { Text("Google") }
            Button(onClick = { provider = "mapbox" }) { Text("Mapbox") }
            Button(onClick = { provider = "here" }) { Text("HERE") }
            Button(onClick = { provider = "arcgis" }) { Text("ArcGIS") }
        }

        // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
            Marker(
                position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
                icon = DefaultIcon(label = provider.uppercase())
            )
        }
    }
}
</code></pre>
<h2 id="interactive-examples"><a class="header" href="#interactive-examples">Interactive Examples</a></h2>
<h3 id="click-and-add-markers"><a class="header" href="#click-and-add-markers">Click and Add Markers</a></h3>
<pre><code class="language-kotlin">@Composable
fun ClickToAddMarkersExample() {
    var markers by remember { mutableStateOf&lt;List&lt;MarkerState&gt;&gt;(emptyList()) }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(
        state = mapViewState,
        onMapClick = { geoPoint -&gt;
            val newMarker = MarkerState(
                position = geoPoint,
                icon = DefaultIcon(
                    label = "${markers.size + 1}",
                    fillColor = Color.Blue
                ),
                extra = "Marker ${markers.size + 1}"
            )
            markers = markers + newMarker
        },
        onMarkerClick = { markerState -&gt;
            // Remove clicked marker
            markers = markers.filter { it.id != markerState.id }
        }
    ) {
        markers.forEach { marker -&gt;
            Marker(marker)
        }
    }
}
</code></pre>
<h3 id="route-planning"><a class="header" href="#route-planning">Route Planning</a></h3>
<pre><code class="language-kotlin">@Composable
fun RoutePlanningExample() {
    var waypoints by remember { mutableStateOf&lt;List&lt;GeoPoint&gt;&gt;(emptyList()) }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(
        state = mapViewState,
        onMapClick = { geoPoint -&gt;
            waypoints = waypoints + geoPoint
        }
    ) {
        // Draw route if we have multiple points
        if (waypoints.size &gt;= 2) {
            Polyline(
                points = waypoints,
                strokeColor = Color.Blue,
                strokeWidth = 4.dp
            )
        }

        // Draw waypoint markers
        waypoints.forEachIndexed { index, point -&gt;
            Marker(
                position = point,
                icon = DefaultIcon(
                    fillColor = when (index) {
                        0 -&gt; Color.Green
                        waypoints.size - 1 -&gt; Color.Red
                        else -&gt; Color.Blue
                    },
                    label = "${index + 1}",
                    scale = 0.8f
                )
            )
        }
    }
}
</code></pre>
<h2 id="area-management"><a class="header" href="#area-management">Area Management</a></h2>
<h3 id="zone-drawing"><a class="header" href="#zone-drawing">Zone Drawing</a></h3>
<pre><code class="language-kotlin">@Composable
fun ZoneDrawingExample() {
    var zones by remember { mutableStateOf&lt;List&lt;PolygonState&gt;&gt;(emptyList()) }
    var currentZone by remember { mutableStateOf&lt;List&lt;GeoPoint&gt;&gt;(emptyList()) }
    var isDrawing by remember { mutableStateOf(false) }

    Column {
        Row {
            Button(
                onClick = {
                    isDrawing = true
                    currentZone = emptyList()
                }
            ) {
                Text("Start Zone")
            }

            Button(
                onClick = {
                    if (currentZone.size &gt;= 3) {
                        val closedZone = currentZone + currentZone.first()
                        zones = zones + PolygonState(
                            points = closedZone,
                            strokeColor = Color.Red,
                            fillColor = Color.Red.copy(alpha = 0.3f),
                            extra = "Zone ${zones.size + 1}"
                        )
                    }
                    isDrawing = false
                    currentZone = emptyList()
                }
            ) {
                Text("Finish Zone")
            }

            Button(onClick = { zones = emptyList() }) {
                Text("Clear All")
            }
        }

        // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(
            state = mapViewState,
            onMapClick = { geoPoint -&gt;
                if (isDrawing) {
                    currentZone = currentZone + geoPoint
                }
            }
        ) {
            // Draw completed zones
            zones.forEach { zone -&gt;
                Polygon(zone)
            }

            // Draw current zone being created
            if (currentZone.size &gt;= 3) {
                Polygon(
                    points = currentZone + currentZone.first(),
                    strokeColor = Color.Gray,
                    fillColor = Color.Gray.copy(alpha = 0.1f)
                )
            }

            // Draw current zone vertices
            currentZone.forEachIndexed { index, point -&gt;
                Marker(
                    position = point,
                    icon = DefaultIcon(
                        fillColor = Color.Orange,
                        label = "${index + 1}",
                        scale = 0.6f
                    )
                )
            }
        }
    }
}
</code></pre>
<h2 id="data-visualization"><a class="header" href="#data-visualization">Data Visualization</a></h2>
<h3 id="heat-map-simulation"><a class="header" href="#heat-map-simulation">Heat Map Simulation</a></h3>
<pre><code class="language-kotlin">@Composable
fun HeatMapExample() {
    val dataPoints = remember {
        List(50) {
            val lat = 37.7749 + (Random.nextFloat() - 0.5f) * 0.02
            val lng = -122.4194 + (Random.nextFloat() - 0.5f) * 0.02
            val intensity = Random.nextFloat()
            Triple(GeoPointImpl.fromLatLong(lat, lng), intensity, it)
        }
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
        dataPoints.forEach { (point, intensity, id) -&gt;
            Circle(
                center = point,
                radius = intensity * 200.0,
                strokeColor = Color.Transparent,
                fillColor = Color.Red.copy(alpha = intensity * 0.5f),
                extra = "Data point $id"
            )
        }
    }
}
</code></pre>
<h3 id="clustering-simulation"><a class="header" href="#clustering-simulation">Clustering Simulation</a></h3>
<pre><code class="language-kotlin">@Composable
fun ClusteringExample() {
    val zoom by remember { mutableStateOf(10f) }

    val markers = remember {
        List(100) {
            val lat = 37.7749 + (Random.nextFloat() - 0.5f) * 0.1
            val lng = -122.4194 + (Random.nextFloat() - 0.5f) * 0.1
            GeoPointImpl.fromLatLong(lat, lng)
        }
    }

    // Simple clustering based on distance
    val clusteredMarkers = remember(zoom) {
        if (zoom &lt; 12) {
            // Group nearby markers
            val clusters = mutableListOf&lt;Pair&lt;GeoPoint, Int&gt;&gt;()
            val processed = mutableSetOf&lt;Int&gt;()

            markers.forEachIndexed { index, marker -&gt;
                if (index !in processed) {
                    val cluster = markers.filterIndexed { i, other -&gt;
                        if (i !in processed) {
                            val distance = calculateDistance(marker, other)
                            distance &lt; 1000 // 1km clustering
                        } else false
                    }
                    cluster.forEach { m -&gt;
                        processed.add(markers.indexOf(m))
                    }
                    clusters.add(marker to cluster.size)
                }
            }
            clusters
        } else {
            markers.map { it to 1 }
        }
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
        clusteredMarkers.forEach { (position, count) -&gt;
            Marker(
                position = position,
                icon = DefaultIcon(
                    fillColor = if (count &gt; 1) Color.Red else Color.Blue,
                    label = if (count &gt; 1) count.toString() else "•",
                    scale = if (count &gt; 1) 1.2f else 0.8f
                )
            )
        }
    }
}
</code></pre>
<h2 id="real-time-updates"><a class="header" href="#real-time-updates">Real-time Updates</a></h2>
<h3 id="live-tracking"><a class="header" href="#live-tracking">Live Tracking</a></h3>
<pre><code class="language-kotlin">@Composable
fun LiveTrackingExample() {
    var currentPosition by remember {
        mutableStateOf(GeoPointImpl.fromLatLong(37.7749, -122.4194))
    }
    var trail by remember { mutableStateOf&lt;List&lt;GeoPoint&gt;&gt;(emptyList()) }

    // Simulate movement
    LaunchedEffect(Unit) {
        while (true) {
            delay(1000)
            val newLat = currentPosition.latitude + (Random.nextFloat() - 0.5f) * 0.001
            val newLng = currentPosition.longitude + (Random.nextFloat() - 0.5f) * 0.001
            val newPosition = GeoPointImpl.fromLatLong(newLat, newLng)

            trail = (trail + currentPosition).takeLast(20) // Keep last 20 points
            currentPosition = newPosition
        }
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
        // Trail
        if (trail.size &gt;= 2) {
            Polyline(
                points = trail,
                strokeColor = Color.Blue.copy(alpha = 0.7f),
                strokeWidth = 3.dp
            )
        }

        // Current position
        Marker(
            position = currentPosition,
            icon = DefaultIcon(
                fillColor = Color.Red,
                label = "📍",
                scale = 1.2f
            )
        )

        // Accuracy circle
        Circle(
            center = currentPosition,
            radius = 50.0,
            strokeColor = Color.Blue.copy(alpha = 0.5f),
            fillColor = Color.Blue.copy(alpha = 0.1f)
        )
    }
}
</code></pre>
<h2 id="utility-functions"><a class="header" href="#utility-functions">Utility Functions</a></h2>
<pre><code class="language-kotlin">fun calculateDistance(point1: GeoPoint, point2: GeoPoint): Double {
    // Simplified distance calculation in meters
    val latDiff = point1.latitude - point2.latitude
    val lngDiff = point1.longitude - point2.longitude
    return sqrt(latDiff * latDiff + lngDiff * lngDiff) * 111000 // Rough conversion
}

fun GeoPointImpl.Companion.fromLatLong(lat: Double, lng: Double): GeoPointImpl {
    return GeoPointImpl(lat, lng)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-usage-examples"><a class="header" href="#advanced-usage-examples">Advanced Usage Examples</a></h1>
<p>This section covers advanced patterns and techniques for building sophisticated mapping applications with MapConductor.</p>
<h2 id="complex-interactions"><a class="header" href="#complex-interactions">Complex Interactions</a></h2>
<h3 id="multi-selection-with-info-panel"><a class="header" href="#multi-selection-with-info-panel">Multi-Selection with Info Panel</a></h3>
<pre><code class="language-kotlin">@Composable
fun MultiSelectionExample() {
    var selectedMarkers by remember { mutableStateOf&lt;Set&lt;String&gt;&gt;(emptySet()) }

    val markers = remember {
        listOf(
            MarkerState(
                position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
                icon = DefaultIcon(fillColor = Color.Blue, label = "A"),
                extra = "Location A"
            ),
            MarkerState(
                position = GeoPointImpl.fromLatLong(37.7849, -122.4094),
                icon = DefaultIcon(fillColor = Color.Green, label = "B"),
                extra = "Location B"
            ),
            MarkerState(
                position = GeoPointImpl.fromLatLong(37.7649, -122.4294),
                icon = DefaultIcon(fillColor = Color.Red, label = "C"),
                extra = "Location C"
            )
        )
    }

    Row {
        // Map
        // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(
            modifier = Modifier.weight(1f),
            state = mapViewState,
            onMarkerClick = { markerState -&gt;
                selectedMarkers = if (markerState.id in selectedMarkers) {
                    selectedMarkers - markerState.id
                } else {
                    selectedMarkers + markerState.id
                }
            }
        ) {
            markers.forEach { marker -&gt;
                val isSelected = marker.id in selectedMarkers
                Marker(
                    state = marker.copy(
                        icon = DefaultIcon(
                            fillColor = if (isSelected) Color.Yellow else marker.icon?.let {
                                when (marker.extra) {
                                    "Location A" -&gt; Color.Blue
                                    "Location B" -&gt; Color.Green
                                    else -&gt; Color.Red
                                }
                            } ?: Color.Gray,
                            label = marker.extra?.toString()?.last()?.toString() ?: "?",
                            scale = if (isSelected) 1.3f else 1.0f
                        )
                    )
                )
            }
        }

        // Info Panel
        Card(modifier = Modifier.width(200.dp)) {
            Column(modifier = Modifier.padding(16.dp)) {
                Text("Selected: ${selectedMarkers.size}")
                selectedMarkers.forEach { markerId -&gt;
                    val marker = markers.find { it.id == markerId }
                    marker?.let {
                        Text("• ${it.extra}")
                    }
                }
            }
        }
    }
}
</code></pre>
<h3 id="dynamic-layer-management"><a class="header" href="#dynamic-layer-management">Dynamic Layer Management</a></h3>
<pre><code class="language-kotlin">@Composable
fun LayerManagementExample() {
    var visibleLayers by remember { mutableStateOf(setOf("markers", "areas")) }

    val layerConfig = mapOf(
        "markers" to "Show Markers",
        "areas" to "Show Areas",
        "routes" to "Show Routes",
        "heatmap" to "Show Heatmap"
    )

    Column {
        // Layer controls
        Card(modifier = Modifier.padding(8.dp)) {
            Column(modifier = Modifier.padding(16.dp)) {
                Text("Layers", style = MaterialTheme.typography.h6)
                layerConfig.forEach { (layerId, label) -&gt;
                    Row(verticalAlignment = Alignment.CenterVertically) {
                        Checkbox(
                            checked = layerId in visibleLayers,
                            onCheckedChange = { checked -&gt;
                                visibleLayers = if (checked) {
                                    visibleLayers + layerId
                                } else {
                                    visibleLayers - layerId
                                }
                            }
                        )
                        Text(label)
                    }
                }
            }
        }

        // Map with conditional layers
        // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
            // Markers layer
            if ("markers" in visibleLayers) {
                repeat(10) { i -&gt;
                    Marker(
                        position = GeoPointImpl.fromLatLong(
                            37.7749 + i * 0.01,
                            -122.4194 + i * 0.01
                        ),
                        icon = DefaultIcon(fillColor = Color.Blue, label = "$i")
                    )
                }
            }

            // Areas layer
            if ("areas" in visibleLayers) {
                repeat(3) { i -&gt;
                    Circle(
                        center = GeoPointImpl.fromLatLong(
                            37.7749 + i * 0.02,
                            -122.4194 + i * 0.02
                        ),
                        radius = 500.0 + i * 200,
                        strokeColor = Color.Red,
                        fillColor = Color.Red.copy(alpha = 0.2f)
                    )
                }
            }

            // Routes layer
            if ("routes" in visibleLayers) {
                Polyline(
                    points = listOf(
                        GeoPointImpl.fromLatLong(37.7749, -122.4194),
                        GeoPointImpl.fromLatLong(37.7849, -122.4094),
                        GeoPointImpl.fromLatLong(37.7949, -122.3994)
                    ),
                    strokeColor = Color.Green,
                    strokeWidth = 4.dp
                )
            }

            // Heatmap layer (simulated with circles)
            if ("heatmap" in visibleLayers) {
                repeat(20) { i -&gt;
                    Circle(
                        center = GeoPointImpl.fromLatLong(
                            37.7749 + Random.nextFloat() * 0.02,
                            -122.4194 + Random.nextFloat() * 0.02
                        ),
                        radius = 100.0,
                        strokeColor = Color.Transparent,
                        fillColor = Color.Red.copy(alpha = 0.3f)
                    )
                }
            }
        }
    }
}
</code></pre>
<h2 id="performance-optimization-3"><a class="header" href="#performance-optimization-3">Performance Optimization</a></h2>
<h3 id="marker-clustering"><a class="header" href="#marker-clustering">Marker Clustering</a></h3>
<pre><code class="language-kotlin">data class MarkerCluster(
    val center: GeoPoint,
    val markers: List&lt;MarkerState&gt;,
    val radius: Double
) : java.io.Serializable

@Composable
fun MarkerClusteringExample() {
    var zoomLevel by remember { mutableStateOf(10f) }

    val allMarkers = remember {
        List(200) { i -&gt;
            MarkerState(
                position = GeoPointImpl.fromLatLong(
                    37.7749 + (Random.nextFloat() - 0.5f) * 0.1,
                    -122.4194 + (Random.nextFloat() - 0.5f) * 0.1
                ),
                extra = "Marker $i"
            )
        }
    }

    val displayedItems = remember(zoomLevel) {
        if (zoomLevel &gt; 13) {
            // Show individual markers at high zoom
            allMarkers.map { Either.Left(it) }
        } else {
            // Cluster at low zoom
            clusterMarkers(allMarkers, 1000.0 / zoomLevel).map { Either.Right(it) }
        }
    }

    Column {
        Slider(
            value = zoomLevel,
            onValueChange = { zoomLevel = it },
            valueRange = 8f..16f,
            modifier = Modifier.padding(16.dp)
        )
        Text("Zoom: ${zoomLevel.toInt()}")

        // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
            displayedItems.forEach { item -&gt;
                when (item) {
                    is Either.Left -&gt; {
                        // Individual marker
                        Marker(item.value)
                    }
                    is Either.Right -&gt; {
                        // Cluster
                        val cluster = item.value
                        Marker(
                            position = cluster.center,
                            icon = DefaultIcon(
                                fillColor = Color.Red,
                                label = cluster.markers.size.toString(),
                                scale = 1.2f
                            ),
                            extra = "Cluster of ${cluster.markers.size} markers"
                        )
                    }
                }
            }
        }
    }
}

sealed class Either&lt;out L, out R&gt; : java.io.Serializable {
    data class Left&lt;out L&gt;(val value: L) : Either&lt;L, Nothing&gt;()
    data class Right&lt;out R&gt;(val value: R) : Either&lt;Nothing, R&gt;()
}

fun clusterMarkers(markers: List&lt;MarkerState&gt;, clusterRadius: Double): List&lt;MarkerCluster&gt; {
    val clusters = mutableListOf&lt;MarkerCluster&gt;()
    val unclustered = markers.toMutableList()

    while (unclustered.isNotEmpty()) {
        val seed = unclustered.removeFirst()
        val clusterMembers = mutableListOf(seed)

        val iterator = unclustered.iterator()
        while (iterator.hasNext()) {
            val marker = iterator.next()
            if (calculateDistance(seed.position, marker.position) &lt;= clusterRadius) {
                clusterMembers.add(marker)
                iterator.remove()
            }
        }

        val center = calculateCentroid(clusterMembers.map { it.position })
        clusters.add(MarkerCluster(center, clusterMembers, clusterRadius))
    }

    return clusters
}

fun calculateCentroid(points: List&lt;GeoPoint&gt;): GeoPoint {
    val avgLat = points.map { it.latitude }.average()
    val avgLng = points.map { it.longitude }.average()
    return GeoPointImpl.fromLatLong(avgLat, avgLng)
}
</code></pre>
<h3 id="viewport-based-loading"><a class="header" href="#viewport-based-loading">Viewport-based Loading</a></h3>
<pre><code class="language-kotlin">@Composable
fun ViewportBasedLoadingExample() {
    var currentViewport by remember { mutableStateOf&lt;GeoRectBounds?&gt;(null) }
    var visibleMarkers by remember { mutableStateOf&lt;List&lt;MarkerState&gt;&gt;(emptyList()) }

    // Simulate large dataset
    val allMarkers = remember {
        List(1000) { i -&gt;
            MarkerState(
                position = GeoPointImpl.fromLatLong(
                    37.5 + Random.nextFloat() * 0.5,
                    -122.7 + Random.nextFloat() * 0.5
                ),
                extra = "Marker $i"
            )
        }
    }

    LaunchedEffect(currentViewport) {
        currentViewport?.let { viewport -&gt;
            visibleMarkers = allMarkers.filter { marker -&gt;
                marker.position.latitude &gt;= viewport.southwest.latitude &amp;&amp;
                marker.position.latitude &lt;= viewport.northeast.latitude &amp;&amp;
                marker.position.longitude &gt;= viewport.southwest.longitude &amp;&amp;
                marker.position.longitude &lt;= viewport.northeast.longitude
            }
        }
    }

    Column {
        Text("Visible markers: ${visibleMarkers.size} / ${allMarkers.size}")

        // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(
            state = mapViewState,
            onMapLoaded = {
                // Set initial viewport
                currentViewport = GeoRectBounds(
                    southwest = GeoPointImpl.fromLatLong(37.7, -122.5),
                    northeast = GeoPointImpl.fromLatLong(37.8, -122.3)
                )
            }
        ) {
            visibleMarkers.forEach { marker -&gt;
                Marker(marker)
            }

            // Show viewport bounds
            currentViewport?.let { viewport -&gt;
                val bounds = listOf(
                    viewport.southwest,
                    GeoPointImpl.fromLatLong(viewport.southwest.latitude, viewport.northeast.longitude),
                    viewport.northeast,
                    GeoPointImpl.fromLatLong(viewport.northeast.latitude, viewport.southwest.longitude),
                    viewport.southwest
                )

                Polyline(
                    points = bounds,
                    strokeColor = Color.Red,
                    strokeWidth = 2.dp
                )
            }
        }
    }
}
</code></pre>
<h2 id="custom-components"><a class="header" href="#custom-components">Custom Components</a></h2>
<h3 id="custom-marker-with-animation"><a class="header" href="#custom-marker-with-animation">Custom Marker with Animation</a></h3>
<pre><code class="language-kotlin">@Composable
fun AnimatedMarkerExample() {
    var isAnimating by remember { mutableStateOf(false) }
    var markerScale by remember { mutableStateOf(1.0f) }

    LaunchedEffect(isAnimating) {
        if (isAnimating) {
            while (isAnimating) {
                delay(100)
                markerScale = 1.0f + sin(System.currentTimeMillis() / 300.0).toFloat() * 0.3f
            }
        } else {
            markerScale = 1.0f
        }
    }

    Column {
        Button(onClick = { isAnimating = !isAnimating }) {
            Text(if (isAnimating) "Stop Animation" else "Start Animation")
        }

        // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
            Marker(
                position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
                icon = DefaultIcon(
                    fillColor = Color.Red,
                    label = "🎯",
                    scale = markerScale
                ),
                extra = "Animated marker"
            )
        }
    }
}
</code></pre>
<h3 id="information-overlay-system"><a class="header" href="#information-overlay-system">Information Overlay System</a></h3>
<pre><code class="language-kotlin">@Composable
fun InformationOverlayExample() {
    var selectedFeature by remember { mutableStateOf&lt;String?&gt;(null) }
    var overlayPosition by remember { mutableStateOf&lt;GeoPoint?&gt;(null) }

    val features = mapOf(
        "restaurant" to GeoPointImpl.fromLatLong(37.7749, -122.4194),
        "hotel" to GeoPointImpl.fromLatLong(37.7849, -122.4094),
        "museum" to GeoPointImpl.fromLatLong(37.7649, -122.4294)
    )

    Box {
        // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(
            state = mapViewState,
            onMarkerClick = { markerState -&gt;
                selectedFeature = markerState.extra as? String
                overlayPosition = markerState.position
            },
            onMapClick = {
                selectedFeature = null
                overlayPosition = null
            }
        ) {
            features.forEach { (type, position) -&gt;
                Marker(
                    position = position,
                    icon = DefaultIcon(
                        fillColor = when (type) {
                            "restaurant" -&gt; Color.Red
                            "hotel" -&gt; Color.Blue
                            "museum" -&gt; Color.Green
                            else -&gt; Color.Gray
                        },
                        label = when (type) {
                            "restaurant" -&gt; "🍽️"
                            "hotel" -&gt; "🏨"
                            "museum" -&gt; "🏛️"
                            else -&gt; "?"
                        }
                    ),
                    extra = type
                )
            }
        }

        // Overlay information panel
        selectedFeature?.let { feature -&gt;
            Card(
                modifier = Modifier
                    .align(Alignment.TopStart)
                    .padding(16.dp)
                    .width(200.dp),
                elevation = 8.dp
            ) {
                Column(modifier = Modifier.padding(16.dp)) {
                    Text(
                        text = feature.capitalize(),
                        style = MaterialTheme.typography.h6
                    )
                    Text("Detailed information about this $feature")

                    Row {
                        Button(
                            onClick = { /* Navigate action */ },
                            modifier = Modifier.weight(1f)
                        ) {
                            Text("Navigate")
                        }

                        Button(
                            onClick = { /* More info action */ },
                            modifier = Modifier.weight(1f)
                        ) {
                            Text("Info")
                        }
                    }
                }
            }
        }
    }
}
</code></pre>
<h2 id="data-integration"><a class="header" href="#data-integration">Data Integration</a></h2>
<h3 id="real-time-data-updates"><a class="header" href="#real-time-data-updates">Real-time Data Updates</a></h3>
<pre><code class="language-kotlin">@Composable
fun RealTimeDataExample() {
    var vehiclePositions by remember { mutableStateOf&lt;Map&lt;String, GeoPoint&gt;&gt;(emptyMap()) }
    var lastUpdate by remember { mutableStateOf&lt;Long&gt;(0) }

    // Simulate real-time vehicle tracking
    LaunchedEffect(Unit) {
        while (true) {
            delay(2000) // Update every 2 seconds

            val newPositions = mutableMapOf&lt;String, GeoPoint&gt;()
            repeat(5) { i -&gt;
                val vehicleId = "vehicle_$i"
                val currentPos = vehiclePositions[vehicleId] ?: GeoPointImpl.fromLatLong(
                    37.7749 + Random.nextFloat() * 0.02,
                    -122.4194 + Random.nextFloat() * 0.02
                )

                // Move vehicle slightly
                val newLat = currentPos.latitude + (Random.nextFloat() - 0.5f) * 0.002
                val newLng = currentPos.longitude + (Random.nextFloat() - 0.5f) * 0.002
                newPositions[vehicleId] = GeoPointImpl.fromLatLong(newLat, newLng)
            }

            vehiclePositions = newPositions
            lastUpdate = System.currentTimeMillis()
        }
    }

    Column {
        Text("Last update: ${Date(lastUpdate)}")
        Text("Vehicles: ${vehiclePositions.size}")

        // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
            vehiclePositions.forEach { (vehicleId, position) -&gt;
                Marker(
                    position = position,
                    icon = DefaultIcon(
                        fillColor = Color.Blue,
                        label = "🚗",
                        scale = 1.2f
                    ),
                    extra = vehicleId
                )

                // Vehicle range circle
                Circle(
                    center = position,
                    radius = 200.0,
                    strokeColor = Color.Blue.copy(alpha = 0.5f),
                    fillColor = Color.Blue.copy(alpha = 0.1f)
                )
            }
        }
    }
}
</code></pre>
<h3 id="geofencing-1"><a class="header" href="#geofencing-1">Geofencing</a></h3>
<pre><code class="language-kotlin">@Composable
fun GeofencingExample() {
    var userPosition by remember {
        mutableStateOf(GeoPointImpl.fromLatLong(37.7749, -122.4194))
    }
    var alerts by remember { mutableStateOf&lt;List&lt;String&gt;&gt;(emptyList()) }

    val geofences = listOf(
        Triple(
            GeoPointImpl.fromLatLong(37.7800, -122.4100),
            300.0,
            "Downtown Zone"
        ),
        Triple(
            GeoPointImpl.fromLatLong(37.7700, -122.4300),
            200.0,
            "Restricted Area"
        )
    )

    // Check geofence violations
    LaunchedEffect(userPosition) {
        val newAlerts = mutableListOf&lt;String&gt;()
        geofences.forEach { (center, radius, name) -&gt;
            val distance = calculateDistance(userPosition, center)
            if (distance &lt;= radius) {
                newAlerts.add("Entered: $name")
            }
        }
        alerts = newAlerts
    }

    Column {
        if (alerts.isNotEmpty()) {
            Card(
                backgroundColor = Color.Yellow.copy(alpha = 0.3f),
                modifier = Modifier.padding(8.dp)
            ) {
                Column(modifier = Modifier.padding(16.dp)) {
                    Text("Geofence Alerts:")
                    alerts.forEach { alert -&gt;
                        Text("• $alert")
                    }
                }
            }
        }

        // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(
            state = mapViewState,
            onMapClick = { geoPoint -&gt;
                userPosition = geoPoint
            }
        ) {
            // Draw geofences
            geofences.forEach { (center, radius, name) -&gt;
                Circle(
                    center = center,
                    radius = radius,
                    strokeColor = Color.Red,
                    strokeWidth = 2.dp,
                    fillColor = Color.Red.copy(alpha = 0.1f),
                    extra = name
                )

                Marker(
                    position = center,
                    icon = DefaultIcon(
                        fillColor = Color.Red,
                        label = name.first().toString(),
                        scale = 0.8f
                    )
                )
            }

            // User position
            Marker(
                position = userPosition,
                icon = DefaultIcon(
                    fillColor = Color.Blue,
                    label = "👤",
                    scale = 1.2f
                ),
                draggable = true
            )
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="event-handlers-1"><a class="header" href="#event-handlers-1">Event Handlers</a></h1>
<p>MapConductor provides comprehensive event handling for user interactions with the map and its components. All events are handled through the <code>MapViewContainer</code> component.</p>
<h2 id="map-events"><a class="header" href="#map-events">Map Events</a></h2>
<h3 id="map-initialization"><a class="header" href="#map-initialization">Map Initialization</a></h3>
<pre><code class="language-kotlin">onMapViewInitialized: OnMapViewInitializedHandler? = null
</code></pre>
<p>Called when the map view is first initialized.</p>
<pre><code class="language-kotlin">onMapLoaded: OnMapLoadedHandler? = null
</code></pre>
<p>Called when the map has finished loading and is ready for interaction.</p>
<h3 id="map-interaction"><a class="header" href="#map-interaction">Map Interaction</a></h3>
<pre><code class="language-kotlin">onMapClick: OnMapEventHandler? = null
</code></pre>
<p>Called when the user taps on the map (not on any overlay).</p>
<p><strong>Event Data</strong>: <code>GeoPoint</code> - the geographic coordinates of the tap</p>
<h2 id="marker-events"><a class="header" href="#marker-events">Marker Events</a></h2>
<p>All marker events receive a <code>MarkerState</code> object containing the marker’s current state.</p>
<h3 id="click-events"><a class="header" href="#click-events">Click Events</a></h3>
<pre><code class="language-kotlin">onMarkerClick: OnMarkerEventHandler? = null
</code></pre>
<p>Called when a marker is tapped.</p>
<h3 id="drag-events"><a class="header" href="#drag-events">Drag Events</a></h3>
<pre><code class="language-kotlin">onMarkerDragStart: OnMarkerEventHandler? = null
onMarkerDrag: OnMarkerEventHandler? = null
onMarkerDragEnd: OnMarkerEventHandler? = null
</code></pre>
<ul>
<li><strong><code>onMarkerDragStart</code></strong>: Called when dragging begins</li>
<li><strong><code>onMarkerDrag</code></strong>: Called continuously during dragging</li>
<li><strong><code>onMarkerDragEnd</code></strong>: Called when dragging ends</li>
</ul>
<h3 id="animation-events"><a class="header" href="#animation-events">Animation Events</a></h3>
<pre><code class="language-kotlin">onMarkerAnimateStart: OnMarkerEventHandler? = null
onMarkerAnimateEnd: OnMarkerEventHandler? = null
</code></pre>
<p>Called when marker animations start and end.</p>
<h2 id="overlay-events"><a class="header" href="#overlay-events">Overlay Events</a></h2>
<h3 id="circle-events"><a class="header" href="#circle-events">Circle Events</a></h3>
<pre><code class="language-kotlin">onCircleClick: OnCircleEventHandler? = null
</code></pre>
<p><strong>Event Data</strong>: <code>CircleEvent</code></p>
<pre><code class="language-kotlin">data class CircleEvent(
    val state: CircleState,
    val clicked: GeoPoint
)
</code></pre>
<h3 id="polyline-events"><a class="header" href="#polyline-events">Polyline Events</a></h3>
<pre><code class="language-kotlin">onPolylineClick: OnPolylineEventHandler? = null
</code></pre>
<p><strong>Event Data</strong>: <code>PolylineEvent</code></p>
<pre><code class="language-kotlin">data class PolylineEvent(
    val state: PolylineState,
    val clicked: GeoPoint
)
</code></pre>
<h3 id="polygon-events"><a class="header" href="#polygon-events">Polygon Events</a></h3>
<pre><code class="language-kotlin">onPolygonClick: OnPolygonEventHandler? = null
</code></pre>
<p><strong>Event Data</strong>: <code>PolygonEvent</code></p>
<pre><code class="language-kotlin">data class PolygonEvent(
    val state: PolygonState,
    val clicked: GeoPoint?
)
</code></pre>
<h3 id="groundimage-events"><a class="header" href="#groundimage-events">GroundImage Events</a></h3>
<pre><code class="language-kotlin">onGroundImageClick: OnGroundImageEventHandler? = null
</code></pre>
<p><strong>Event Data</strong>: <code>GroundImageEvent</code></p>
<pre><code class="language-kotlin">data class GroundImageEvent(
    val state: GroundImageState,
    val clicked: GeoPointImpl?
)
</code></pre>
<h2 id="usage-examples-15"><a class="header" href="#usage-examples-15">Usage Examples</a></h2>
<h3 id="basic-event-handling"><a class="header" href="#basic-event-handling">Basic Event Handling</a></h3>
<pre><code class="language-kotlin">// Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(
    state = mapViewState,
    onMapClick = { geoPoint -&gt;
        println("Map clicked at: ${geoPoint.latitude}, ${geoPoint.longitude}")
    },
    onMarkerClick = { markerState -&gt;
        println("Marker clicked: ${markerState.extra}")
    },
    onCircleClick = { circleEvent -&gt;
        println("Circle clicked: ${circleEvent.state.extra}")
    }
) {
    // Map content
}
</code></pre>
<h3 id="advanced-event-handling-1"><a class="header" href="#advanced-event-handling-1">Advanced Event Handling</a></h3>
<pre><code class="language-kotlin">@Composable
fun AdvancedEventHandlingExample() {
    var selectedItem by remember { mutableStateOf&lt;String?&gt;(null) }
    var draggedMarker by remember { mutableStateOf&lt;MarkerState?&gt;(null) }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(
        state = mapViewState,
        onMapClick = { geoPoint -&gt;
            selectedItem = null
            println("Map clicked at: $geoPoint")
        },
        onMarkerClick = { markerState -&gt;
            selectedItem = "Marker: ${markerState.extra}"
        },
        onMarkerDragStart = { markerState -&gt;
            draggedMarker = markerState
            println("Started dragging: ${markerState.id}")
        },
        onMarkerDrag = { markerState -&gt;
            draggedMarker = markerState
            println("Dragging to: ${markerState.position}")
        },
        onMarkerDragEnd = { markerState -&gt;
            draggedMarker = null
            println("Finished dragging: ${markerState.id}")
        },
        onCircleClick = { circleEvent -&gt;
            selectedItem = "Circle: ${circleEvent.state.extra}"
        },
        onPolylineClick = { polylineEvent -&gt;
            selectedItem = "Polyline: ${polylineEvent.state.extra}"
        },
        onPolygonClick = { polygonEvent -&gt;
            selectedItem = "Polygon: ${polygonEvent.state.extra}"
        }
    ) {
        // Map components
    }

    // Show selected item info
    selectedItem?.let { item -&gt;
        Card(modifier = Modifier.padding(16.dp)) {
            Text(item, modifier = Modifier.padding(16.dp))
        }
    }
}
</code></pre>
<h3 id="conditional-event-handling"><a class="header" href="#conditional-event-handling">Conditional Event Handling</a></h3>
<pre><code class="language-kotlin">@Composable
fun ConditionalEventExample() {
    var editMode by remember { mutableStateOf(false) }
    var selectedMarkers by remember { mutableStateOf&lt;Set&lt;String&gt;&gt;(emptySet()) }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(
        state = mapViewState,
        onMapClick = { geoPoint -&gt;
            if (editMode) {
                // Add new marker in edit mode
                addNewMarker(geoPoint)
            } else {
                // Clear selection in view mode
                selectedMarkers = emptySet()
            }
        },
        onMarkerClick = { markerState -&gt;
            if (editMode) {
                // Toggle selection in edit mode
                selectedMarkers = if (markerState.id in selectedMarkers) {
                    selectedMarkers - markerState.id
                } else {
                    selectedMarkers + markerState.id
                }
            } else {
                // Show info in view mode
                showMarkerInfo(markerState)
            }
        },
        onMarkerDragStart = { markerState -&gt;
            if (!editMode) {
                // Prevent dragging in view mode
                return@MapViewContainer
            }
        }
    ) {
        // Map content
    }
}
</code></pre>
<h3 id="event-debouncing"><a class="header" href="#event-debouncing">Event Debouncing</a></h3>
<pre><code class="language-kotlin">@Composable
fun DebouncedEventExample() {
    var searchLocation by remember { mutableStateOf&lt;GeoPoint?&gt;(null) }

    // Debounce search to avoid excessive API calls
    LaunchedEffect(searchLocation) {
        searchLocation?.let { location -&gt;
            delay(500) // Wait 500ms
            performLocationSearch(location)
        }
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(
        state = mapViewState,
        onMapClick = { geoPoint -&gt;
            searchLocation = geoPoint
        }
    ) {
        searchLocation?.let { location -&gt;
            Marker(
                position = location,
                icon = DefaultIcon(
                    fillColor = Color.Blue,
                    label = "🔍"
                )
            )
        }
    }
}
</code></pre>
<h3 id="multi-touch-gesture-events"><a class="header" href="#multi-touch-gesture-events">Multi-touch Gesture Events</a></h3>
<pre><code class="language-kotlin">@Composable
fun GestureEventExample() {
    var gestureInfo by remember { mutableStateOf("No gesture") }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(
        state = mapViewState,
        onMapClick = { geoPoint -&gt;
            gestureInfo = "Single tap at: $geoPoint"
        },
        // Note: Long press and other gestures would be handled
        // through the underlying map provider's gesture system
    ) {
        // Display gesture info
        Text(
            text = gestureInfo,
            modifier = Modifier
                .background(Color.Black.copy(alpha = 0.7f))
                .padding(8.dp),
            color = Color.White
        )
    }
}
</code></pre>
<h2 id="event-handler-types"><a class="header" href="#event-handler-types">Event Handler Types</a></h2>
<pre><code class="language-kotlin">typealias OnMapViewInitializedHandler = () -&gt; Unit
typealias OnMapLoadedHandler = () -&gt; Unit
typealias OnMapEventHandler = (GeoPoint) -&gt; Unit
typealias OnMarkerEventHandler = (MarkerState) -&gt; Unit
typealias OnCircleEventHandler = (CircleEvent) -&gt; Unit
typealias OnPolylineEventHandler = (PolylineEvent) -&gt; Unit
typealias OnPolygonEventHandler = (PolygonEvent) -&gt; Unit
typealias OnGroundImageEventHandler = (GroundImageEvent) -&gt; Unit
</code></pre>
<h2 id="best-practices-25"><a class="header" href="#best-practices-25">Best Practices</a></h2>
<ol>
<li><strong>Performance</strong>: Avoid heavy computations in event handlers</li>
<li><strong>State Updates</strong>: Use event handlers to update your application state</li>
<li><strong>User Feedback</strong>: Provide immediate visual feedback for user interactions</li>
<li><strong>Error Handling</strong>: Handle potential null values and edge cases</li>
<li><strong>Debouncing</strong>: Debounce rapid events like dragging to improve performance</li>
<li><strong>Conditional Logic</strong>: Use application state to determine event behavior</li>
<li><strong>Event Propagation</strong>: Be aware that some events may bubble up or be consumed</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="initialization-1"><a class="header" href="#initialization-1">Initialization</a></h1>
<p>This section covers how to properly initialize and configure MapConductor for different map providers.</p>
<h2 id="basic-initialization"><a class="header" href="#basic-initialization">Basic Initialization</a></h2>
<h3 id="gradle-dependencies"><a class="header" href="#gradle-dependencies">Gradle Dependencies</a></h3>
<p>Add MapConductor to your <code>build.gradle.kts</code>:</p>
<pre><code class="language-kotlin">dependencies {
    implementation "com.mapconductor:mapconductor-bom:$version"
    implementation "com.mapconductor:core"

    // Choose your map provider(s)
    implementation "com.mapconductor:for-googlemaps"
    implementation "com.mapconductor:for-mapbox"
    implementation "com.mapconductor:for-here"
    implementation "com.mapconductor:for-arcgis"
}
</code></pre>
<h3 id="map-provider-setup"><a class="header" href="#map-provider-setup">Map Provider Setup</a></h3>
<p>Each map provider requires specific setup and API keys.</p>
<h4 id="google-maps-2"><a class="header" href="#google-maps-2">Google Maps</a></h4>
<pre><code class="language-kotlin">// In your Activity or Fragment
@Composable
fun GoogleMapsExample() {
    val mapViewState = rememberGoogleMapViewState()

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
        // Map content
    }
}
</code></pre>
<h4 id="mapbox-2"><a class="header" href="#mapbox-2">Mapbox</a></h4>
<pre><code class="language-kotlin">@Composable
fun MapboxExample() {
    val mapViewState = rememberMapboxMapViewState()

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
        // Map content
    }
}
</code></pre>
<h4 id="here-maps-2"><a class="header" href="#here-maps-2">HERE Maps</a></h4>
<pre><code class="language-kotlin">@Composable
fun HereExample() {
    val mapViewState = rememberHereMapViewState()

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
        // Map content
    }
}
</code></pre>
<h4 id="arcgis-2"><a class="header" href="#arcgis-2">ArcGIS</a></h4>
<pre><code class="language-kotlin">@Composable
fun ArcGISExample() {
    val mapViewState = rememberArcGISMapViewState()

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
        // Map content
    }
}
</code></pre>
<h2 id="advanced-initialization"><a class="header" href="#advanced-initialization">Advanced Initialization</a></h2>
<h3 id="custom-map-configuration"><a class="header" href="#custom-map-configuration">Custom Map Configuration</a></h3>
<pre><code class="language-kotlin">@Composable
fun CustomMapConfiguration() {
    val mapViewState = remember {
        GoogleMapViewStateImpl().apply {
            // Set initial camera position
            initCameraPosition = MapCameraPositionImpl(
                target = GeoPointImpl.fromLatLong(37.7749, -122.4194),
                zoom = 12f,
                bearing = 45f,
                tilt = 30f
            )

            // Set map design/style
            mapDesignType = GoogleMapDesignType.SATELLITE
        }
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(
        state = mapViewState,
        onMapViewInitialized = {
            println("Map view initialized")
        },
        onMapLoaded = {
            println("Map loaded and ready")
        }
    ) {
        // Map content
    }
}
</code></pre>
<h3 id="provider-selection-at-runtime"><a class="header" href="#provider-selection-at-runtime">Provider Selection at Runtime</a></h3>
<pre><code class="language-kotlin">@Composable
fun DynamicProviderSelection() {
    var selectedProvider by remember { mutableStateOf("google") }

    val mapViewState = remember(selectedProvider) {
        when (selectedProvider) {
            "google" -&gt; rememberGoogleMapViewState()
            "mapbox" -&gt; rememberMapboxMapViewState()
            "here" -&gt; rememberHereMapViewState()
            "arcgis" -&gt; rememberArcGISMapViewState()
            else -&gt; rememberGoogleMapViewState()
        }
    }

    Column {
        // Provider selection UI
        LazyRow {
            items(listOf("google", "mapbox", "here", "arcgis")) { provider -&gt;
                Button(
                    onClick = { selectedProvider = provider },
                    colors = if (provider == selectedProvider) {
                        ButtonDefaults.buttonColors(backgroundColor = Color.Blue)
                    } else {
                        ButtonDefaults.buttonColors()
                    }
                ) {
                    Text(provider.capitalize())
                }
            }
        }

        // Map with selected provider
        // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
            Marker(
                position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
                icon = DefaultIcon(label = selectedProvider.uppercase())
            )
        }
    }
}
</code></pre>
<h3 id="initialization-state-handling"><a class="header" href="#initialization-state-handling">Initialization State Handling</a></h3>
<pre><code class="language-kotlin">@Composable
fun InitializationStateExample() {
    val mapViewState = rememberGoogleMapViewState()
    val initState by mapViewState.isInitialized.collectAsState()

    when (initState) {
        InitState.NotStarted -&gt; {
            // Show loading placeholder
            Box(
                modifier = Modifier.fillMaxSize(),
                contentAlignment = Alignment.Center
            ) {
                Column(horizontalAlignment = Alignment.CenterHorizontally) {
                    CircularProgressIndicator()
                    Text("Preparing map...")
                }
            }
        }

        InitState.Initializing -&gt; {
            // Show initialization progress
            Box(
                modifier = Modifier.fillMaxSize(),
                contentAlignment = Alignment.Center
            ) {
                Column(horizontalAlignment = Alignment.CenterHorizontally) {
                    CircularProgressIndicator()
                    Text("Loading map...")
                }
            }
        }

        InitState.Initialized -&gt; {
            // Show the map
            // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
                // Map is ready for content
                Marker(
                    position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
                    icon = DefaultIcon(label = "Ready!")
                )
            }
        }

        InitState.Failed -&gt; {
            // Show error state
            Box(
                modifier = Modifier.fillMaxSize(),
                contentAlignment = Alignment.Center
            ) {
                Column(horizontalAlignment = Alignment.CenterHorizontally) {
                    Icon(
                        Icons.Default.Error,
                        contentDescription = "Error",
                        tint = Color.Red,
                        modifier = Modifier.size(48.dp)
                    )
                    Text("Failed to load map")
                    Button(
                        onClick = { mapViewState.resetInitState() }
                    ) {
                        Text("Retry")
                    }
                }
            }
        }
    }
}
</code></pre>
<h3 id="deferred-initialization"><a class="header" href="#deferred-initialization">Deferred Initialization</a></h3>
<pre><code class="language-kotlin">@Composable
fun DeferredInitializationExample() {
    var shouldInitialize by remember { mutableStateOf(false) }
    val mapViewState = rememberGoogleMapViewState()

    Column {
        if (!shouldInitialize) {
            Button(
                onClick = { shouldInitialize = true },
                modifier = Modifier.fillMaxWidth().padding(16.dp)
            ) {
                Text("Load Map")
            }
        }

        if (shouldInitialize) {
            // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(
                state = mapViewState,
                shouldInitialize = shouldInitialize
            ) {
                Marker(
                    position = GeoPointImpl.fromLatLong(37.7749, -122.4194),
                    icon = DefaultIcon(label = "Loaded!")
                )
            }
        }
    }
}
</code></pre>
<h3 id="custom-rendering-strategy"><a class="header" href="#custom-rendering-strategy">Custom Rendering Strategy</a></h3>
<pre><code class="language-kotlin">@Composable
fun CustomRenderingExample() {
    val mapViewState = rememberGoogleMapViewState()

    // Custom marker rendering strategy
    val customStrategy = remember {
        object : MarkerRenderingStrategy&lt;GoogleMapActualMarker&gt; {
            override suspend fun render(
                markers: Map&lt;String, MarkerState&gt;,
                controller: MapViewController
            ) {
                // Custom rendering logic
                // This is an advanced feature for specific use cases
            }
        }
    }

    // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(
        state = mapViewState,
        renderingStrategy = customStrategy
    ) {
        // Map content with custom rendering
    }
}
</code></pre>
<h2 id="configuration-options"><a class="header" href="#configuration-options">Configuration Options</a></h2>
<h3 id="camera-position"><a class="header" href="#camera-position">Camera Position</a></h3>
<pre><code class="language-kotlin">val cameraPosition = MapCameraPositionImpl(
    target = GeoPointImpl.fromLatLong(37.7749, -122.4194),
    zoom = 15f,
    bearing = 0f,  // Rotation in degrees
    tilt = 0f      // Tilt angle in degrees
)

mapViewState.initCameraPosition = cameraPosition
</code></pre>
<h3 id="map-bounds"><a class="header" href="#map-bounds">Map Bounds</a></h3>
<pre><code class="language-kotlin">// Set initial map bounds
val bounds = GeoRectBounds(
    southwest = GeoPointImpl.fromLatLong(37.7049, -122.4794),
    northeast = GeoPointImpl.fromLatLong(37.8049, -122.3594)
)

// Move camera to show bounds
mapViewState.moveCameraTo(bounds)
</code></pre>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<h3 id="initialization-failures"><a class="header" href="#initialization-failures">Initialization Failures</a></h3>
<pre><code class="language-kotlin">@Composable
fun RobustInitializationExample() {
    val mapViewState = rememberGoogleMapViewState()
    val initState by mapViewState.isInitialized.collectAsState()
    var retryCount by remember { mutableStateOf(0) }

    LaunchedEffect(initState) {
        if (initState == InitState.Failed) {
            // Log error and potentially retry
            println("Map initialization failed (attempt ${retryCount + 1})")

            if (retryCount &lt; 3) {
                delay(1000) // Wait before retry
                retryCount++
                mapViewState.resetInitState()
            }
        } else if (initState == InitState.Initialized) {
            retryCount = 0 // Reset on success
        }
    }

    when (initState) {
        InitState.Failed -&gt; {
            if (retryCount &gt;= 3) {
                ErrorScreen(onRetry = {
                    retryCount = 0
                    mapViewState.resetInitState()
                })
            } else {
                LoadingScreen("Retrying...")
            }
        }
        else -&gt; {
            // Replace MapView with your chosen map provider, such as GoogleMapsView, MapboxMapView
MapView(state = mapViewState) {
                // Map content
            }
        }
    }
}

@Composable
fun ErrorScreen(onRetry: () -&gt; Unit) {
    Column(
        modifier = Modifier.fillMaxSize(),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        Text("Map failed to load")
        Button(onClick = onRetry) {
            Text("Retry")
        }
    }
}

@Composable
fun LoadingScreen(message: String) {
    Box(
        modifier = Modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Column(horizontalAlignment = Alignment.CenterHorizontally) {
            CircularProgressIndicator()
            Text(message)
        }
    }
}
</code></pre>
<h2 id="best-practices-26"><a class="header" href="#best-practices-26">Best Practices</a></h2>
<ol>
<li><strong>Use remember</strong>: Always wrap MapViewState creation in <code>remember</code></li>
<li><strong>Handle States</strong>: Properly handle all initialization states</li>
<li><strong>Error Recovery</strong>: Implement retry logic for failed initializations</li>
<li><strong>Resource Management</strong>: Let the SDK handle lifecycle management</li>
<li><strong>API Keys</strong>: Ensure proper API key configuration for each provider</li>
<li><strong>Performance</strong>: Consider deferred initialization for better app startup</li>
<li><strong>Testing</strong>: Test with different providers to ensure compatibility</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
